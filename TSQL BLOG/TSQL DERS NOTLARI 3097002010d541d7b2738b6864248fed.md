# TSQL DERS NOTLARI

## SQL SERVER STRING FUNCTION

***ASCII FONKSÄ°YONU:*** Bir karakterin ascii deÄŸerini dÃ¶ndÃ¼rÃ¼r. Verinin iÃ§erisinde gÃ¶rÃ¼nmeyen veya kirli karakterleri temizlemek iÃ§in kullanÄ±lÄ±r. 

Her bir karakterin bilgisayar dilinde bir sayÄ±sal deÄŸeri vardÄ±r. ASCII fonksiyonu ise belirtilen karakterin ascii tablosundaki sayÄ±sal deÄŸerini vermektedir.

*Ã–rneÄŸin:*

```sql
SELECT ASCII('B') // 66

SELECT ASCII('A') // 65

SELECT ASCII('!') // 33

SELECT ASCII('.') // 46

SELECT ASCII('$') // 36

SELECT ASCII(' ') // 32
```

Bu deÄŸerlerin her biri karakter tÃ¼rÃ¼nde olan verilerin ascii tablosundaki sayÄ±sal karÅŸÄ±lÄ±klarÄ±nÄ± vermektedir. Ã–rneÄŸin â€˜Aâ€™ harfinin ascii tablosundaki sayÄ±sal karÅŸÄ±lÄ±ÄŸÄ± â€˜65â€™ tir. 

***CHAR FONKSÄ°YONU:*** Bir sayÄ±sal deÄŸerin ascii tablosundaki karakter deÄŸerini dÃ¶ndÃ¼rmektedir. KullanÄ±m ÅŸekli yine aynÄ± ÅŸekilde kirli verileri temizlemek veya veri manipÃ¼lasyonlarÄ±nÄ± gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±lÄ±r. 

Ã–nceden de bahsedildiÄŸi gibi bilgisayar dilinde her bir karakterin bir sayÄ±sal deÄŸeri vardÄ±r. CHAR fonksiyonu ise sayÄ±sal deÄŸerin ascii tablosundaki karakter deÄŸerini vermektedir.

*Ã–rneÄŸin:*

```sql
SELECT CHAR(65) // A

SELECT CHAR(66)  // B

SELECT CHAR(33) // !

SELECT CHAR(46) // .

SELECT CHAR(36) // $
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi bu ÅŸekilde kullanÄ±lÄ±r. Ancak bazÄ± durumlardan kurtulabilmek iÃ§in ascii fonksiyonu ile char fonksiyonu beraber kullanÄ±lÄ±r. Ã–rneÄŸin ascii tablosunda enter yani alt satÄ±r karakterinin deÄŸeri 13â€™tÃ¼r. Bunu ascii fonksiyonuyla yakalamak mÃ¼mkÃ¼ndÃ¼r. Ancak char fonksiyonuyla 13 parametresini girerseniz bu fonksiyon bizlere sadece boÅŸ veri dÃ¶ndÃ¼recektir.

*Ã–rneÄŸin:*

```sql
SELECT ASCII('
') // 13

SELECT CHAR(13) // boÅŸluk verisi dÃ¶ndÃ¼rÃ¼r.
```

YukarÄ±daki kod parÃ§acÄ±ÄŸÄ±nda ascii olarak alt satÄ±ra geÃ§ilmiÅŸ karakterin sayÄ±sal deÄŸeri verilirken char ise bunu boÅŸluk olarak dÃ¶ndÃ¼rmektedir. Ä°ÅŸte bu tip hatalardan kaÃ§Ä±nmak iÃ§in Ã§oÄŸu zaman ascii fonksiyonuyla char fonksiyonu beraber kullanÄ±lmaktadÄ±r.

***CONCAT FONKSÄ°YONU:*** Ä°ki veya daha fazla karakter ifadelerini birleÅŸtirmek iÃ§in kullanÄ±lan bir fonksiyondur. 

*Ã–rneÄŸin:*

```sql
SELECT CONCAT('Kelime','BirleÅŸtirildi!') -- KelimeBirleÅŸtirildi!

SELECT CONCAT('Kelime',' ','BirleÅŸtirildi!') -- Kelime BirleÅŸtirildi!

SELECT CONCAT('Bu',' ','ÅŸekilde',' ','birden',' ','fazla',' ','kelimeyi',' ','de',' ','birleÅŸtirebiliriz!')
-- Bu ÅŸekilde birden fazla kelimeyi de birleÅŸtirebiliriz!
```

Bu ÅŸekilde karakter tÃ¼rÃ¼nde olan verileri birleÅŸtirmemize olanak saÄŸlamaktadÄ±r. AyrÄ±ca toplama (+) iÅŸareti kullanarak da karakter verilerini birleÅŸtirebiliriz.

*Ã–rneÄŸin:*

```sql
SELECT 'Toplama'+' '+'birleÅŸtirme' -- Toplama birleÅŸtirme
```

Bu ÅŸekilde de iki veya daha fazla karakter verilerini birleÅŸtirebiliriz. Ancak bu tip birleÅŸtirmeler bazen sorunlara neden olabilmektedir. Ã‡Ã¼nkÃ¼ toplam deÄŸiÅŸkenleri yani â€œ+â€ iÅŸareti MSSQL iÃ§erisinde farklÄ± yerlerde de kullanÄ±labilir. O yÃ¼zden dolayÄ± genellikle concat fonksiyonuyla birleÅŸtirme yapmak daha efektif bir Ã§alÄ±ÅŸma saÄŸlamaktadÄ±r.

***LEFT-RIGHT FONKSÄ°YONLARI:*** Bir string deÄŸerini saÄŸdan veya soldan belirtilen parametreye gÃ¶re bÃ¶lmeye olanak saÄŸlayan bir fonksiyondur.

*Ã–rneÄŸin:*

```sql
SELECT RIGHT('SÃ¼per Lig',3) // "Lig"

SELECT RIGHT('SÃ¼per Lig',6) // "er Lig"

SELECT LEFT('SÃ¼per Lig', 5) // "SÃ¼per"

SELECT LEFT('SÃ¼per Lig',8) // "SÃ¼per Li"
```

Bu ÅŸekilde karakter verilerini saÄŸdan veya soldan belirtilen karakter sayÄ±sÄ± kadar bÃ¶lmemize olanak saÄŸlayan bir fonksiyon olarak karÅŸÄ±mÄ±za Ã§Ä±kmaktadÄ±r.

***TRIM-LTRIM-RTRIM FONKSÄ°YONLARI:*** TRIM fonksiyonu bir string verisindeki baÅŸÄ±ndaki veya sonundaki boÅŸluk karakterlerini silmeye olanak saÄŸlar. LTRIM ve RTRIM ise soldan veya saÄŸdan baÅŸÄ±nda boÅŸluk olan karakterlerin boÅŸluklarÄ±nÄ± silmeye olanak saÄŸlamaktadÄ±r.

*Ã–rneÄŸin:*

```sql
// BaÅŸÄ±ndaki ve sonundaki boÅŸluklarÄ± siler.
SELECT TRIM(' SÃ¼per Lig ') // "SÃ¼per Lig" 

// Soldan yani baÅŸÄ±ndaki boÅŸluklarÄ± siler.
SELECT LTRIM(' SÃ¼per Lig ') // "SÃ¼per Lig "

// SaÄŸdan yani sondaki boÅŸluklarÄ± siler.
SELECT RTRIM(' SÃ¼per Lig ') // " SÃ¼per Lig"
```

TRIM Fonksiyonu sadece ama sadece baÅŸÄ±ndaki ve sonundaki boÅŸluk karakterlerini silmeye olanak saÄŸlar. Kod parÃ§acÄ±ÄŸÄ±nda da gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi ortadaki boÅŸluk karakterini silmez. 

***LOWER-UPPER-REVERSE-REPLICATE FONKSÄ°YONLARI:*** 

- *Lower Fonksiyonu:* Belirtilen karakter deÄŸerini kÃ¼Ã§Ã¼k harflere dÃ¶nÃ¼ÅŸtÃ¼rme fonksiyonudur.
- *Upper Fonksiyonu:* Belirtilen karakter deÄŸerini bÃ¼yÃ¼k harflere dÃ¶nÃ¼ÅŸtÃ¼rme fonksiyonudur.
- *Reverse Fonksiyonu:* Belirtilen karakter deÄŸerini tersten yazdÄ±rmaya olanak saÄŸlayan bir fonksiyondur.
- *Replicate Fonksiyonu:* Belirtilen karakter deÄŸerini girilen girdi parametresine gÃ¶re tekrar yazdÄ±ran bir fonksiyondur.

*Ã–rneÄŸin:*

```sql
SELECT LOWER('SÃœPER LÄ°G') // sÃ¼per lig
SELECT LOWER('SÃ¼PeR LiG') // sÃ¼per lig

SELECT UPPER('sÃ¼per lig') // SÃœPER LÄ°G
SELECT UPPER('SÃ¼Per lÄ°G') // SÃœPER LÄ°G
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi lower fonksiyonu girilen karakter deÄŸerlerini kÃ¼Ã§Ã¼k harflere uygun olarak dÃ¶nÃ¼ÅŸtÃ¼rÃ¼rken, upper ise bÃ¼yÃ¼k harflere dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemini yapmaktadÄ±r. 

<aside>
ğŸ’¡ Ä°ngilizceâ€™de ve TÃ¼rkÃ§eâ€™de karakter aÃ§Ä±sÄ±ndan farklÄ±lÄ±klar vardÄ±r. Ã–rneÄŸin TÃ¼rkÃ§eâ€™de bÃ¼yÃ¼k i harfi (Ä°) varken Ä°ngilizceâ€™de bu harften bulunmamaktadÄ±r. MSSQL bu karakter dÃ¶nÃ¼ÅŸÃ¼mlerinde ise kurulum esnasÄ±nda mevcut veritabanÄ±nÄ±n collition deÄŸerine gÃ¶re hareket etmektedir. Ã–rneÄŸin collation deÄŸeri Turkish_CI ise bÃ¼yÃ¼k (Ä°) dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼ saÄŸlamaktadÄ±r. Ancak bu deÄŸeri Ä°ngilizce olarak tutarsak lower ve upper fonksiyonlarÄ±nda (i) harfi (I) olarak dÃ¶nÃ¼ÅŸÃ¼rken, (I) harfi ise (i) olarak dÃ¶nÃ¼ÅŸecektir.

</aside>

*Ã–rneÄŸin:*

```sql
SELECT LOWER('DATA SCIENCE') // data scÄ±ence
SELECT UPPER('data science') // DATA SCÄ°ENCE
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi burada dÃ¶nÃ¼ÅŸÃ¼m saÄŸlanmadÄ± Ã§Ã¼nkÃ¼ ben kurulumda collation deÄŸerini â€˜Turkish_CIâ€™ olarak belirtmiÅŸtim. Ä°ÅŸte veri tabanlarÄ±nÄ±n kurulum esnasÄ±nda bu deÄŸerlere Ã¶nem vermek gerekmektedir.

AyrÄ±ca benim veri tabanÄ±mÄ±n kurulum ayarlarÄ± ÅŸu ÅŸekildedir.

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi dil ayarlarÄ± TÃ¼rkÃ§e olduÄŸu iÃ§in bu fonksiyon bende problem Ã§Ä±kartabilir. EÄŸer ki Ä°ngilizce bir veriyle Ã§alÄ±ÅŸacaksanÄ±z bu veri tabanÄ± ayarlarÄ±ndan Server Collation deÄŸerini Ä°ngilizce olarak belirtmek gerekir.

<aside>
ğŸ’¡ TÃ¼rkÃ§e olarak ayarlanan bir veritabanÄ±nda ingilizce yazÄ± dilinde sorgu Ã§alÄ±ÅŸtÄ±rmak istersek ise collate fonksiyonuyla bunu dÃ¼zeltebiliriz.

</aside>

***Ã–rneÄŸin:***

Washington kelimesi, Ä°ngilizce bir kelimedir. EÄŸer ki â€˜Turkish_CI_ASâ€™ ayarlanmÄ±ÅŸ veri tabanÄ±nda `UPPER()` fonksiyonu Ã§alÄ±ÅŸtÄ±rÄ±rsak bize dÃ¶nÃ¼ÅŸÃ¼m olarak â€œWASHÄ°NGTONâ€ olarak dÃ¶nÃ¼ÅŸ saÄŸlayacaktÄ±r. Ä°ngilizceâ€™de â€œÄ°â€ harfi gibi bir harf tanÄ±mlÄ± olmadÄ±ÄŸÄ± iÃ§in bu hatalÄ± bir dÃ¶nÃ¼ÅŸÃ¼m olacaktÄ±r. Ä°ÅŸte bu hatadan kurtulmak iÃ§in ÅŸÃ¶yle bir sorgu Ã§alÄ±ÅŸtÄ±rmamÄ±z gerekir.

```sql
SELECT 'washington'

SELECT UPPER('washington') -- WASHÄ°NGTON (hatalÄ± ifade)

/*

hatadan kurtulmak iÃ§in --> collate sql_latin1_general_cp1_ci_as 

*/

-- Ã–rnek:

SELECT UPPER('washington' collate sql_latin1_general_cp1_ci_as) -- WASHINGTON
```

Bu ÅŸekilde sorunu Ã§Ã¶zebiliriz.

***Reverse Fonksiyonu*** ise girilen kelime parametresini tersten yazdÄ±rmaya olanak saÄŸlamaktadÄ±r. 

*Ã–rneÄŸin:*

```sql
SELECT REVERSE('SÃ¼per Lig') // giL repÃ¼S

SELECT REVERSE('Microsoft TSQL') // LQST tfosorciM

SELECT REVERSE('AMBULANS') 
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi ifadeleri komple tersten yazdÄ±rmaya olanak saÄŸlamaktadÄ±r. 

<aside>
ğŸ’¡ Bu fonksiyon genellikle yÃ¼ksek hacimli veri setlerinde arama yaparken kullanÄ±lÄ±r. Ã–rneÄŸin ad soyad ve adres bilgilerinden oluÅŸan Ã§ok hacimli bir veri seti iÃ§erisinden soyadÄ± ile ilgili sorgular Ã§alÄ±ÅŸtÄ±rÄ±rsanÄ±z â€˜like %â€™ ifadesi gibi sorgularÄ±n Ã§alÄ±ÅŸmasÄ± Ã§ok zor olacaktÄ±r. Ã‡Ã¼nkÃ¼ iÃ§erisinde belirli bir deÄŸerin var olduÄŸunu bildiÄŸiniz deÄŸerlerde veri tabanÄ± indeksleme yapamaz. Ä°ÅŸte reverse komutuyla birlikte veri tabanÄ± bu indekslemeyi gerÃ§ekleÅŸtirir ve daha performanslÄ± bir ÅŸekilde Ã§alÄ±ÅŸmasÄ±na olanak saÄŸlamaktadÄ±r.

</aside>

***Replicate fonksiyonu*** ise girilen kelime parametresini ve diÄŸer girilen sayÄ±sal girdi parametresi kadar tekrar tekrar yan yana yazdÄ±rmaya olanak saÄŸlayan bir fonksiyondur.

*Ã–rneÄŸin:*

```sql
SELECT REPLICATE('LOSC', 5) // LOSCLOSCLOSCLOSCLOSC

SELECT REPLICATE('TSQL ', 3) // TSQL TSQL TSQL 
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi ilk fonksiyonda â€˜LOSCâ€™ ifadesini yan yana 5 defa yazdÄ±rÄ±rken, ikinci replicate fonksiyonunda ise â€˜TSQL â€™ ifadesini 3 defa yan yana yazdÄ±rarak yeni bir veri oluÅŸturdu.

<aside>
ğŸ’¡ Replicate fonksiyonu gerÃ§ek hayatta bazÄ± algoritmik olarak yapÄ±lan problemlerde Ã§Ã¶zÃ¼mler getirebilir. Ã–rneÄŸin bir Ã¼rÃ¼n kodu oluÅŸturmak isteyebiliriz. Bu Ã¼rÃ¼n kodunda 0 sayÄ±sal deÄŸerini Ã¼rÃ¼nÃ¼n id deÄŸiÅŸkenine gÃ¶re ve uzunluÄŸuna gÃ¶re ekleyebiliriz.

</aside>

*Ã–rneÄŸin:*

```sql
SELECT 'URUN'+REPLICATE('0',5-LEN('139'))+'139' //URUN00139

SELECT 'URUN'+REPLICATE('0',5-LEN('10'))+'10' // URUN00010

SELECT 'URUN'+REPLICATE('0',5-LEN('1457'))+'1457' //URUN01457
```

Bu ÅŸekilde Ã¼rÃ¼nÃ¼n id numarasÄ±nÄ±n uzunluÄŸuna gÃ¶re 0 ekleyip eklememe durumu gibi bir durumda Ã§Ã¶zÃ¼mlemeler gerÃ§ekleÅŸtirilebilmektedir.

***REPLACE FONKSÄ°YONU:*** ÃœÃ§ adet parametre alan bu fonksiyonda girilen ilk parametrede Ã¼zerinde deÄŸiÅŸiklik yapÄ±lacak deÄŸer girilir. Ä°kinci parametrede bu kelimenin veya ilk kelime iÃ§erisinde geÃ§en ifadenin eski sÃ¼rÃ¼mÃ¼nÃ¼ ve son olarak Ã¼Ã§Ã¼ncÃ¼ ifade de ise bu ifadenin yeni sÃ¼rÃ¼mÃ¼nÃ¼n girilmesi beklenilir.

*Ã–rneÄŸin:*

```sql
SELECT REPLACE('OpenCV gÃ¶rÃ¼ntÃ¼ iÅŸlemede kullanÄ±lan bir python dili kÃ¼tÃ¼phanesidir.',
'OpenCV','Tensorflow')
// Tensorflow gÃ¶rÃ¼ntÃ¼ iÅŸlemede kullanÄ±lan bir python dili kÃ¼tÃ¼phanesidir.
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi iÃ§erisinde geÃ§en â€˜OpenCVâ€™ ifadesini, â€˜Tensorflowâ€™ olarak deÄŸiÅŸtirdi.

<aside>
ğŸ’¡ Replace Fonksiyonu, kirli verileri temizlemek iÃ§in oldukÃ§a sÄ±klÄ±kla kullanÄ±lan bir fonksiyondur. Ã–rneÄŸin bir form verisi iÃ§erisinde â€˜istanbulâ€™, â€˜Ä°stanbulâ€™ veya â€˜ist.â€™ olarak kullanÄ±labilir. Ä°ÅŸte bu veri karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± tek dÃ¼ze indirebilmek iÃ§in replace komutunu kullanarak â€˜Ä°stanbulâ€™ olarak verileri dÃ¼zenleyebiliriz.

</aside>

***SUBSTRING FONKSÄ°YONU:*** Bir string ifadesinde belirli bir baÅŸlangÄ±Ã§ noktasÄ±ndan belirli bir bitiÅŸ noktasÄ±na kadar deÄŸeri almamÄ±za olanak saÄŸlayan bir fonksiyondur.

```sql
SELECT SUBSTRING('ChatGPT gpt tabanlÄ± bir yapay zeka dil modelidir.',1,7) 
// ChatGPT

SELECT SUBSTRING('ChatGPT gpt tabanlÄ± bir yapay zeka dil modelidir.',25,10) 
//yapay zeka 
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi girilen karakter verisini bÃ¶lmek istenilen yerden, kaÃ§ tane bÃ¶lmek istenildiÄŸi parametreleri girilerek karakter veri setlerinde iÃ§erisindeki deÄŸerleri dilediÄŸimiz gibi manipÃ¼le etmemize olanak saÄŸlayan bir yapÄ± olarak karÅŸÄ±mÄ±za Ã§Ä±kmaktadÄ±r.

<aside>
ğŸ’¡ Substring fonksiyonu gÃ¼ndelik hayatta oldukÃ§a fazla kullanÄ±lan bir fonksiyondur. Ã–rneÄŸin bÃ¼yÃ¼k veri iÃ§erisinde yer alan bir html sayfasÄ±nÄ± belirli yerlerinden scraping iÅŸlemi yapmak iÃ§in kullanÄ±labilmektedir.

</aside>

***CHARINDEX FONKSÄ°YONU:*** Belirli bir string ifadesinde aranan ifadenin kaÃ§Ä±ncÄ± indeksten baÅŸladÄ±ÄŸÄ±nÄ± bildiren bir fonksiyondur. Temel olarak iki tane parametre alan bu fonksiyonda Ã¶ncelikle aranan ifade ve sonrasÄ±nda nerede aranacaÄŸÄ±nÄ± bildiren ikinci ifade yer almaktadÄ±r.

```sql
SELECT CHARINDEX('2022', 'MICROSOFT SQL SERVER 2022') //22

SELECT CHARINDEX('SQL', 'MICROSOFT SQL SERVER 2022') // 11
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi aranan â€˜2022â€™ ifadesi belirtilen string dizisinde 22â€™nci indexten baÅŸladÄ±ÄŸÄ±nÄ± belirtmektedir.

<aside>
ğŸ’¡ Temel olarak string ifadelerini belirli parametrelere gÃ¶re bÃ¶lmemize olanak saÄŸlayan bu fonksiyon Ã¶rneÄŸin elimizde olan bir string fonksiyonunda deÄŸiÅŸtirmek istediÄŸimiz ifadenin kaÃ§Ä±ncÄ± indexte olduÄŸunu Ã¶ÄŸrenip ona gÃ¶re manipÃ¼lasyon iÅŸlemlerini gerÃ§ekleÅŸtirebilmemize olanak saÄŸlayan bir yapÄ± olarak karÅŸÄ±mÄ±za Ã§Ä±kmaktadÄ±r.

</aside>

***STRING_SPLIT FONKSÄ°YONU:*** DiÄŸer fonksiyonlardan ayrÄ±lan bu fonksiyonda bize sonuÃ§ odaklÄ± dÃ¶nÃ¼ÅŸ deÄŸil tablo olarak dÃ¶nÃ¼ÅŸ saÄŸlamaktadÄ±r. Bundan Ã¶tÃ¼rÃ¼ de kullanÄ±mda ise FROM ifadesi kullanÄ±lmaktadÄ±r. Temel olarak iki ifade alÄ±r. Bunlardan biri split edilmesi gereken ifadeyi alÄ±rken diÄŸeri ise neye gÃ¶re split edilmesi gerektiÄŸinden bahseder.

*Ã–rneÄŸin:*

```sql
SELECT * FROM STRING_SPLIT('ChatGPT, GPT tabanlÄ± bir yapay zeka dil modelidir.',' ')

/*
ChatGPT,
GPT
tabanlÄ±
bir
yapay
zeka
dil
modelidir.

*/
```

Bu ÅŸekilde girilen string parametresini boÅŸluklardan ayÄ±rarak bir tablo halinde gÃ¶sterime olanak saÄŸlayan bir yapÄ± olarak karÅŸÄ±mÄ±za Ã§Ä±kmaktadÄ±r. Bu fonksiyon Ã¶ncesinde de dediÄŸimiz gibi diÄŸer fonksiyonlardan ayÄ±ran Ã¶zelliÄŸi bir tablo olarak gÃ¶sterim saÄŸlamasÄ±dÄ±r. Ã–rnek olarak aÅŸaÄŸÄ±daki kodu Ã§alÄ±ÅŸtÄ±ralÄ±m ve sonucuna bir bakalÄ±m.

*Ã–rneÄŸin:*

```sql
SELECT STRING_SPLIT('ChatGPT, GPT tabanlÄ± bir yapay zeka dil modelidir.',' ')

/*

Msg 195, Level 15, State 10, Line 15
'STRING_SPLIT' is not a recognized built-in function name.

Completion time: 2024-05-30T17:46:01.6367640+03:00

*/
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ Ã¼zere hata almamÄ±za sebep olabilmektedir. Ã‡Ã¼nkÃ¼ scaler value deÄŸerinde deÄŸer dÃ¶ndÃ¼ren bir string_split fonksiyonu yoktur. string_split fonksiyonu bize table-value deÄŸeri dÃ¶ndÃ¼rmektedir.

### STRING FONKSÄ°YONLARI ALIÅTIRMALAR

***SORU-1:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%201.png)

***AdÄ±mlar sÄ±rasÄ±yla:***

- Ã–ncelikle veri tabanÄ±ndaki tabloyu bir gÃ¶rÃ¼ntÃ¼lememiz gerekir.
- Ä°kinci olarak soruda belirtilen alanlar iÃ§in tasarÄ±mcÄ± ekranÄ±ndan yeni bir sÃ¼tun veri tablosuna ekledik.
- ÃœÃ§Ã¼ncÃ¼ olarak soruda belirtilen alanlarÄ± birleÅŸtiren komutu yazdÄ±k.
- En son olarak veri tabanÄ± iÃ§erisinde Ã¶nceden de oluÅŸturduÄŸumuz NAMESURNAME sÃ¼tunundaki verileri gÃ¼ncelledik.

KurduÄŸumuz yapÄ±nÄ±n SQL sorgusu aÅŸaÄŸÄ±daki gibidir.

```sql
SELECT * FROM LAB01 -- tabloyu listeledik

SELECT *, NAME_+' '+SURNAME FROM LAB01 -- Eklemek istediÄŸimiz yapÄ±yÄ± kontrol ettik

UPDATE LAB01 SET NAMESURNAME = NAME_+' '+SURNAME -- VeritabanÄ±nda gÃ¼ncelleme yaptÄ±k.
```

Kod sonrasÄ± oluÅŸan son durum ÅŸu ÅŸekildedir. 

[LAB01](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/LAB01%209a66c86f97eb4e9f91243703baee3ba4.csv)

***SORU-2:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%202.png)

***AdÄ±mlar sÄ±rasÄ±yla:***

- Ã–ncelikle veri tabanÄ±ndaki mevcut tabloyu gÃ¶rÃ¼ntÃ¼ledik.
- SonrasÄ±nda istenilen formata gÃ¶re select sorgusu yazÄ±ldÄ±.
- ÃœrÃ¼n kodu ve Ã¼rÃ¼n adÄ± alt alta satÄ±rlarda olmasÄ±nÄ± istediÄŸimizden Ã¶tÃ¼rÃ¼ de char(13) string fonksiyonunu kullandÄ±k. Ã‡Ã¼nkÃ¼ bu fonksiyon bizlere enter karakterinin ascii tablosundaki deÄŸerini vermektedir.
- Tablo olarak enter gÃ¶zÃ¼kmeyeceÄŸi iÃ§in Ã§Ä±ktÄ± kÄ±smÄ±nÄ±n gÃ¶rÃ¼ntÃ¼lenme ÅŸeklini text olarak ayarladÄ±m ki daha iyi anlayabilelim

Bu adÄ±mlar durumunda sorgu ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB02

SELECT 'ÃœrÃ¼n Kodu:' +ITEMCODE +CHAR(13)+ 'ÃœrÃ¼n AdÄ±: '+ITEMNAME AS 'AÃ‡IKLAMA' FROM LAB02 

-- CHAR(32) --> BOÅLUK KARAKTERÄ°
-- CHAR(13) --> ENTER KARAKTERÄ°
```

Kod sonrasÄ± oluÅŸan tablo ise ÅŸu ÅŸekildedir.

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%203.png)

***SORU-3:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%204.png)

AdÄ±mlar sÄ±rasÄ±yla:

- Ã–ncelikle gÃ¼ncellemek istediÄŸimiz tabloyu `SELECT` komutuyla gÃ¶rÃ¼ntÃ¼ledik.
- SonrasÄ±nda problemde bize bildirilen bÃ¼yÃ¼k harfe dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemi iÃ§in `UPPER()` fonksiyonunu kullanarak belirlenen alanlardaki fonksiyonu denedik.
- En sonunda gÃ¼ncellemek istediÄŸimiz tabloyu ve sÃ¼tunlarÄ± belirterek ilgili `UPDATE` fonksiyonunu yazarak iÅŸlemi tamamladÄ±k.

Bu adÄ±mlar neticesinde oluÅŸturulan SQL sorgusu ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB03

/*

UPPER() --> BÃ¼yÃ¼k harfe dÃ¶nÃ¼ÅŸtÃ¼ren String fonksiyonu
LOWER() --> KÃ¼Ã§Ã¼k harfe dÃ¶nÃ¼ÅŸtÃ¼ren String fonksiyonu

*/

SELECT *, UPPER(TOWN), UPPER(CITY) FROM LAB03

UPDATE LAB03 SET CITY = UPPER(CITY), TOWN = UPPER(TOWN);
```

Sorgu sonucu oluÅŸan yeni tablomuz ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%205.png)

***SORU-4:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%206.png)

Bu iÅŸlemi gerÃ§ekleÅŸtirebilmek iÃ§in birden fazla string fonksiyonunu iÃ§ iÃ§e yazmamÄ±z gerekebilir. AdÄ±m adÄ±m incelersek:

- Ã–ncelikle tabloyu listelemek iÃ§in `SELECT()` sorgusunu Ã§alÄ±ÅŸtÄ±rmamÄ±z gerekir. Bu ÅŸekilde tabloyu komple gÃ¶rÃ¼ntÃ¼leyebiliriz.
- SonrasÄ±nda soruda belirtilen â€œilk harfi bÃ¼yÃ¼kâ€ ifadesi iÃ§in gerekli yerin ilk harfini seÃ§ebilmek iÃ§in `LEFT()` fonksiyonunu kullanÄ±rÄ±z. EÄŸer parametre olarak 1 sayÄ±sÄ± girilirse ilk harfi seÃ§ecektir.
- Soruda ilk harfin bÃ¼yÃ¼k kalmasÄ± talep edilmiÅŸ bÃ¼yÃ¼k harf olarak kalmasÄ± iÃ§in `UPPER()` fonksiyonu kullanÄ±lÄ±r. Bu ÅŸekilde gerekli alandaki ilk ifade kÄ±smÄ± bitmiÅŸ olur.
- DiÄŸer bir kÄ±sÄ±m ise kÃ¼Ã§Ã¼k harf olarak dÃ¶nÃ¼ÅŸmesi gereken kÄ±sÄ±mlar bunlar iÃ§in de yine benzer bir yÃ¶ntem izlemek gerekir.
- Bunun iÃ§in Ã¶ncelikle baÅŸ harf hariÃ§ diÄŸerinin seÃ§ilmesi istenmiÅŸ. Bunun iÃ§in tabii ki `RIGHT()` fonksiyonu kullanacaÄŸÄ±z. `RIGHT()` fonksiyonu iÃ§in ise ilk kelime hariÃ§ olduÄŸu iÃ§in ve tablo iÃ§erisinde kelimelerin tam uzunluÄŸunu bilemediÄŸimiz iÃ§in `LEN()` fonksiyonuyla bunu belirleyebiliriz. En sonunda `LEN()` fonksiyonundan gelen ifadeden -1 olarak dÃ¼ÅŸersek baÅŸ harfi hariÃ§ bÃ¼tÃ¼n kelimeler bize dÃ¶nÃ¼ÅŸ saÄŸlayacaktÄ±r.
- En sonunda ise bÃ¼tÃ¼n harflerin kÃ¼Ã§Ã¼k olmasÄ± nedeniyle burada ise lower fonksiyonuyla kurulan yapÄ± iÃ§eriye aktarÄ±lÄ±r.
- Son olarak `UPDATE()` sorgusu Ã§alÄ±ÅŸtÄ±rÄ±larak sonuÃ§ ekranÄ± dÃ¶ndÃ¼rÃ¼lÃ¼r.

Ä°lgili adÄ±mlarÄ±n sorgularÄ± ÅŸu ÅŸekilde olmaktadÄ±r.

```sql
SELECT * FROM LAB04

/*
	SOLDAN KARAKTER SEÃ‡Ä°MÄ°: LEFT()
	SAÄDAN KARAKTER SEÃ‡Ä°MÄ°: RIGHT()
*/

/*
	KÃœÃ‡ÃœK HARF DÃ–NÃœÅTÃœRÃœCÃœ: LOWER()
	BÃœYÃœK HARF DÃ–NÃœÅTÃœRÃœCÃœ: UPPER()
*/

/*
	UZUNLUK BELÄ°RTECÄ°: LEN()
*/

SELECT LEFT('ANKARA',1)+LOWER(RIGHT('ANKARA', LEN('ANKARA')-1)) -- Ankara

-- Tabloyu gÃ¼ncelleÅŸtirelim

UPDATE LAB04 SET CITY = UPPER(LEFT(CITY,1))+LOWER(RIGHT(CITY, LEN(CITY)-1)), TOWN = UPPER(LEFT(TOWN,1))+LOWER(RIGHT(TOWN, LEN(TOWN)-1))
```

Sorgu neticesinde Ã§Ä±kacak gÃ¶rÃ¼ntÃ¼ ise ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%207.png)

***SORU-5:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%208.png)

Yine aynÄ± ÅŸekilde bu sorunu Ã§Ã¶zebilmek iÃ§in birden fazla string fonksiyonunu iÃ§ iÃ§e yazmamÄ±z gerekecek. Bu adÄ±mlarÄ± sÄ±rasÄ±yla incelersek:

- Ä°lk olarak tabloyu gÃ¶rÃ¼ntÃ¼leyebilmek iÃ§in `SELECT` komutunu Ã§alÄ±ÅŸtÄ±rarak tablonun tamamÄ±nÄ± listeledik.
- SonrasÄ±nda soruda istenilen mail servis saÄŸlayÄ±cÄ±larÄ±nÄ±n seÃ§imini belirtmemiz gerekecek. Bunun iÃ§in ise burada belirleyici etken â€˜@â€™ iÅŸaretidir. O zaman burada â€˜@â€™ iÅŸaretinin yerini tespit edebilirsek buna uygun olarak servis saÄŸlayÄ±cÄ±nÄ±n domain adresini ayÄ±rabiliriz.
- â€˜@â€™ iÅŸaretinin yerini tespit edebilmek iÃ§in `CHARINDEX()` fonksiyonunu kullanabiliriz. `CHARINDEX()` fonksiyonu bize belirli bir konum sayÄ±sÄ± yani indeks dÃ¶ndÃ¼rÃ¼r bu dÃ¶nen indeks sayÄ±sÄ±nÄ± ise `RIGHT()` fonksiyonu ile bÃ¶lebiliriz.
- O zaman metnin tam uzunluÄŸundan `CHARINDEX()` Ã§Ä±karÄ±rsak ve sonucunu `LEN()`fonksiyonu ile belirtirsek bize tam bir sonuÃ§ saÄŸlayabilir.
- YapÄ±yÄ± kurduktan sonra bizden istenilen toplam sayÄ± kullanabilmek iÃ§in ise `GROUP BY` ile `COUNT()` kullanarak yapÄ±yÄ± tamamen istediÄŸimiz ÅŸekilde kurabiliriz.

Bu adÄ±mlar neticesinde sorgumuz ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB05
/*
	email'i seÃ§memiz iÃ§in gereken ayraÃ§ '@' iÅŸareti
	Bunun iÃ§in kullanÄ±labilecek fonksiyon CharIndex
*/

SELECT CHARINDEX('@','mel_ozipek@fakeyahoo.com') -- 11

/*
	'@' sonrasÄ± seÃ§imi iÃ§in len ve rightÄ± iÃ§ iÃ§e kullanabiliriz.
*/

SELECT LEN('mel_ozipek@fakeyahoo.com') -- 24-11= 13

SELECT RIGHT('mel_ozipek@fakeyahoo.com',13)

-- Sorguya bir dÃ¼zen getirelim

SELECT *, RIGHT(EMAIL, LEN(EMAIL) - CHARINDEX('@', EMAIL)) FROM LAB05

-- Hangi mail adresinden ne kadar var sorusunu da count ve group by ile yapabiliriz.

SELECT RIGHT(EMAIL, LEN(EMAIL) - CHARINDEX('@', EMAIL)), COUNT(*) FROM LAB05 
GROUP BY RIGHT(EMAIL, LEN(EMAIL) - CHARINDEX('@', EMAIL));
```

Bu sorgu neticesinde Ã§Ä±ktÄ±mÄ±z ise ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%209.png)

***SORU-6:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2010.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT TELNR FROM LAB06

/*
	LEFT() - SOLDAN Ä°LK SAYI SEÃ‡Ä°MÄ° yani 0
	SUBSTRING() --> kaÃ§Ä±ncÄ± indeksten baÅŸlayÄ±p kaÃ§ tane karakter seÃ§imi olsun
*/

SELECT '+90 ('+ SUBSTRING('03563355976',2,3)+')'+' '+
SUBSTRING('03563355976',5,3)+' '+
SUBSTRING('03563355976',8,2)+' '+
SUBSTRING('03563355976',10,2)

SELECT *,'+90 ('+ SUBSTRING(TELNR,2,3)+')'+' '+
SUBSTRING(TELNR,5,3)+' '+
SUBSTRING(TELNR,8,2)+' '+
SUBSTRING(TELNR,10,2) AS 'FormatlanmÄ±ÅŸ Numaralar' FROM LAB06
```

Sorgunun Ã§Ä±ktÄ±sÄ± ise ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2011.png)

***SORU-7:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2012.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB07

/*
	REPLICATE() --> tekrar yazÄ±lmasÄ± istenilen ve ne kadar yazÄ±lmasÄ± istenen parametreleri alÄ±r
	LEN() --> Ã¼rÃ¼n kodunun uzunluÄŸunu belirtir.
*/

SELECT *,CATEGORY1CODE + REPLICATE(0, 6-LEN(ITEMCODE))+ITEMCODE AS 'AkÄ±llÄ± Kod' FROM LAB07

UPDATE LAB07 SET ITEMCODE = CATEGORY1CODE + REPLICATE(0, 6-LEN(ITEMCODE))+ITEMCODE;
```

Sorgunun Ã§Ä±ktÄ±sÄ± ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2013.png)

***SORU-8:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2014.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB09
/*
	string_split(x,y) --> x=veri, y=bÃ¶lÃ¼nme parametresi
	count() --> toplam veri sayÄ±sÄ±
*/
SELECT COUNT(*) FROM string_split('Ä°stanbul tarihi mekanlarÄ±yla Ã¼nlÃ¼ bir bÃ¼yÃ¼kÅŸehirdir.', ' ')

SELECT *,(SELECT COUNT(*) FROM string_split(FULLTEXT, ' ')) as 'ToplamKelimeSayisi' FROM LAB09
```

Sorgunun Ã§Ä±ktÄ±sÄ± ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2015.png)

***SORU-9:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2016.png)

Sorunun Ã§Ã¶zÃ¼m sorgusu ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB10

SELECT REPLACE(INFO, '##',CHAR(13)) FROM LAB10
```

Sorgunun Ã§Ä±ktÄ±sÄ± ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2017.png)

### SQL SERVER DATETIME FUNCTION

***ANLIK TARÄ°HÄ° ve SAATÄ° GETÄ°REN FONKSÄ°YONLAR:*** SQL serverÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± ana makinenin tarih ve saatlerini getiren fonksiyonlardÄ±r. KÄ±saca maddeler halinde deÄŸinelim:

- `GETDATE()` fonksiyonu sistemin anlÄ±k zaman dilimini yÄ±l-ay-gÃ¼n saat-dakika-saniye-milisaniye (max 3 digit) ÅŸeklinde gÃ¶sterim saÄŸlamaktadÄ±r. En Ã§ok kullanÄ±lan fonksiyon ise budur.
- `SYSDATETIME()` fonksiyonu ise daha da detaylÄ± bir milisaniye deÄŸeri dÃ¶ndÃ¼rÃ¼r.
- `SYSDATETIMEOFFSET()` fonksiyonu ise +03.00 timezon deÄŸerini de gÃ¶sterir.

DiÄŸer fonksiyonlarÄ±n kullanÄ±mÄ± ise ÅŸu ÅŸekildedir:

```sql
SELECT 
GETDATE() GETDATE,
SYSDATETIME() SYSDATETIME,
SYSDATETIMEOFFSET() SYSDATETIMEOFFSET,
SYSUTCDATETIME() SYSUTCDATETIME,
CURRENT_TIMESTAMP "CURRENT_TIMESTAMP",
GETUTCDATE() GETUTCDATE
```

YukarÄ±da yazÄ±lmÄ±ÅŸ olan datetime fonksiyonlarÄ±n Ã§Ä±ktÄ±sÄ± ise ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2018.png)

***DATEPART FONKSÄ°YONU:*** Bir tarih ve saat yapÄ±sÄ± iÃ§erisinden belirli bir kÄ±smÄ± almak iÃ§in kullanÄ±lan fonksiyondur. Belirli bir parametreler girerek Ã¶rneÄŸin: ay, yÄ±l gÃ¼n gibi deÄŸerleri alabiliriz.

*Ã–rneÄŸin:*

```sql
/*
	 DATEPART FUNCTIONS
	 YEAR -> yÄ±l bilgisini alÄ±r.
	 MONTH -> ay bilgisini alÄ±r.
	 DAY -> gÃ¼n bilgisini alÄ±r.
	 HOUR -> saat bilgisini alÄ±r.
	 MINUTE -> dakika bilgisini alÄ±r.
	 SECOND -> saniye bilgisini alÄ±r.
*/

SELECT DATEPART(YEAR, '2024-06-02 02:23:58.723') AS 'YIL',
DATEPART(MONTH, '2024-06-02 02:23:58.723') AS 'AY',
DATEPART(DAY, '2024-06-02 02:23:58.723') AS 'GUN',
DATEPART(HOUR, '2024-06-02 02:23:58.723') AS 'SAAT',
DATEPART(MINUTE, '2024-06-02 02:23:58.723') AS 'MINUTE',
DATEPART(SECOND, '2024-06-02 02:23:58.723') AS 'SECOND'
```

Sorgu sonucunda oluÅŸan tablo ise ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2019.png)

***DATENAME FONKSÄ°YONU:*** DATEPART fonksiyonuna tÄ±patÄ±p benzerdir. Sadece tek farklÄ± yanÄ± ay gibi ifadeleri sayÄ±sal olarak deÄŸil string tÃ¼rÃ¼ olarak yazdÄ±rÄ±r.

*Ã–rneÄŸin:*

```sql
/*
	 DATENAME FUNCTIONS
	 YEAR -> yÄ±l bilgisini alÄ±r.
	 MONTH -> ay bilgisini alÄ±r.
	 DAY -> gÃ¼n bilgisini alÄ±r.
	 HOUR -> saat bilgisini alÄ±r.
	 MINUTE -> dakika bilgisini alÄ±r.
	 SECOND -> saniye bilgisini alÄ±r.
*/

SELECT DATENAME(YEAR, '2024-06-02 02:23:58.723') AS 'YIL',
DATENAME(MONTH, '2024-06-02 02:23:58.723') AS 'AY',
DATENAME(DAY, '2024-06-02 02:23:58.723') AS 'GUN',
DATENAME(HOUR, '2024-06-02 02:23:58.723') AS 'SAAT',
DATENAME(MINUTE, '2024-06-02 02:23:58.723') AS 'DAKIKA',
DATENAME(SECOND, '2024-06-02 02:23:58.723') AS 'SANIYE'
```

Sorgu sonucunda oluÅŸan tablo ÅŸu ÅŸekildedir:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2020.png)

***DATE-TimeFromParts FONKSÄ°YONLARI:***  Ä°Ã§ine almÄ±ÅŸ olduÄŸu gÃ¼n-ay-yÄ±l deÄŸerini date tÃ¼rÃ¼nde dÃ¶ndÃ¼rÃ¼r. TimeFromParts ise iÃ§erisinde gÃ¼n-ay-yÄ±l-saat-dakika tÃ¼rÃ¼nde veri alÄ±r ve date tÃ¼rÃ¼nde dÃ¶ndÃ¼rÃ¼r.

*Ã–rneÄŸin:*

```sql
SELECT DATEFROMPARTS(2020,2,18); -- date tÃ¼rÃ¼nde dÃ¶ndÃ¼rdÃ¼ (2020-02-18)
SELECT DATEFROMPARTS(2020,8,19); -- date tÃ¼rÃ¼nde dÃ¶ndÃ¼rdÃ¼ (2020-08-19)

-- HatalÄ± tarih giriÅŸleri denemesi
SELECT DATEFROMPARTS(2020,2,29); -- 2020 artÄ±k yÄ±l olduÄŸu iÃ§in iÃ§erisinde 29 ÅŸubat vardÄ±r o yÃ¼zden sorgu doÄŸrudur. ancak

SELECT DATEFROMPARTS(2019,2,29);
/*
	Msg 289, Level 16, State 1, Line 6
	Cannot construct data type date, some of the arguments have values which are not valid. (hata alÄ±ndÄ±.)
*/

-- farklÄ± bir ÅŸekilde olmayan bir ay girdisi verelim:
SELECT DATEFROMPARTS(2020,13,4); -- 13. ay diye bir ay yoktur.
/*
(hata tÃ¼rÃ¼)
	Msg 289, Level 16, State 1, Line 14
	Cannot construct data type date, some of the arguments have values which are not valid.
*/

-- DATEFROMPARTS (7 tane parametre alÄ±r eÄŸer almazsa hata alÄ±nÄ±r.)

SELECT DATETIMEFROMPARTS(2022,12,20,16);
/*
(hata tÃ¼rÃ¼)
	Msg 174, Level 15, State 1, Line 23
	The datetimefromparts function requires 7 argument(s).
*/

SELECT DATETIMEFROMPARTS(2022,12,20,18,19,20,8) -- 2022-12-20 18:19:20.007

-- TIMEFROMPARTS -> 5 tane parametre alÄ±r bunlar sÄ±rasÄ±yla

/*
	-> saat
	-> dakika
	-> saniye
	-> milisaniye
	-> milisaniye hassasiyeti (Ã¶rneÄŸin 5 girilirse 5 rakamdan oluÅŸan bir yapÄ± olarak karÅŸÄ±mÄ±za Ã§Ä±kar (00046) gibi.
*/

SELECT TIMEFROMPARTS(16,45,56,415,5); -- 16:45:56.00415

-- Ã¶rneÄŸin 5 digitlik bir milisaniye girelim ve hassasiyeti 3 ayarlayalÄ±m:

SELECT TIMEFROMPARTS(16,45,56,1234,3);
/*
(hata kodu)
	Msg 289, Level 16, State 2, Line 46
	Cannot construct data type time, some of the arguments have values which are not valid.
*/
-- yani burada anlamamÄ±z gereken ÅŸey hassasiyet girilen milisaniye digit deÄŸerinden fazla olamaz eÄŸer olursa hata alÄ±nÄ±r.
```

Bu ÅŸekilde Ã¶zetleyebilirizâ€¦.

***DAY-MONTH-YEAR FONKSÄ°YONLARI:*** Genel olarak elimizde bulunan bir tarih verisini gÃ¼n-ay-yÄ±l veya farklÄ± ÅŸekillerde farklÄ± veriler elde etmemize olanak saÄŸlayan temel bir tsql fonksiyonudur. DateFromParts ile ayrÄ±lan Ã¶zelliÄŸi y-a-g-s-d-ms ÅŸeklinde veri istenirken day-month-year fonksiyonlarÄ±nda buna ihtiyaÃ§ yoktur. Sadece y-a-g ÅŸeklinde tarih verisi yeterlidir.

*Ã–rneÄŸin:*

```sql
-- Sistemim iÃ§in anlÄ±k tarih saat verisini gÃ¶sterelim:
SELECT GETDATE(); -- 2024-06-24 14:24:09.623

SELECT YEAR(GETDATE()) as 'YEAR'; -- sistemin anlÄ±k olarak yÄ±l bilgisi (2024)
SELECT MONTH(GETDATE()) as 'MONTH'; -- sistemin anlÄ±k olarak ay bilgisini (06)
SELECT DAY(GETDATE()) as 'DAY'; -- sistemin anlÄ±k olarak gÃ¼n bilgisini (24) alabiliriz.

-- ayrÄ±ca sadece getdate fonksiyonuyla iÃ§ iÃ§e kullanÄ±lamaz. FarklÄ± bir date veri iÃ§erisinde de Ã§alÄ±ÅŸabilir.

SELECT YEAR('2022-08-14') as 'YEAR'; -- date verisindeki yÄ±l deÄŸerini (2022) milisaniye deÄŸeri olmadan da alabilirim datefromparts ile ayrÄ±lan Ã¶zelliÄŸi budur.
SELECT MONTH('2022-08-14 12:24:09.613') as 'MONTH'; -- date verisindeki ay deÄŸerini (08)
SELECT DAY('2022-08-14 12:24:09.613') as 'DAY'; -- date verisindeki gÃ¼n deÄŸerini (14)
```

Bu ÅŸekilde Ã¶zetleyebilirizâ€¦

***Datediff Fonksiyonu:*** Bu fonksiyonda ise iki tarih arasÄ±ndaki farkÄ± almak iÃ§in kullanÄ±lÄ±r. Ä°Ã§erisine iki adet parametre alÄ±r. AyrÄ±ca iki tarih arasÄ±ndaki farkÄ± nasÄ±l olarak gÃ¶stermemiz gerektiÄŸine dair bir parametre daha alÄ±r.

*Ã–rneÄŸin:*

```sql
/*
	ÃœÃ§ adet parametre alÄ±r:
	-> iki tarih arasÄ±ndaki farkÄ± hangi tÃ¼rde istenilmesi (day,month,week,hour vs.)
	-> geÃ§miÅŸ olan tarih
	-> yeni olan tarih

*/

SELECT DATEDIFF(YEAR, '2002-09-24', '2034-10-14'); -- iki tarih arasÄ±ndaki yÄ±l farkÄ±nÄ± verir. (32 yÄ±l)
SELECT DATEDIFF(MONTH, '2002-09-24', '2034-10-14'); -- iki tarih arasÄ±ndaki ay farkÄ±nÄ± verir. (385 ay)
SELECT DATEDIFF(DAY, '2002-09-24', '2034-10-14'); -- iki tarih arasÄ±ndaki gÃ¼n farkÄ±nÄ± verir. (11708 gÃ¼n)

-- saat ve dakika
SELECT DATEDIFF(HOUR, '2002-09-24', '2034-10-14') -- iki tarih arasÄ±ndaki saat farkÄ± (280992 saat)
SELECT DATEDIFF(MINUTE, '2002-09-24', '2034-10-14') -- iki tarih arasÄ±ndaki dakika farkÄ± (16859520 dakika)
SELECT DATEDIFF(SECOND, '2002-09-24', '2034-10-14'); -- saniye farkÄ± (1011571200 saniye) olarak gÃ¶sterilir.

/*
	bir Ã¶rnek dÃ¼ÅŸÃ¼nelim: Bir mÃ¼ÅŸterimiz bizden en son alÄ±ÅŸveriÅŸ yaptÄ±ÄŸÄ± tarih '2008-10-09' olsun. 
	Bu mÃ¼ÅŸterimizin bizden ne zamandÄ±r alÄ±ÅŸveriÅŸ yapmadÄ±ÄŸÄ±na dair bir analiz oluÅŸturalÄ±m:
	(sistemin anlÄ±k tarihini kullanmamÄ±z iÃ§in gereken fonksiyon GETDATE() fonksiyonudur.)
*/
-- Ã§Ã¶zÃ¼m:
SELECT DATEDIFF(YEAR,'2008-10-09', GETDATE()); -- yÄ±l farkÄ± (16) yÄ±ldÄ±r bizden alÄ±ÅŸveriÅŸ yapmÄ±yor.
SELECT DATEDIFF(MONTH, '2008-10-09', GETDATE()); -- ay farkÄ± (118) aydÄ±r alÄ±ÅŸveriÅŸ yapmÄ±yor.
SELECT DATEDIFF(DAY, '2008-10-09', GETDATE()); -- gÃ¼n farkÄ± (5737) gÃ¼ndÃ¼r bizden alÄ±ÅŸveriÅŸ yapmÄ±yor.
SELECT DATEDIFF(WEEK, '2008-10-09', GETDATE()); -- hafta farkÄ± (820) haftadÄ±r bizden alÄ±ÅŸveriÅŸ yapmÄ±yor.

-- Bu ÅŸekilde Ã§Ã¶zÃ¼mleri hem saat hem dakika hem saniye ÅŸeklinde de yapabiliriz.
```

Bu ÅŸekilde Ã¶zetleyebilirizâ€¦.

***Dateadd Fonksiyonu:*** Bir tarihe baÅŸka bir parametrede deÄŸer girilmesine olanak saÄŸlar. Bu fonksiyon temelinde Ã¼Ã§ parametre alÄ±r.

*Ã–rneÄŸin:*

```sql
/*
	Temel olarak bir tarihe baÅŸka bir deÄŸer girilerek o tarihi dÃ¼zenlememize olanak saÄŸlar.
	Bu fonksiyon Ã¼Ã§ adet parametre alÄ±r
	-> tarih verisi iÃ§erisinden hangisine ekleme yapÄ±lacak (year,month,day vs.)
	-> ne kadar sÃ¼re girilecek (10,20,30 vs.)
	-> ve deÄŸiÅŸtirilmek istenen tarih verisi (2023-08-15 vs.)
*/

-- KullanÄ±m ÅŸu ÅŸekildedir:
SELECT DATEADD(YEAR, 10, '2024-06-24'); -- tarihin yÄ±lÄ±na 10 sene ekle (2034-06-24 00:00:00.000)
SELECT DATEADD(MONTH, 1, '2024-06-24'); -- tarihin ayÄ±na 1 ay ekle (2024-07-24 00:00:00.000)
SELECT DATEADD(DAY, 5, '2024-06-24'); -- tarihin gÃ¼nÃ¼ne 5 gÃ¼n ekle (2024-06-29 00:00:00.000)
SELECT DATEADD(WEEK, 6, '2024-06-24'); -- tarihe 6 hafta ekler. (2024-08-05 00:00:00.000)

-- saat veya dakika ms ekleme ise ÅŸu ÅŸekildedir:
SELECT DATEADD(HOUR, 5, GETDATE()); -- sistemin anlÄ±k saatine 5 saat ekle (2024-06-24 22:46:42.160)
SELECT DATEADD(MINUTE, 20, GETDATE()); -- sistemin anlÄ±k dakikasÄ±na 20 dakika ekler. (2024-06-24 18:07:58.113)
SELECT DATEADD(SECOND, 45, GETDATE()); -- sistemin anlÄ±k saniyesine 45 saniye ekler. (2024-06-24 17:52:45.363)
SELECT DATEADD(MILLISECOND, 300, GETDATE()); -- sistemin anlÄ±k milisaniyesine 300 ms ekler. (2024-06-24 17:49:04.133)

-- dateadd fonksiyonunu iÃ§ iÃ§e kullanarak bir tarihi istediÄŸimiz gibi dÃ¼zenleyebiliriz.
SELECT DATEADD(MINUTE, 50, DATEADD(HOUR, 5, '2024-06-24')); -- hem saate hem de dakika verisi girmiÅŸ oluruz. (2024-06-24 05:50:00.000)
SELECT DATEADD(SECOND, 80, DATEADD(MINUTE, 50, DATEADD(HOUR, 5, '2024-06-18'))); -- bir tarih verisine sÄ±rasÄ±yla saniye dakika ve saat verisi girildi (2024-06-18 05:51:20.000)

-- peki eklemek iÃ§in kullandÄ±ÄŸÄ±mÄ±z fonksiyon dateadd ise Ã§Ä±karmak istediÄŸimiz iÃ§in kullandÄ±ÄŸÄ±mÄ±z bir fonksiyon var mÄ± diye 
-- soracak olursak hayÄ±r yoktur. Bunun iÃ§in girilecek ifadede eksili (-10 vs.) gibi deÄŸerler girilmelidir.

SELECT DATEADD(DAY, -10, GETDATE()); -- sistemin anlÄ±k tarihinden 10 gÃ¼n geriye yani -10 gÃ¼n Ã§Ä±kart (2024-06-14 17:59:07.160)
SELECT DATEADD(YEAR, -100, '2023-10-29'); -- cumhuriyetin ilanÄ± tarihini verir. Yani 100 yÄ±l Ã¶ncesi (1923-10-29 00:00:00.000)
```

KÄ±saca bu ÅŸekilde Ã¶zetleyebilirizâ€¦

***IsDate Fonksiyonu:*** Ä°Ã§ine almÄ±ÅŸ olduÄŸu deÄŸerin tarih veri tÃ¼rÃ¼nde olup olmadÄ±ÄŸÄ±nÄ± dÃ¶ndÃ¼ren bir fonksiyondur.

```sql
/*
	iÃ§erisine sadece bir parametre alan bu fonksiyon eÄŸer ki girilen veri tarih formatÄ±na uygunsa 1, deÄŸilse 0 dÃ¶ndÃ¼rÃ¼r.
*/

SELECT ISDATE('2024-06-24') -- girilen veri tarih formatÄ±na uygundur. Bu yÃ¼zden dolayÄ± cevap (1)'dir.
SELECT ISDATE('2023-02-29') -- artÄ±k yÄ±lda olunmadÄ±ÄŸÄ± iÃ§in ve ÅŸubat 29 gÃ¼n olmadÄ±ÄŸÄ± iÃ§in cevap (0)'dÄ±r.
SELECT ISDATE('2024-02-29') -- artÄ±k yÄ±lda olunduÄŸu iÃ§in ve ÅŸubat 29 gÃ¼n olduÄŸu iÃ§in cevap (1)'dir.
SELECT ISDATE('2023-13-30') -- 13. ay diye bir ay tanÄ±mlÄ± olmadÄ±ÄŸÄ± iÃ§in cevap (0)'dÄ±r.
SELECT ISDATE('2023-1A-10') -- cevap 0'dÄ±r. Ã‡Ã¼nkÃ¼ 1A diye bir ay tanÄ±mlÄ± deÄŸildir.

-- farklÄ± tarih girme formatlarÄ±nÄ± denersek
SELECT ISDATE('19-09-2020') -- cevap (0)'dÄ±r Ã§Ã¼nkÃ¼ tsql'de tarih formatÄ± y-a-g ÅŸeklindedir.
SELECT ISDATE('20240216') -- tarih formatÄ± olarak okuyabildiÄŸi iÃ§in cevap (1)'dir. Yani doÄŸrudur.

```

Bu ÅŸekilde Ã¶zetleyebiliriz.

***ALIÅTIRMALAR*** 

SORU-1:

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2021.png)

SORUNUN Ã‡Ã–ZÃœMÃœ:

```sql
-- iki tarih arasÄ±ndaki farkÄ± almak iÃ§in datediff kullanabiliriz.

SELECT *, DATEDIFF(YEAR,  BIRTHDATE, GETDATE()) AS 'AGE' FROM LAB01 -- yaÅŸlarÄ± farkÄ±nÄ± buldurduk.

-- 40 ile 45 arasÄ±ndaki yaÅŸlarÄ± listeleyelim: (ARALIK BELÄ°RTMEK FONKSÄ°YONU BETWEEN()'DÄ°R.)

SELECT *, DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS 'AGE' FROM LAB01
WHERE
DATEDIFF(YEAR, BIRTHDATE, GETDATE()) BETWEEN 40 AND 45

-- son bir ÅŸartÄ±mÄ±z ise cinsiyeti erkek olanlardÄ± bunun iÃ§in de gender iÃ§erisinde E veya K deÄŸerleriyle bulabiliriz.

SELECT *, DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS 'AGE' FROM LAB01
WHERE
DATEDIFF(YEAR, BIRTHDATE, GETDATE()) BETWEEN 40 AND 45 -- yaÅŸÄ± 40 ile 45 arasÄ±nda olsun.
AND GENDER = 'E'; -- cinsiyeti erkek olsun

-- Bu ÅŸekilde fonksiyonumuz son halini almÄ±ÅŸ oldu. Soruda belirtilen Ã§Ã¶zÃ¼mÃ¼ yapan sorgu ÅŸudur:
SELECT *, DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS 'AGE' FROM LAB01
WHERE
DATEDIFF(YEAR, BIRTHDATE, GETDATE()) BETWEEN 40 AND 45
AND GENDER = 'E'; 
```

Bu ÅŸekilde soru Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***SORU-2:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2022.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ise ÅŸu ÅŸekildedir:

```sql
/*
	bir tarih verisi iÃ§erisinden ay verisini string olarak da alabiliriz sÄ±ralama sayÄ±sÄ± olarak da alabiliriz.
	sÄ±ralama sayÄ±sÄ± olarak almak istersek --> DATEPART()
	string olarak almak istersek --> DATENAME()
*/

SELECT *, DATEPART(MONTH, BIRTHDATE) AS 'MONTH' FROM LAB02 -- sayÄ±sal olarak ayÄ± aldÄ±k.

-- sorgumuzda istenilen mayÄ±s ayÄ±nda doÄŸanlarÄ±n listesini almak istersek ise where kullanabiliriz. (mayÄ±s 5. aydÄ±r)

SELECT *, DATEPART(MONTH, BIRTHDATE) AS 'MONTH' FROM LAB02
WHERE
DATEPART(MONTH, BIRTHDATE) = 5; -- 5. ayda yani mayÄ±s ayÄ±nda doÄŸanlarÄ± seÃ§

-- datename() kullanarak Ã§Ã¶zÃ¼mÃ¼ ise ÅŸu ÅŸekildedir:

SELECT *, DATENAME(MONTH, BIRTHDATE) AS 'MONTH' FROM LAB02 -- karakter verisi olarak seÃ§er

-- sorguda istenilen mayÄ±s ayÄ± filtrelemesi

SELECT *, DATENAME(MONTH, BIRTHDATE) AS 'MONTH' FROM LAB02
WHERE
DATENAME(MONTH, BIRTHDATE) = 'May' -- mayÄ±s ayÄ±na ait filtreleme ise bu ÅŸekilde gerÃ§ekleÅŸtirilir.
```

***SORU-3:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2023.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ise ÅŸu ÅŸekildedir:

```sql
 /*
	bir tarih verisi iÃ§erisinden ay verisini string olarak da alabiliriz sÄ±ralama sayÄ±sÄ± olarak da alabiliriz.
	sÄ±ralama sayÄ±sÄ± olarak almak istersek --> DATEPART()
	string olarak almak istersek --> DATENAME()
*/

SELECT *, DATEPART(MONTH, BIRTHDATE) AS 'MONTH' FROM LAB02 -- sayÄ±sal olarak ayÄ± aldÄ±k.
/*
	yÄ±l bilgisini almak iÃ§in datepart fonksiyonunu kullanabiliriz.
*/

SELECT YEAR(DATE_) AS 'YEAR', -- istenilen tarihlerin seÃ§imi
MONTH(DATE_) AS 'MONTH',
SUM(TOTALPRICE) AS 'TOTALSALES' -- toplam satÄ±ÅŸ miktarÄ± hesaplanmasÄ±

FROM LAB03
GROUP BY YEAR(DATE_), MONTH(DATE_) -- tarihlere gÃ¶re gruplanmasÄ±

-- sorunun bizden istediÄŸi senenin 2022 olmasÄ± durumuydu buna gÃ¶re sorguyu tekrar dÃ¼zenlersek:

SELECT YEAR(DATE_) AS 'YEAR',
MONTH(DATE_) AS 'MONTH',
SUM(TOTALPRICE) AS 'TOTALSALES' FROM LAB03
WHERE YEAR(DATE_) = 2022 -- YILIN 2022 OLARAK AYARLANMASI
GROUP BY YEAR(DATE_), MONTH(DATE_)
```

Bu ÅŸekilde Ã§Ã¶zÃ¼mÃ¼ saÄŸlamÄ±ÅŸ oluruz.

***SORU-4:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2024.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB04

/*
	bir tarih verisi iÃ§erisinde haftalarÄ± datepart ile seÃ§ebiliriz DW ise haftanÄ±n gÃ¼nÃ¼nÃ¼ bize verir.
*/

SET LANGUAGE Turkish -- haftanÄ±n gÃ¼nlerini doÄŸru ve tÃ¼rkÃ§e sÄ±ralamasÄ± iÃ§in veri dilini tÃ¼rkÃ§eye ayarladÄ±k.

SELECT 
	DATENAME(DW, DATE_) AS 'DAY_NAME', -- bizden istenilen duruma gÃ¶re haftanÄ±n gÃ¼n ismini dw ile seÃ§tik.
	SUM(TOTALPRICE) AS 'TOTAL SALES' -- toplam satÄ±ÅŸ miktarÄ±nÄ± aldÄ±k
FROM LAB04
	GROUP BY DATEPART(DW, DATE_), DATENAME(DW, DATE_) -- pazartesi, salÄ± diye satÄ±ÅŸlarÄ± grupladÄ±k
	ORDER BY DATEPART(DW, DATE_) -- pazartesi, salÄ±, Ã§arÅŸamba diye doÄŸru bir sÄ±rada listelemek iÃ§in order by kullandÄ±k ve sÄ±raladÄ±k.
```

Bu ÅŸekilde Ã§Ã¶zÃ¼mÃ¼ saÄŸlamÄ±ÅŸ oluruz.

***SORU-5:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2025.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB05

-- saat aralÄ±ÄŸÄ±nÄ± nasÄ±l belirleriz ? DATEPART HOUR KULLANILABÄ°LÄ°R.

SELECT DATEPART(HOUR, '2022-06-25 21:59:34.000')

-- buna uygun olarak sorguyu dÃ¼zenleyerek gidelim

SELECT DATEPART(HOUR, DATE_) AS 'HOUR', -- saat aralÄ±ÄŸÄ± seÃ§tik
SUM(TOTALPRICE) AS 'TOTALSALES' -- her saat aralÄ±ÄŸÄ±nÄ±n toplam satÄ±ÅŸ miktarÄ±nÄ± aldÄ±k
FROM LAB05 
WHERE CUSTOMERGENDER = 'K' AND -- cinsiyetinin kadÄ±n olmasÄ± ÅŸartÄ±nÄ± saÄŸladÄ±k bu birinci ÅŸarttÄ±
DATEDIFF(YEAR, CUSTOMERBIRHTDATE, GETDATE()) BETWEEN 30 AND 50 -- ve seÃ§ilen kadÄ±nlarÄ±n yaÅŸ aralÄ±ÄŸÄ±nÄ± 30 ile 50 arasÄ±nda belirttik
GROUP BY DATEPART(HOUR, DATE_) -- saatlere gÃ¶re verileri gruplayÄ±p
ORDER BY 2 DESC -- toplam satÄ±ÅŸa gÃ¶re en yÃ¼ksek fiyattan en dÃ¼ÅŸÃ¼k fiyata sÄ±ralama yaptÄ±k.

-- Ancak ÅŸÃ¶yle bir durum var ki soru bizden sadece ama sadece en yÃ¼ksek satÄ±ÅŸa sahip olan saat dilimini istemiÅŸti
-- buna uygun olarak ise yapÄ±labilecek en doÄŸru karar top 1 fonksiyonunu yazarak listelemektir. 
-- sorgunun son hali ektedir:

SELECT TOP 1 -- sadece 1 kayÄ±t
DATEPART(HOUR, DATE_) AS 'HOUR',
SUM(TOTALPRICE) AS 'TOTALSALES'
FROM LAB05
WHERE CUSTOMERGENDER = 'K' AND
DATEDIFF(YEAR, CUSTOMERBIRHTDATE, GETDATE()) BETWEEN 30 AND 50
GROUP BY DATEPART(HOUR, DATE_)
ORDER BY 2 DESC
```

***SORU-6:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2026.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
/*
	Ã¶ncelikle gÃ¼n bilgisini almamÄ±z gerekir.
	sonrasÄ±nda gÃ¼n ve ay kÄ±rÄ±lÄ±mlarÄ±na gÃ¶re verileri alabiliriz.
	Ã¶ncelikle gÃ¼n bilgisinden baÅŸlayalÄ±m:
*/

-- gÃ¼n bilgisi iÃ§in datepart kullanabiliriz.

SELECT DATEPART(DAY, DATE_) AS 'DAYS',* FROM LAB06

-- gÃ¼n ve ay kÄ±rÄ±lÄ±mlarÄ±na gÃ¶re listeleme yapabilmek ve toplam satÄ±ÅŸÄ± almak iÃ§in ise yine datepart fonksiyonlarÄ±yla Ã§Ã¶zÃ¼mleriz.

SELECT 
	YEAR(DATE_) AS 'YEARS',
	MONTH(DATE_) AS 'MONTHS',
	SUM(TOTALPRICE) AS 'TOTALSALES' 
FROM LAB06
GROUP BY YEAR(DATE_), MONTH(DATE_)

-- yapÄ± kuruldu ancak her ayÄ±n 10 ile 15 diye bir ÅŸartÄ±mÄ±z var onu saÄŸlamamÄ±zÄ± istersek

SELECT 
	YEAR(DATE_) AS 'YEARS',
	MONTH(DATE_) AS 'MONTHS',
	SUM(TOTALPRICE) AS 'TOTALSALES'
FROM LAB06
WHERE DATEPART(DAY, DATE_) BETWEEN 10 AND 15
GROUP BY YEAR(DATE_), MONTH(DATE_)

-- aylara gÃ¶re sÄ±ralamayÄ± da gerÃ§ekleÅŸtirirsek

SELECT 
	YEAR(DATE_) AS 'YEARS',
	MONTH(DATE_) AS 'MONTHS',
	SUM(TOTALPRICE) AS 'TOTALSALES'
FROM LAB06
WHERE DATEPART(DAY, DATE_) BETWEEN 10 AND 15
GROUP BY YEAR(DATE_), MONTH(DATE_)
ORDER BY 1,2 

-- aylarÄ±n sadece sayÄ±sÄ± deÄŸil yazÄ± olarak da gÃ¶sterilmesini istersek eÄŸer datename kullanabiliriz.

SELECT 
	YEAR(DATE_) AS 'YEARS',  -- yÄ±l bilgisini aldÄ±k
	MONTH(DATE_) AS 'MONTHS', -- ay bilgisini aldÄ±k (sayÄ±sal olarak)
	DATENAME(MONTH, DATE_) AS 'MONTH_NAME', -- ay bilgisini aldÄ±k (karakter olarak)
	SUM(TOTALPRICE) AS 'TOTAL_SALES' -- toplam satÄ±ÅŸ bilgisini hesaplattÄ±k
FROM LAB06
	WHERE DATEPART(DAY, DATE_) BETWEEN 10 AND 15 -- ayÄ±n 10 ve 15 gÃ¼nleri arasÄ±ndaki ifadeleri filtreledik
	GROUP BY YEAR(DATE_), MONTH(DATE_), DATENAME(MONTH, DATE_) -- grupladÄ±k
	ORDER BY 1,2 -- yÄ±l ve ay sÃ¼tunlarÄ±na gÃ¶re sÄ±ralama yaptÄ±rdÄ±k.

-- sorgunun son hali aÅŸaÄŸÄ±daki gibidir:

SELECT 
	YEAR(DATE_) AS 'YEARS', 
	MONTH(DATE_) AS 'MONTHS',
	DATENAME(MONTH, DATE_) AS 'MONTH_NAME',
	SUM(TOTALPRICE) AS 'TOTAL_SALES'
FROM LAB06
	WHERE DATEPART(DAY, DATE_) BETWEEN 10 AND 15
	GROUP BY YEAR(DATE_), MONTH(DATE_), DATENAME(MONTH, DATE_)
	ORDER BY 1,2

```

***SORU-7:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2027.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB07

/* 
	bugÃ¼n doÄŸum gÃ¼nÃ¼ olanlarÄ±n listesini yapacaÄŸÄ±z.
	bugÃ¼nÃ¼n tarihini getdate() ile alabiliriz.
	iki tarihin arasÄ±ndaki kurguyu ise gÃ¼nleri ve aylarÄ± where sorgusuyla doÄŸrulatabiliriz.
*/

-- BugÃ¼nÃ¼n tarihi iÃ§erisinden gÃ¼nÃ¼ ve ayÄ± alalÄ±m.

SELECT DATEPART(MONTH, GETDATE()), DATEPART(DAY, GETDATE())

-- veri setinin iÃ§erisinde gÃ¼n ve ay bilgilerini nasÄ±l alabiliriz?

SELECT *, 
	DATEPART(MONTH, BIRTHDATE) AS 'MONTH',
	DATEPART(DAY, BIRTHDATE) AS 'DAY'
FROM LAB07

-- ÅŸartÄ±mÄ±z olan bugÃ¼nÃ¼n tarihiyle kÄ±yaslayalÄ±m

SELECT *,
	DATEPART(MONTH, BIRTHDATE) AS 'MONTH', -- veri setindeki ay bilgisi
	DATEPART(DAY, BIRTHDATE) AS 'DAY' -- veri setindeki gÃ¼n bilgisi
FROM LAB07
WHERE
	DATEPART(MONTH, BIRTHDATE) = DATEPART(MONTH, GETDATE()) -- sistem gÃ¼ncel tarihindeki ay ile veri setindeki ay bilgisi eÅŸitliÄŸi
	AND
	DATEPART(DAY, BIRTHDATE) = DATEPART(DAY, GETDATE()) -- sistem gÃ¼ncel tarihindeki gÃ¼n ile veri setindeki gÃ¼n bilgisi eÅŸitliÄŸi

-- Sorgunun son hali aÅŸaÄŸÄ±daki gibidir:

SELECT *,
	DATEPART(MONTH, BIRTHDATE) AS 'MONTH', 
	DATEPART(DAY, BIRTHDATE) AS 'DAY'
FROM LAB07
WHERE
	DATEPART(MONTH, BIRTHDATE) = DATEPART(MONTH, GETDATE()) 
	AND
	DATEPART(DAY, BIRTHDATE) = DATEPART(DAY, GETDATE())
```

***SORU-8:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2028.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
/*
	soruya gÃ¶re biz bu ayÄ±n ve maÄŸazalarÄ±n toplam satÄ±ÅŸ verisini listeleyeceÄŸiz.
	Bunun iÃ§in ÅŸu adÄ±mlarÄ± izleyebiliriz.
*/

-- bugÃ¼n yapÄ±lan satÄ±ÅŸlar

SELECT * FROM LAB08
	WHERE
YEAR(DATE_) = YEAR(GETDATE()) AND MONTH(DATE_) = MONTH(GETDATE())

-- hem ÅŸehre hem de toplam satÄ±ÅŸ miktarÄ±na gÃ¶re nasÄ±l dÃ¼zenleyebiliriz

SELECT 
	CITY, 
	SUM(TOTALPRICE) AS 'TOTALSALES'
FROM LAB08
WHERE
	YEAR(DATE_) = YEAR(GETDATE()) AND MONTH(DATE_) = MONTH(GETDATE())
GROUP BY CITY
ORDER BY 1

-- soruda bir Ã¶nceki aydaki verilerden bahsediyorduk getdate()-1 her zaman bir Ã¶ncekini verir.

SELECT SUM(TOTALPRICE) FROM LAB08 WHERE CITY = 'Adana'
AND YEAR(DATE_) = YEAR(GETDATE()) AND MONTH(DATE_) = MONTH(GETDATE()-1)

-- SORGUNUN SON HALÄ° AÅAÄIDAKÄ° GÄ°BÄ°DÄ°R:

SELECT 
	CITY, 
	SUM(TOTALPRICE) AS 'TOTALSALES',
( -- SUBQUERY
	SELECT SUM(TOTALPRICE) FROM LAB08 WHERE CITY = L.CITY
	AND YEAR(DATE_) = YEAR(GETDATE()) AND MONTH(DATE_) = MONTH(GETDATE())-1
)
FROM LAB08 L -- ALLIANCE
WHERE
	YEAR(DATE_) = YEAR(GETDATE()) AND MONTH(DATE_) = MONTH(GETDATE())
GROUP BY CITY
ORDER BY 1
```

***SORU-9:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2029.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB09

-- yeni bir sÃ¼tun ekleyelim

-- ALTER TABLE LAB09 ADD BIRTHDATE2 DATE

-- tarih dÃ¶nÃ¼ÅŸÃ¼mÃ¼ iÃ§in ÅŸu ÅŸekilde bir yapÄ± kurmamÄ±z gerekebilir.

SELECT '26.09.1988', '1998-09-26' -- olarak dÃ¶nÃ¼ÅŸtÃ¼rmemiz gerekecek. 

-- bunun iÃ§in 

SELECT RIGHT('26.09.1988',4) -- yÄ±l iÃ§in
SELECT SUBSTRING('26.09.1988',4,2) -- ay iÃ§in
SELECT LEFT('26.09.1988',2) -- gÃ¼n iÃ§in

-- hepsini yan yana yazalÄ±m:

SELECT RIGHT('26.09.1988',4)+'-'+SUBSTRING('26.09.1988',4,2)+'-'+LEFT('26.09.1988',2)

-- UPDATE ile kurgularsak

UPDATE LAB09 SET BIRTHDATE2 = RIGHT('26.09.1988',4)+'-'+SUBSTRING('26.09.1988',4,2)+'-'+LEFT('26.09.1988',2)
WHERE ID = 2

-- DATEFROMPARTS ile Ã§Ã¶zersek

SELECT DATEFROMPARTS(RIGHT('26.09.1988',4),SUBSTRING('26.09.1988',4,2),LEFT('26.09.1988',2))

-- update sorgusuna uygun yazarsak ise

UPDATE LAB09 SET BIRTHDATE2 = DATEFROMPARTS(RIGHT('26.09.1988',4),SUBSTRING('26.09.1988',4,2),LEFT('26.09.1988',2))
WHERE ID = 2

-- yine aynÄ± yÃ¶ntemi izleyerek o zaman Ã¼Ã§ numaralÄ± kayÄ±t iÃ§in bu ifadeyi gerÃ§ekleÅŸtirelim:

UPDATE LAB09 SET BIRTHDATE2 = DATEFROMPARTS(RIGHT(BIRTHDATE,4), SUBSTRING(BIRTHDATE,4,2), LEFT(BIRTHDATE,2))
WHERE ID = 3

-- bÃ¼tÃ¼n kayÄ±tlarÄ± tekrardan gÃ¼ncelleyelim

UPDATE LAB09 SET BIRTHDATE2 = DATEFROMPARTS(RIGHT(BIRTHDATE,4), SUBSTRING(BIRTHDATE,4,2), LEFT(BIRTHDATE,2)) -- hata alÄ±nÄ±r. Ã§Ã¼nkÃ¼ yanlÄ±ÅŸ formatlanmÄ±ÅŸ veriler var

-- farklÄ± bir yÃ¶ntem izleyerek tekrar yazalÄ±m

UPDATE LAB09 SET BIRTHDATE2 = RIGHT(BIRTHDATE,4)+'-'+SUBSTRING(BIRTHDATE,4,2)+'-'+LEFT(BIRTHDATE,2)
/*
	yine hata alÄ±ndÄ±
	Msg 241, Level 16, State 1, Line 46
	Karakter dizesinden tarihe ve/veya saate dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼rken iÅŸlem baÅŸarÄ±sÄ±z oldu. (Ã§Ã¼nkÃ¼ bozuk verilerim var)
*/

-- peki bozuk verilerden kaÃ§ tane olduÄŸunu tespit edelim:

SELECT *, 
RIGHT(BIRTHDATE,4)+'-'+SUBSTRING(BIRTHDATE,4,2)+'-'+LEFT(BIRTHDATE,2)
FROM LAB09
WHERE ISDATE(RIGHT(BIRTHDATE,4)+'-'+SUBSTRING(BIRTHDATE,4,2)+'-'+LEFT(BIRTHDATE,2)) = 0

-- buna gÃ¶re isdate() sonucunda 1 dÃ¶nenleri Ã§alÄ±ÅŸtÄ±rÄ±rsak ve bozuk verileri gÃ¶z ardÄ± edersek

UPDATE LAB09 SET BIRTHDATE2 = DATEFROMPARTS(RIGHT(BIRTHDATE,4),SUBSTRING(BIRTHDATE,4,2),LEFT(BIRTHDATE,2))
FROM LAB09
WHERE ISDATE(RIGHT(BIRTHDATE,4)+'-'+SUBSTRING(BIRTHDATE,4,2)+'-'+LEFT(BIRTHDATE,2)) = 1
```

### TÄ°P DÃ–NÃœÅTÃœRME FONKSÄ°YONLARI

Herhangi bir tipteki verileri baÅŸka bir tipteki verilere dÃ¶nÃ¼ÅŸtÃ¼rmemize olanak saÄŸlayan bu fonksiyonlarda genel olarak altÄ± adet fonksiyon kullanÄ±lÄ±r:

- Convert
- Cast
- Parse
- Try_Cast
- Try_Convert
- Try_Parse

BunlarÄ±n iÃ§erisinde en Ã§ok kullanÄ±lan fonksiyonlar Convert ve Cast fonksiyonlarÄ±dÄ±r.

### CAST ve CONVERT

Tip dÃ¶nÃ¼ÅŸtÃ¼rmede oldukÃ§a sÄ±klÄ±kla kullanÄ±lan fonksiyonlarÄ±n baÅŸÄ±nda gelen bu fonksiyonlarda temel olarak farklÄ± tÃ¼rdeki veri tipini baÅŸka bir veri tipine uygun olarak dÃ¶nÃ¼ÅŸtÃ¼rmeyi olanak saÄŸlamaktadÄ±r.

```sql
-- CAST ifadesi tip dÃ¶nÃ¼ÅŸtÃ¼rme fonksiyonlarÄ± arasÄ±nda en Ã§ok kullanÄ±lan fonksiyonlardan bir tanesidir.
-- Bu fonksiyonda temel olarak dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi gereken veri tipine uygun olarak verilerin tÃ¼rÃ¼nÃ¼ dÃ¶nÃ¼ÅŸtÃ¼rebiliriz.

-- Ã–rneÄŸin: 
SELECT CAST('2022-12-26' AS DATE) -- String bir ifadeyi date tÃ¼rÃ¼ne dÃ¶ndÃ¼rdÃ¼

-- peki date tÃ¼rÃ¼ne uygun olmayan bir yapÄ±yÄ± dÃ¶nÃ¼ÅŸtÃ¼rebilir miydi (gÃ¼n-ay-yÄ±l)

SELECT CAST('24-09-2002' AS DATE)

/*
	(hayÄ±r dÃ¶nÃ¼ÅŸtÃ¼remez.)
	Msg 241, Level 16, State 1, Line 9
	Conversion failed when converting date and/or time from character string.
*/

-- peki bu veriyi datetime tipine dÃ¶nÃ¼ÅŸtÃ¼rebilir miyiz

SELECT CAST('2022-12-26' AS datetime) -- 2022-12-26 00:00:00.000 (dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼.)

-- veriyi integer'a dÃ¶nÃ¼ÅŸtÃ¼rseydik.

SELECT CAST('2022-12-26' AS INT) -- hata alÄ±nÄ±r Ã§Ã¼nkÃ¼ integer'a uygun deÄŸildir. ancak aradaki ayraÃ§larÄ± kaldÄ±rÄ±rsak

SELECT CAST('20221226' AS INT) -- dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r (20221226)

-- CONVERT FUNCTION

SELECT CONVERT(DATE, '2022-12-27') -- yine aynÄ± ÅŸekilde dÃ¶nÃ¼ÅŸtÃ¼rÃ¼ldÃ¼.

-- yine aynÄ± ÅŸekilde veriyi integera dÃ¶nÃ¼ÅŸtÃ¼rsek

SELECT CONVERT(INT, '2022-12-27') -- hata alÄ±nÄ±r Ã§Ã¼nkÃ¼ int'e uygun deÄŸildir.

SELECT CONVERT(INT, '20221227') -- integera dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼

-- aslÄ±nda birÃ§ok veri tipleri birbirine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lebilir.

-- Ã–rneÄŸin bir stringi binary'e dÃ¶nÃ¼ÅŸtÃ¼rebiliriz.

SELECT CONVERT(binary, 'Merhaba') -- kelimenin binary karÅŸÄ±lÄ±ÄŸÄ± (0x4D6572686162610000000000000000000000000000000000000000000000)

-- yine aynÄ± ÅŸekilde binary ifadeyi string2e dÃ¶nÃ¼ÅŸtÃ¼relim

SELECT CONVERT(varchar(100), 0x4D6572686162610000000000000000000000000000000000000000000000) -- Merhaba

-- mesela float-int iliÅŸkisine bakalÄ±m

SELECT CONVERT(float, 72) -- dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼ (integerdan-floata dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼)

SELECT CONVERT(int, 74.12) -- dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼ (floattan-integera dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼.) -74

-- diyelim ki bugÃ¼nÃ¼n tarihi text olarak yazdÄ±ralÄ±m

SELECT GETDATE() -- anlÄ±k saati ve tarihi verir

SELECT 'BugÃ¼nÃ¼n Tarihi: '+ CONVERT(varchar, CONVERT(DATE, GETDATE()))
SELECT 'Åuan da saat: '+ CONVERT(varchar, CONVERT(TIME, GETDATE()))

-- bunun tabiki daha da kÄ±sayolu vardÄ±r o da ÅŸu ÅŸekildedir:

SELECT CONVERT(varchar, GETDATE()) -- uzun bir ifade verir (Jun 28 2024  2:39PM)

SELECT CONVERT(varchar, GETDATE(),103) -- Ã¼Ã§Ã¼ncÃ¼ ifadeyle istediÄŸim formatÄ± belirledim (28/06/2024)

-- bu ÅŸekilde 100'den baÅŸlayarak farklÄ± formatlarda gÃ¶sterim saÄŸlayabilirim

SELECT CONVERT(varchar, GETDATE(),100) -- Jun 28 2024  2:42PM
SELECT CONVERT(varchar, GETDATE(),101) -- 06/28/2024
SELECT CONVERT(varchar, GETDATE(),102) -- 2024.06.28
SELECT CONVERT(varchar, GETDATE(),103) -- 2024.06.28
SELECT CONVERT(varchar, GETDATE(),104) -- 2024.06.28
SELECT CONVERT(varchar, GETDATE(),105) -- 28-06-2024
SELECT CONVERT(varchar, GETDATE(),106) -- 28 Jun 2024
SELECT CONVERT(varchar, GETDATE(),107) -- Jun 28, 2024
SELECT CONVERT(varchar, GETDATE(),108) -- 14:53:23
```

KÄ±saca bu fonksiyonlarÄ± bu ÅŸekilde tanÄ±mlayabiliriz.

### TRY_CAST ve TRY_CONVERT

Cast ve Convert fonksiyonlarÄ±yla aynÄ± iÅŸleme sahiptir. Tek farkÄ± try ifadesiyle tip dÃ¶nÃ¼ÅŸÃ¼mlerinde hata yÃ¶netimi saÄŸlamasÄ± konusunda bizlere yardÄ±mcÄ± olmaktadÄ±r. Ã–nceki Ã¶rneklerde ele aldÄ±ÄŸÄ±mÄ±z gibi Ã¶rneÄŸin tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼nde hata alÄ±ndÄ±ÄŸÄ± zaman bizlere dÃ¶nÃ¼ÅŸtÃ¼rme hatasÄ± olarak sonuÃ§ dÃ¶ndÃ¼rÃ¼lÃ¼yordu. Burada ise sistem bize hata dÃ¶ndÃ¼rmez. Tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼ne uygun olmayan yapÄ± iÃ§in null deÄŸer dÃ¶ndÃ¼rÃ¼r. Bu ÅŸekilde bÃ¼yÃ¼k Ã§aptaki verilerde daha dÃ¼zgÃ¼n Ã§alÄ±ÅŸmasÄ±na olanak saÄŸlamaktadÄ±r.

```sql
-- Ã–ncelikle bir tarih formatÄ±nÄ± date formatÄ±na Ã§evirmeyi deneyelim

SELECT CAST('2022-16-18' AS DATE) -- hata alÄ±nÄ±r Ã§Ã¼nkÃ¼ 16. ay diye bir yapÄ± yoktur.
/*
	Msg 241, Level 16, State 1, Line 3
	Conversion failed when converting date and/or time from character string.
*/
SELECT CONVERT(DATE, '2022-16-18') -- hata alÄ±nÄ±r Ã§Ã¼nkÃ¼ 16. ay diye bir yapÄ± yoktur.
/*
	Msg 241, Level 16, State 1, Line 3
	Conversion failed when converting date and/or time from character string.
*/

-- peki aynÄ± sorunu try_cast ve try_convert olarak yapalÄ±m.

SELECT TRY_CAST('2022-16-18' AS DATE) -- format yanlÄ±ÅŸtÄ±r ama hata vermez cevap (NULL)

SELECT TRY_CONVERT(DATE, '2022-16-18') -- tarih formatÄ±na uygun deÄŸildir yanlÄ±ÅŸtÄ±r ama hata vermez cevap (NULL)

-- peki doÄŸru formatta veriler girildiÄŸi zaman nasÄ±l bir Ã§Ä±ktÄ± alÄ±rÄ±z.

SELECT TRY_CAST('2022-08-16' AS DATE) -- tarih formatÄ± doÄŸrudur ve cevap: (2022-08-16)

SELECT TRY_CONVERT(DATE, '2022-08-16') -- tarih formatÄ± doÄŸrudur dÃ¶nÃ¼ÅŸtÃ¼rme tamamlandÄ± ve cevap (2022-08-16)

/*
	try_cast ve try_convert fonksiyonlarÄ± aynÄ± cast ve convert gibi kullanÄ±lÄ±r.
	Sadece tek farklarÄ± cast ve convert dÃ¶nÃ¼ÅŸtÃ¼remediÄŸi zamanlarda hata verirken,
	try_cast ve try_convert hata vermez dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lemeyen verileri null olarak girer.
	Bu ÅŸekilde sistem hatasÄ± almadan veri dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemlerini gerÃ§ekleÅŸtirmemize olanak saÄŸlar.
*/ 
```

### DÃ–NÃœÅTÃœRME FONKSÄ°YONLARI ALIÅTIRMALAR

***ALIÅTIRMA - 1:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2030.png)

Bunun Ã§Ã¶zÃ¼mÃ¼nÃ¼ ÅŸu ÅŸekilde gerÃ§ekleÅŸtirebiliriz:

```sql
SELECT * FROM LAB01

/*
	tarih verisini Ã§ekmemiz iÃ§in convert date kullanabiliriz.
	saat verisini Ã§ekmemiz iÃ§in ise convert time kullanabiliriz.
*/

SELECT *,
CONVERT(DATE, DATE_) AS 'TARIHLER', -- tarih formatÄ±nÄ± verir
CONVERT(TIME, DATE_) AS 'SAAT' -- saat formatÄ±nÄ± verir
FROM LAB01

-- farklÄ± bir yÃ¶ntem olarak 

/*
	tarih verisini Ã§ekmemiz iÃ§in cast date kullanabiliriz.
	saat verisini Ã§ekmemiz iÃ§in ise cast time kullanabiliriz.
*/

SELECT *,
CAST(DATE_ AS DATE) AS 'TARIHLER', -- tarih formatÄ±nÄ± verir
CAST(DATE_ AS TIME) AS 'SAAT' -- saat formatÄ±nÄ± verir
FROM LAB01

-- peki bu date_ alanÄ±nÄ± string olarak yazdÄ±rmak isteseydik nasÄ±l yapabilirdik.

SELECT *,
CONVERT(DATE, DATE_) AS 'TARIHLER', -- tarih formatÄ±nÄ± verir
CONVERT(TIME, DATE_) AS 'SAAT', -- saat formatÄ±nÄ± verir
CONVERT(VARCHAR, DATE_, 103) AS 'STRDATE', -- tarih formatÄ±nÄ± string yapÄ±sÄ± olarak verir Ã¶rn. (06/02/2019)
CONVERT(VARCHAR, DATE_, 108) AS 'TIMESTR' -- saat formatÄ±nÄ± string yapÄ±sÄ± olarak verir Ã¶rn. (10:54:58)
FROM LAB01
```

Bu ÅŸekilde sorunu Ã§Ã¶zmÃ¼ÅŸ oluruz.

***ALIÅTIRMA - 2:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2031.png)

Bunun Ã§Ã¶zÃ¼mÃ¼nÃ¼ adÄ±m adÄ±m gerÃ§ekleÅŸtirelim:

```sql
SELECT * FROM LAB02

/*
	soruda bizden istenilen yeni bir alan aÃ§mak buna gÃ¶re alter table kullanarak yeni bir alan aÃ§alÄ±m
	sonrasÄ±nda Ã¶ncelikle convert date kullanarak iÅŸlemi gerÃ§ekleÅŸtirelim
	eÄŸer hata alÄ±rsak buna gÃ¶re try convert date kullanarak yine deneyelim
*/

-- yeni bir alan aÃ§mak iÃ§in 

-- ALTER TABLE LAB02 ADD BIRTHDATE2 DATE --> alanÄ± aÃ§tÄ±k (Commands completed successfully.)

-- alanÄ± gÃ¶rÃ¼ntÃ¼leyelim 

SELECT * FROM LAB02

-- convertle bir deneyelim ve alanÄ± gÃ¼ncelleyelim
UPDATE LAB02 SET BIRTHDATE2 = CONVERT(DATE, BIRTHDATE) -- hata aldÄ±k. Ã§Ã¼nkÃ¼ date tÃ¼rÃ¼ne uygun olmayan veriler var
/*
	Msg 241, Level 16, State 1, Line 18
	Conversion failed when converting date and/or time from character string.
*/

-- hata kontrolÃ¼nÃ¼ yaparak gÃ¼ncelleyelim

UPDATE LAB02 SET BIRTHDATE2 = TRY_CONVERT(DATE, BIRTHDATE) -- tarih formatÄ±na uygun olanlarÄ± dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼ uygun olmayanlara null dedi
```

Bu ÅŸekilde sorunu Ã§Ã¶zmÃ¼ÅŸ oluruz.

***ALIÅTIRMA - 3:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2032.png)

Bunun Ã§Ã¶zÃ¼mÃ¼nÃ¼ adÄ±m adÄ±m gerÃ§ekleÅŸtirelim:

```sql
SELECT * FROM LAB03

/*
	akÄ±llÄ± barkod oluÅŸturacaÄŸÄ±z.
	categorycode-itemcode-year-month-day-hour-minute-second ÅŸeklinde oluÅŸacak.
*/

SELECT  
CATEGORY1CODE +'-'+REPLICATE('0', 6-LEN(ITEMCODE))+ITEMCODE+'-'+
REPLACE(CONVERT(VARCHAR, GETDATE(), 102), '.','-')+
REPLACE(CONVERT(VARCHAR, GETDATE(), 108), ':', ''),
* FROM LAB03 WHERE ITEMCODE = 1
```

Bu ÅŸekilde sorunu Ã§Ã¶zmÃ¼ÅŸ oluruz.

### MATEMATÄ°K FONKSÄ°YONLARI

TSQLâ€™de matematiksel olarak iÅŸlemleri gerÃ§ekleÅŸtirebilmek iÃ§in Ã§ok fazla fonksiyonlar vardÄ±r. BazÄ± fonksiyonlarÄ± bu bÃ¶lÃ¼mde ele alacaÄŸÄ±z:

- ABS Function: Bir sayÄ±nÄ±n mutlak deÄŸerini almaktadÄ±r. Mutlak deÄŸer denilen ifadede bir sayÄ± eÄŸer negatifse pozitife dÃ¶nÃ¼ÅŸÃ¼r. Pozitif ise pozitif olarak kalmaya devam edecektir.
- SIGN Function: Bir sayÄ±nÄ±n yÃ¶nÃ¼nÃ¼ belirtmek iÃ§in kullanÄ±lan fonksiyondur. YÃ¶nden kastÄ±mÄ±z tabii ki sayÄ±nÄ±n negatif mi yoksa pozitif mi olduÄŸu durumlardÄ±r. Ã–rneÄŸin (-21,8) fonksiyonu negatif deÄŸeri temsil ederken, (21,8) pozitif yÃ¶nÃ¼ temsil etmektedir.

Bu iki fonksiyonun kullanÄ±mÄ± ÅŸu ÅŸekildedir:

```sql
SELECT ABS(28) -- (28)

SELECT ABS(-28) -- (28)

SELECT ABS(-28.78) -- (28.78)

SELECT ABS(28.78) -- (28.78) 

-- SIGN FUNCTION

/*
	Fonksiyon iÃ§erisinde belirtilen sayÄ± eÄŸer pozitifse (1) deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r.
	EÄŸer sayÄ± negatifse sonuÃ§ olarak (-1) deÄŸeri dÃ¶ndÃ¼rÃ¼lÃ¼r.
	EÄŸer sayÄ± sÄ±fÄ±rsa cevap da 0 olarak gelecektir.
	AyrÄ±ca
	Decimal karakterlerde virgÃ¼lden sonra kaÃ§ karakter varsa sonuÃ§ deÄŸerinin yanÄ±na o kadar sÄ±fÄ±r koyulur.
	Ã–rneÄŸin (28.78) deÄŸeri Ã§Ä±ktÄ± olarak (1.00) ÅŸeklinde dÃ¶necektir.
	Bu durum negatif sayÄ±larda da geÃ§erlidir.
	Ã–rneÄŸin (-78.9078) sayÄ±sÄ±nÄ±n sonuÃ§ deÄŸeri (-1.0000) olarak Ã§Ä±kacaktÄ±r.
*/

SELECT SIGN(28) -- (1)

SELECT SIGN(-28) -- (-1)

SELECT SIGN(0) -- (0)

SELECT SIGN(28.98) -- (1.00)

SELECT SIGN(-28.98) -- (-1.00)

SELECT SIGN(1982.938493739) -- (1.000000000)

SELECT SIGN(-1982.938493739) -- (-1.000000000)
```

> ABS ve SIGN fonksiyonlarÄ± genellikle farklÄ± zamanlarda alÄ±nmÄ±ÅŸ veriler arasÄ±ndaki deÄŸiÅŸim frekansÄ±nÄ± bulmak iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin aylÄ±k bazda satÄ±ÅŸlarda bazen dÃ¼ÅŸÃ¼ÅŸler bazen yÃ¼kseliÅŸler gibi farklÄ± farklÄ± dalgalanmalar olabilir. Bu dalgalanmalarÄ± yÃ¶nlerinden baÄŸÄ±msÄ±z olarak analiz etmek iÃ§in ABS fonksiyonu kullanÄ±lÄ±r.
> 

> SIGN fonksiyonu ise yine aynÄ± mantÄ±kla Ã§alÄ±ÅŸmaktadÄ±r. Yine aynÄ± ÅŸekilde satÄ±ÅŸ verileri Ã¼zerindeki dalgalanmalarÄ±n yÃ¶nÃ¼nÃ¼ Ã¶ÄŸrenebilmemiz iÃ§in sÄ±klÄ±kla kullanÄ±labilen fonksiyonlardan bir tanesidir.
> 

Matematik fonksiyonlarÄ±na ROUND, FLOOR ve CEILING fonksiyonlarÄ± kÃ¼mesiyle devam edelim. Bu fonksiyon kÃ¼melerinde sayÄ± yuvarlama iÅŸlemleri gerÃ§ekleÅŸtirilir. Bu fonksiyonlarÄ± adÄ±m adÄ±m ele alalÄ±m:

- ROUND Function: Ä°Ã§erisinde iki adet parametre alan bu fonksiyonda virgÃ¼lden sonra kaÃ§ adet karakter alÄ±nacaÄŸÄ±nÄ± biz belirleyebiliriz. Ã–rneÄŸin (48.8765) virgÃ¼lden sonra 2 karakter alÄ±nacaÄŸÄ± belirtirsek virgÃ¼lden sonra 2 sayÄ± alÄ±r. Burada yuvarlama iÅŸlemini de (0.50) sayÄ±sÄ±na gÃ¶re belirler. Ã–rneÄŸin (48.8765) sayÄ±sÄ±nda 2 digit olarak 87 sayÄ±sÄ± alÄ±nÄ±r. Ancak bu digitlerden sonra 65 sayÄ±sÄ± (0.50)â€™den bÃ¼yÃ¼k olduÄŸu iÃ§in sonuÃ§ (48.8800) olarak verecektir. EÄŸer alÄ±nan iki digit sayÄ±sÄ± (0.50)â€™den kÃ¼Ã§Ã¼k olsaydÄ± bu sefer sayÄ±yÄ± bir aÅŸaÄŸÄ± yuvarlardÄ±. Ã–rneÄŸin (48.8740) â†’ (48.8700). EÄŸer sayÄ± (0.50) ye eÅŸit olsaydÄ± yine aynÄ± ÅŸekilde yukarÄ± yuvarlayacaktÄ±. Ã–rneÄŸin (48.8750) â†’ (48.8800)
- FLOOR Function: SayÄ±yÄ± her zaman aÅŸaÄŸÄ± yÃ¶nlÃ¼ olarak yuvarlayacaktÄ±r. Ã–rneÄŸin (156.48) â†’ (156) veya (179.89) â†’ (179) olarak iÅŸlemi gerÃ§ekleÅŸtirecektir.
- CEILING Function: Floor fonksiyonunun tam olarak tersidir. Burada ise sayÄ±yÄ± her zaman bir Ã¼st ondalÄ±k sayÄ±ya yuvarlayacaktÄ±r. Ã–rneÄŸin (156.89) â†’ (157) veya (157.12) â†’ (158) ÅŸeklinde sonuÃ§lar vermektedir.

Bu fonksiyonlarla ilgili ÅŸu Ã¶rneklere bakabiliriz:

```sql
/*
	ROUND, FLOOR, CEILING FUNCTIONS (YUVARLAMA FONKSIYONLARI)
*/

SELECT ROUND(179.9835, 2) -- (sonu 35 olduÄŸu iÃ§in bir aÅŸaÄŸÄ± yuvarladÄ± ve o son iki sayÄ±yÄ± sildi sÄ±fÄ±r yazdÄ±) cevap (179.9800)

SELECT ROUND(179.9850, 2) -- (sonu 50 olduÄŸu iÃ§in bir yukarÄ± yuvarladÄ± ve o son iki sayÄ±yÄ± sildi sÄ±fÄ±r yazdÄ±) cevap (179.9900)

SELECT ROUND(179.9890, 2) -- (sonu 90 olduÄŸu iÃ§in bir yukarÄ± yuvarladÄ± ve o son iki sayÄ±yÄ± sildi sÄ±fÄ±r yazdÄ±) cevap (179.9900)

/* peki virgÃ¼lden sonra neden sÄ±fÄ±r yazdÄ± bu sayÄ±larÄ± silemez miyiz gibi bir soru aklÄ±nÄ±za takÄ±lÄ±rsa
	burada deÄŸer decimal tÃ¼rÃ¼nde olduÄŸu iÃ§in decimal deÄŸer verir eÄŸer ki bu iÃ§erisindeki deÄŸeri floata dÃ¶nÃ¼ÅŸtÃ¼rÃ¼rsek 
	cevap da float olarak dÃ¶nÃ¼ÅŸ yapacaktÄ±r.
*/

SELECT CONVERT(FLOAT, ROUND(179.9890, 2)) -- (90) yukarÄ± yÃ¶nlÃ¼ ondalÄ±k hesaplamasÄ±nÄ± yaptÄ±rdÄ±m sonra floata dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼m cevap (179,99)

SELECT CONVERT(FLOAT, ROUND(179.9850, 2)) -- (50) yukarÄ± yÃ¶nlÃ¼ ondalÄ±k hesaplamasÄ±nÄ± yaptÄ±rdÄ±m sonra floata dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼m cevap (179,99)

SELECT CONVERT(FLOAT, ROUND(179.9830, 2)) -- (30) aÅŸaÄŸÄ± yÃ¶nlÃ¼ ondalÄ±k hesaplamasÄ±nÄ± yaptÄ±rdÄ±m sonra floata dÃ¶nÃ¼ÅŸtÃ¼rdÃ¼m cevap (179,98)

-- FLOOR FUNCTION -- (her koÅŸulda bir alt ondalÄ±ÄŸa yuvarlama)

SELECT FLOOR(179.9083) -- 179

SELECT FLOOR(178.65) -- 178

SELECT FLOOR(-178.65) -- negatif sayÄ±larda aÅŸaÄŸÄ± yuvarladÄ± ve sonuÃ§ (-179)

SELECT FLOOR(-178.45) -- negatif sayÄ±larda aÅŸaÄŸÄ± yuvarladÄ± ve sonuÃ§ (-179)

-- CEILING FUNTION -- (her koÅŸulda bir Ã¼st ondalÄ±ÄŸa yuvarlama)

SELECT CEILING(179.9083) -- bir Ã¼st ondalÄ±k sayÄ±ya yuvarladÄ± (180)

SELECT CEILING(178.1500) -- bir Ã¼st ondalÄ±k sayÄ±ya yuvarladÄ± (179)

SELECT CEILING(-178.65) -- negatif sayÄ±larda yukarÄ± yuvarladÄ± ve sonuÃ§ (-178) (sayÄ± 0'a yaklaÅŸtÄ±kÃ§a bÃ¼yÃ¼r.)

SELECT CEILING(-178.45) -- negatif sayÄ±larda yukarÄ± yuvarladÄ± ve sonuÃ§ (-178) 
```

> Bu fonksiyonlarÄ±n neredeyse tamamÄ± veri analizlerinde sÄ±klÄ±kla kullanÄ±lan fonksiyonlarÄ±n baÅŸÄ±nda gelmektedir.
> 

Matematik fonksiyonlarÄ±na RAND fonksiyonuyla devam edelim. Bu fonksiyonda 0 ile 1 arasÄ±nda rastgele bir adet sayÄ± Ã¼retmek iÃ§in kullanÄ±lÄ±r.

Åu Ã¶rnekler Ã¼zerinden gidelim:

```sql
/*
	RAND() --> 0-1 arasÄ±nda rastgele sayÄ±lar Ã¼retir.
*/

SELECT RAND() -- 0,750020993827269

SELECT RAND() -- 0,14228996696352

SELECT RAND() -- 0,26659128423981

-- peki belirli bir sayÄ± arasÄ±nda deÄŸerleri nasÄ±l Ã¼retebiliriz ?

SELECT RAND()*100 -- (0-100 arasÄ±nda deÄŸerler Ã¼retir.) 33,1685229863244

SELECT RAND()*100 -- (0-100 arasÄ±nda deÄŸerler Ã¼retir.) 17,4923769309541

SELECT RAND()*50 -- (0-50 arasÄ±nda deÄŸerler Ã¼retir.) 44,1225391265993

-- peki 50-100 arasÄ±nda deÄŸer Ã¼rettirirsek

SELECT 50+RAND()*100 -- (50-100 arasÄ±nda deÄŸerler Ã¼retir.) 55,0688982925827

SELECT 50+RAND()*100 -- (50-100 arasÄ±nda deÄŸerler Ã¼retir.) 80,4596849637517

-- sayÄ±yÄ± decimal olarak deÄŸil integer olarak getirtmek istiyorsak ise convert kullanabiliriz.

SELECT CONVERT(INT,50+RAND()*100) -- (50-100 arasÄ±nda integer deÄŸer Ã¼retti.) 56

SELECT CONVERT(INT,RAND()*100) -- (0-100 arasÄ±nda integer deÄŸer Ã¼retti.) 32
```

> Genel anlamda matematiksel fonksiyonlarÄ± bu ÅŸekilde ele alabiliriz.
> 

BirkaÃ§ Ã¶rnekle bu konuyu pekiÅŸtirelim:

***SORU-1:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2033.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB01

SELECT CUSTOMERID, SUM(AMOUNT) AS 'bakiye' FROM LAB01
WHERE CUSTOMERID = 55
GROUP BY CUSTOMERID

SELECT -5109754 + 5342574 -- giden miktardan gelen miktarÄ±n Ã§Ä±karÄ±lmasÄ± sonucu bulunan bakiye

-- para hacmini bulabilmek iÃ§in ise bu deÄŸerin pozitif olarak toplanmasÄ± gereklidir. yani

SELECT ABS(-5109754) + ABS(5342574) -- yani toplam para hacmi --> 10452328

-- peki bunu sorguda yaparsak

SELECT CUSTOMERID, 
SUM(AMOUNT) AS 'BALANCE',
SUM(ABS(AMOUNT)) AS 'MONEY_VOLUME'
FROM LAB01
GROUP BY CUSTOMERID
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olmaktadÄ±r.

***SORU-2:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2034.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekilde olmaktadÄ±r:

```sql
SELECT * FROM LAB02 -- 299 toplam kayÄ±t sayÄ±sÄ±

-- rastgele olarak 1-299 arasÄ±nda iki sayÄ± Ã¼retirsem bu eÅŸleÅŸmeyi saÄŸlamÄ±ÅŸ olurum

SELECT RAND()*299 -- ondalÄ±klÄ± Ã¼retir. 

SELECT CONVERT(INT, RAND()*299) -- 239

-- bunu sorgunun iÃ§erisinde where ÅŸartÄ±yla getirtsek

SELECT * FROM LAB02
WHERE
ID = CONVERT(INT, RAND()*299) 

-- Angers VS Moreirense FC ÅŸeklinde kurgulayabiliriz.

-- bir baÅŸka yÃ¶ntem ise NEWID() kullanmaktÄ±r. 
-- NEWID() ise yeni bir global identify Ã¼retir.

SELECT NEWID()

-- order by ile rastgelelik sÄ±ralamasÄ±nda newid() kullanÄ±rsak ise

SELECT TOP 1 * FROM LAB02 
ORDER BY
NEWID() -- LIV - Liverpool -131

-- bu ÅŸekilde de Ã§Ã¶zmÃ¼ÅŸ oluruz.
```

Bu ÅŸekilde istenilen sorgu kurgulanmÄ±ÅŸ olur.

***SORU-3:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2035.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekilde yapÄ±labilir:

```sql
SELECT * FROM LAB03

SELECT 
CATEGORY1+'>'+CATEGORY2+'>'+CATEGORY3+'>'+CATEGORY4 CATEGORY,
SUM(TOTALPRICE) AS 'TOTAL_SALES',
CONVERT(INT, SUM(TOTALPRICE)) AS 'TOTAL_SALES_INT',
FLOOR(SUM(TOTALPRICE)) AS 'TOTAL_SALES_FLOOR',
CEILING(SUM(TOTALPRICE)) AS 'TOTAL_SALES_CEILING',
ROUND(SUM(TOTALPRICE), 0) AS 'TOTAL_SALES_ROUND'
FROM LAB03
GROUP BY CATEGORY1,CATEGORY2,CATEGORY3,CATEGORY4
ORDER BY 1
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

## TSQL PROGRAMLAMAYA GÄ°RÄ°Å

Bu bÃ¶lÃ¼mde ÅŸu konularÄ± ele alacaÄŸÄ±z:

- DeÄŸiÅŸkenler
- Åart BloklarÄ±
- DÃ¶ngÃ¼ler
- Hata YÃ¶netimi
- Cursor KavramÄ±

### DeÄŸiÅŸkenler

BÃ¼tÃ¼n programlama dillerinde olan deÄŸiÅŸkenler, belirli sayÄ±sal veya karaktersel verileri iÃ§erisinde barÄ±ndÄ±ran bir yapÄ±dÄ±r. Bu bÃ¶lÃ¼mde TSQL ile deÄŸiÅŸkenler yapÄ±larÄ± ele alÄ±nacaktÄ±r. Bu bÃ¶lÃ¼mde iÅŸlenecek konular ÅŸu ÅŸekildedir:

- DeÄŸiÅŸken kavramÄ±
- DeÄŸiÅŸken tanÄ±mlama
- DeÄŸiÅŸkene deÄŸer atama
- VarsayÄ±lan deÄŸer tanÄ±mlama
- DeÄŸiÅŸkenden deÄŸer okuma
- SQL sorgusundan gelen deÄŸerden deÄŸiÅŸkene deÄŸer atama
- SQL sorgusu iÃ§inde deÄŸiÅŸkenleri kullanma

***DEÄÄ°ÅKEN KAVRAMI***

TSQLâ€™de deÄŸiÅŸkenlerde farklÄ± farklÄ± Ã¶zellikler mevcuttur. BunlarÄ± madde madde aÃ§Ä±klayalÄ±m:

- TSQLâ€™de bir deÄŸiÅŸken `DECLARE @SAYI1` ÅŸeklinde tanÄ±mlanÄ±r.
- AS ifadesinden sonra bu deÄŸiÅŸkenin hangi veri tipinde olduÄŸu belirtilir. `DECLARE @SAYI1 AS INT` ÅŸeklinde kurgulanÄ±r.
- DeÄŸiÅŸkeni gÃ¶rÃ¼ntÃ¼lemek veya okumak iÃ§in ise `SELECT @SAYI1` ÅŸeklinde yazÄ±lmasÄ± gereklidir.
- Bir deÄŸiÅŸkene deÄŸer verme iki tÃ¼rlÃ¼dÃ¼r: Birinci varsayÄ±lan olarak deÄŸer verilir. Ã–rneÄŸin, `DECLARE @SAYI1 AS INT = 15` ÅŸeklindedir. DiÄŸerinde ise set edilerek deÄŸer girilebilir. Ã–rneÄŸin:  `DECLARE @SAYI1 AS INT SET @SAYI1 = 50`  gibi bir yapÄ±da kurulabilir.
- Ä°ki deÄŸiÅŸken toplanÄ±lmasÄ± istenirse ise bunu ÅŸu ÅŸekilde kurgulayabiliriz. `DECLARE @TOPLAM AS INT SET @TOPLAM = @SAYI1 + @SAYI2` bu ÅŸekilde iki sayÄ± toplanmÄ±ÅŸ olur.

<aside>
ğŸ’¡ SayÄ±sal olarak deÄŸeri var olan bir deÄŸiÅŸkenle, iÃ§erisinde herhangi bir ÅŸekilde veri olmayan ***NULL*** bir deÄŸiÅŸken toplanÄ±rsa cevap ***NULL*** olur.

</aside>

Bu konuyla ilgili sorgularÄ± inceleyebilirsiniz:

```sql
/*
	 TSQL'de deÄŸiÅŸkenler DECLARE (@) iÅŸareti ile tanÄ±mlanÄ±r.
	 AS ifadesinden sonra deÄŸiÅŸkenin hangi veri tipinde olduÄŸu belirtilir.
	 SET ile deÄŸiÅŸkenin deÄŸeri girilir.
	 SELECT @degisken ile ise deÄŸiÅŸken gÃ¶sterilir.
*/

-- bir deÄŸiÅŸken tanÄ±mlayalÄ±m:

DECLARE @SAYI AS INT

-- bir deÄŸiÅŸkenin deÄŸerini girelim

DECLARE @SAYI1 AS INT
SET @SAYI1 = 15

-- bir deÄŸiÅŸken daha tanÄ±mlayalÄ±m:

DECLARE @SAYI2 AS INT
SET @SAYI2 = 20

-- bu iki deÄŸiÅŸkeni toplayalÄ±m:

DECLARE @TOPLAM AS INT
SET @TOPLAM = @SAYI1 + @SAYI2

-- bu deÄŸiÅŸkenleri ekranda gÃ¶sterelim

SELECT @SAYI1, @SAYI2, @TOPLAM

-- bazÄ± pÃ¼f noktalar...

/*	deÄŸiÅŸkeni varsayÄ±lan olarak tanÄ±mlayabilirsin. */

DECLARE @SAYI5 AS INT=25

-- eÄŸer bu ifade set edilerek yeni bir deÄŸer girilirse

DECLARE @SAYI6 AS INT=25
SET @SAYI6 = 30 -- EN SON GÄ°RÄ°LEN CEVAP 30 OLDUÄU Ä°Ã‡Ä°N CEVAP 30'DUR.

-- tanÄ±mlÄ± bir deÄŸiÅŸkenle tanÄ±mlÄ± olmayan yani null olan deÄŸerler toplanÄ±rsa sonuÃ§ nedir

DECLARE @SAYI7 AS INT= 40 -- ilk sayÄ± tanÄ±mlÄ±

DECLARE @SAYI8 AS INT -- ikinci sayÄ± boÅŸ deÄŸer yani null

DECLARE @TOPLA AS INT
SET @TOPLA = @SAYI7 + @SAYI8

SELECT @SAYI7,@SAYI8,@TOPLA -- cevap null

-- yani boÅŸ deÄŸerle dolu bir deÄŸer toplanÄ±rsa cevap NULL'dÄ±r.
```

TSQLâ€™de deÄŸiÅŸkenler sadece sayÄ±sal olarak tanÄ±mlanmazlar. AynÄ± zamanda karakter verileri yani VARCHAR olarak da tanÄ±mlanabilirler. SayÄ±sal kÄ±sÄ±mda olan Ã¶zelliklerin ve kurallarÄ±n tamamÄ± karakter verileri yani varchar() tÃ¼rÃ¼ndeki deÄŸiÅŸkenlerde de geÃ§erlidir.

Ã–rnek sorgu parÃ§asÄ±nÄ± inceleyiniz:

```sql
/*
	TSQL'de deÄŸiÅŸkenler sadece sayÄ±sal olarak tanÄ±mlanmaz.
	Karakter deÄŸiÅŸkenleri de tanÄ±mlanabilir.
*/

-- bir tane isim deÄŸiÅŸkeni oluÅŸturalÄ±m:
DECLARE @AD AS VARCHAR(100)
	SET @AD = 'AHMET'

-- bir tane daha isim deÄŸiÅŸkeni oluÅŸturalÄ±m:
DECLARE @SOYAD AS VARCHAR(100)
	SET @SOYAD = 'KILINÃ‡'

-- iki tane isim deÄŸiÅŸkenini toplayalÄ±m:
DECLARE @AD_SOYAD AS VARCHAR(200)
	SET @AD_SOYAD = @AD +' '+ @SOYAD

-- birleÅŸtirilmiÅŸ ifadenin toplam karakter sayÄ±sÄ± yani uzunluÄŸunu alalÄ±m:
DECLARE @UZUNLUK AS INT 
	SET @UZUNLUK = LEN(@AD_SOYAD)

-- sonuÃ§larÄ± gÃ¶rÃ¼ntÃ¼leyelim:
SELECT @AD, @SOYAD, @AD_SOYAD, @UZUNLUK

-- sayÄ±sal deÄŸiÅŸkenlerde olduÄŸu gibi tanÄ±mlÄ± bir deÄŸerle tanÄ±msÄ±z olan bir deÄŸer toplanÄ±rsa sonuÃ§ NULL'dÄ±r.

DECLARE @isim as VARCHAR(100)
	-- SET @isim

DECLARE @soy_isim as VARCHAR(100)
	SET @soy_isim = 'BAÅAR'

DECLARE @isim_soyad as VARCHAR(200)
	SET @isim_soyad = @isim + ' '+ @soy_isim -- NULL

DECLARE @isim_uzunluk INT
	SET @isim_uzunluk = LEN(@isim_soyad) -- NULL

SELECT @isim, @soy_isim, @isim_soyad, @isim_uzunluk

-- default deÄŸer ise ÅŸu ÅŸekilde tanÄ±mlanÄ±r:

DECLARE @default_values AS VARCHAR(100) = 'BAÅARI' 
```

Bu ÅŸekilde string tÃ¼rÃ¼ndeki deÄŸiÅŸkenler oluÅŸturulur.

Bir sonraki deÄŸiÅŸken tÃ¼rÃ¼mÃ¼z ise en Ã§ok kullanÄ±lan veri tiplerinden biri olan DateTime veri tiplerinde olacaktÄ±r.

Date verileri Ã¼zerinden istediÄŸimiz gibi deÄŸiÅŸkenler oluÅŸturarak bunlarÄ± efektif bir ÅŸekilde kullanabiliriz.

Ã–rneÄŸin:

```sql
/*
	Bir yaÅŸ hesaplamasÄ±nÄ± yapalÄ±m
*/

DECLARE @DOGUMTARIHI AS DATE -- date tÃ¼rÃ¼nde deÄŸiÅŸken
DECLARE @YAS AS INT -- int tÃ¼rÃ¼nde yaÅŸ deÄŸiÅŸkeni
DECLARE @TARIH AS DATE -- date tÃ¼rÃ¼nde tarih deÄŸiÅŸkeni

SET @DOGUMTARIHI = '1986-08-25'
SET @TARIH = GETDATE() -- bugÃ¼nÃ¼n tarihiyle hesap yapabiliriz.
SET @TARIH = DATEADD(YEAR,-10,GETDATE()) -- 10 yÄ±l Ã¶nceki yaÅŸÄ±nÄ± ekleyebiliriz.

SET @YAS = DATEDIFF(YEAR, @DOGUMTARIHI, @TARIH) -- yaÅŸÄ±nÄ± hesaplayan deÄŸiÅŸken

SELECT @YAS, @TARIH

-- 10 yÄ±l Ã¶nceki tarih
SET @TARIH = DATEADD(YEAR,-10,GETDATE())

-- 28 ay Ã¶nceki tarih
SET @TARIH = DATEADD(MONTH,-28,GETDATE())
```

Bir baÅŸka Ã¶rnekte ise sistemin anlÄ±k datetime verisini istediÄŸimiz ÅŸekilde parÃ§alayarak deÄŸiÅŸkenlere atayalÄ±m:

Ã–rneÄŸin:

```sql
DECLARE @TARIH AS DATETIME -- tarih deÄŸiÅŸkenini oluÅŸturduk

SET @TARIH = GETDATE() -- sistemin anlÄ±k datetime verisini alalÄ±m

SELECT @TARIH
-- tarih tÃ¼rÃ¼ndeki verilerin her birini parÃ§alayalÄ±m ve deÄŸiÅŸkenlere atalÄ±m
DECLARE @YIL AS INT -- yÄ±l deÄŸiÅŸkeni
DECLARE @AY AS INT
DECLARE @GUN AS INT
DECLARE @SAAT AS INT
DECLARE @DAKIKA AS INT
DECLARE @SANIYE AS INT

SET @YIL = YEAR(@TARIH) -- yÄ±l deÄŸiÅŸkeni oluÅŸturma
SET @AY = MONTH(@TARIH)
SET @GUN = DAY(@TARIH)
SET @SAAT = DATEPART(HOUR, @TARIH)
SET @DAKIKA = DATEPART(MINUTE, @TARIH)
SET @SANIYE = DATEPART(SECOND, @TARIH)

SELECT @TARIH, @YIL, @AY, @GUN, @SAAT, @DAKIKA, @SANIYE
```

Datetime verileri Ã¼zerinden deÄŸiÅŸkenler bu ÅŸekilde tanÄ±mlanarak kullanÄ±labilir.

TSQLâ€™de genellikle statik olarak deÄŸiÅŸken tanÄ±mlanmasÄ± Ã§ok sÄ±klÄ±kla karÅŸÄ±laÅŸÄ±lan bir durum deÄŸildir. Genellikle deÄŸiÅŸkenler daha Ã§ok SQL sorgusundan gelen dinamik verilere tanÄ±mlanarak iÅŸlemler gerÃ§ekleÅŸtirilir. Bu bÃ¶lÃ¼mde onu ele almaya Ã§alÄ±ÅŸacaÄŸÄ±z:

SQL sorgusundan gelen ifadeleri deÄŸiÅŸkenlere atamak iÃ§in iki farklÄ± yÃ¶ntem vardÄ±r:

- Direkt olarak SELECT sorgusu iÃ§erisinde deÄŸiÅŸken tanÄ±mlanabilir. Ã–rneÄŸin: `SELECT @TOTALSALE = SUM(TOTALPRICE) FROM SALES WHERE CITY = 'Ä°STANBUL'`
- DiÄŸer bir yapÄ± olarak ise SET ile bu deÄŸiÅŸkenler tanÄ±mlanabilir. Ã–rneÄŸin: `SET @TOTALSALE = (SELECT SUM(TOTALPRICE) FROM SALES WHERE CITY = 'Ä°STANBUL')`

Bu ÅŸekilde kurgulanabilir. 

Ã–rnek sorgularÄ± inceleyelim:

```sql
SELECT * FROM SALES

-- bu tablo iÃ§erisindeki toplam satÄ±ÅŸÄ± gÃ¶sterelim

SELECT SUM(TOTALPRICE) AS TOTALSALE
FROM SALES
WHERE CITY = 'Ä°STANBUL' -- istanbul'daki toplam satÄ±ÅŸ 

-- peki bunu bir deÄŸiÅŸkene atayalÄ±m bunun iki adet yÃ¶ntemi vardÄ±r:
-- birinci yÃ¶ntem
--DECLARE @TOTALSALE AS FLOAT
/*
SELECT @TOTALSALE = SUM(TOTALPRICE)
FROM SALES
WHERE CITY = 'Ä°STANBUL' 

SELECT @TOTALSALE
*/
-- ikinci yÃ¶ntem ise ÅŸudur: (SET ile)
 --SET @TOTALSALE = (SELECT SUM(TOTALPRICE) FROM SALES WHERE CITY = 'Ä°STANBUL')
 -- SET @TOTALAMOUNT = (SELECT SUM(AMOUNT) FROM SALES WHERE CITY = 'Ä°STANBUL')

 -- burada Ã¶nemli nokta ÅŸudur. Bir deÄŸiÅŸken sadece bir veri tutar.
 -- yani sorgu sonucunda iki adet kolon dÃ¶nseydi hata alÄ±rdÄ±k. 
 -- o zaman bu bilgilere gÃ¶re aynÄ± sorgu iÃ§erisinde iki adet deÄŸiÅŸken tanÄ±mlanabilir mi
 -- cevap evet tanÄ±mlanabilir.

 DECLARE @TOTALSALE AS FLOAT
 DECLARE @TOTALAMOUNT AS INT
 DECLARE @ROWCOUNT AS INT

SELECT 
	@TOTALSALE = SUM(TOTALPRICE), 
	@TOTALAMOUNT = SUM(AMOUNT),
	@ROWCOUNT = COUNT(*)
FROM SALES
WHERE CITY = 'Ä°STANBUL' 

SELECT @TOTALSALE AS 'TOPLAM_CÄ°RO', @TOTALAMOUNT AS 'TOPLAM_SATIÅ', @ROWCOUNT AS 'SATIR_SAYISI' -- alliance
```

Bu ÅŸekilde yapÄ±lar kurulabilir.

Bu ÅŸekilde bir SQL sorgusunu bir deÄŸiÅŸkene nasÄ±l atayabileceÄŸimizi gÃ¶stermiÅŸ olduk. Bu sefer tam tersini gerÃ§ekleÅŸtirerek bir SQL sorgusunu, bir deÄŸiÅŸkene nasÄ±l parametre olarak atayabileceÄŸimizi ele alalÄ±m:

Åu sorgularÄ± inceleyelim:

```sql
DECLARE @CITY AS VARCHAR(100)
SET @CITY = 'A%' -- SET @CITY = 'ANKARA'

SELECT * FROM SALES
WHERE
CITY LIKE @CITY -- CITY = @CITY

-- son Ã¼Ã§ yÄ±lÄ±n verilerini alalÄ±m 
-- bunun iÃ§in baÅŸlangÄ±Ã§ ve bitiÅŸ tarihlerini alabiliriz.

DECLARE @BEGDATE AS DATE = DATEADD(YEAR, -5, GETDATE())
DECLARE @ENDDATE AS DATE = GETDATE()

SELECT * FROM SALES
WHERE
CITY LIKE @CITY -- CITY = @CITY
AND DATE_ BETWEEN @BEGDATE AND @ENDDATE

-- bide marka deÄŸiÅŸkenini girebiliriz.

DECLARE @BEGDATE AS DATE = DATEADD(YEAR, -5, GETDATE())
DECLARE @ENDDATE AS DATE = GETDATE()
DECLARE @BRAND AS VARCHAR(100) = 'ULKER' -- ismi Ã¼lker olan markalar veya (U%)

SELECT * FROM SALES
WHERE
CITY LIKE @CITY -- CITY = @CITY
AND DATE_ BETWEEN @BEGDATE AND @ENDDATE
AND BRAND LIKE @BRAND
```

Bu ÅŸekilde sorgular oluÅŸturabiliriz.

Genel anlamda deÄŸineceklerimiz bu kadardÄ±. BirkaÃ§ alÄ±ÅŸtÄ±rma ile bu konularÄ± pekiÅŸtirelim:

***ALIÅTIRMA-1:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2036.png)

Sorunun Ã§Ã¶zÃ¼mÃ¼nÃ¼ ÅŸu ÅŸekilde gerÃ§ekleÅŸtirebiliriz:

```sql
/*
	tsql'de iki sayÄ±nÄ±n toplamÄ±nÄ± Ã§Ä±karÄ±mÄ±nÄ± Ã§arpÄ±mÄ±nÄ± ve bÃ¶lÃ¼mÃ¼nÃ¼ yapÄ±nÄ±z.
*/

-- Ä°ki deÄŸiÅŸkeni tanÄ±mlayalÄ±m ve deÄŸerlerini verelim:

-- birinci sayÄ±:
DECLARE @SAYI1 AS INT
SET @SAYI1 = 100

-- ikinci sayÄ±
DECLARE @SAYI2 AS INT
SET @SAYI2 = 500

-- MATEMATIKSEL Ä°ÅLEMLER
DECLARE @TOPLAMA AS INT
SET @TOPLAMA = @SAYI1 + @SAYI2

DECLARE @CÄ°KARMA AS INT
SET @CÄ°KARMA = @SAYI1 - @SAYI2

DECLARE @CARPMA AS INT
SET @CARPMA = @SAYI1 * @SAYI2

DECLARE @BOLME AS FLOAT -- kÃ¼sÃ¼ratlÄ± iÃ§in gereklidir ancak tek baÅŸÄ±na yeterli deÄŸildir.
-- sayÄ±lardan biri float olmak zorundadÄ±r aksi halde en yakÄ±n tam sayÄ±ya yuvarlama iÅŸlemi gerÃ§ekleÅŸtirilir
SET @BOLME = CONVERT(FLOAT,@SAYI1) / @SAYI2 

-- Ä°ÅŸlemleri gÃ¶sterme
SELECT 
	@SAYI1 AS 'BÄ°RÄ°NCÄ°_SAYI', -- alliance deÄŸerleri Ã§Ä±ktÄ±nÄ±n kolon isimlerini verir.
	@SAYI2 AS 'Ä°KÄ°NCÄ°_SAYI',
	@TOPLAMA AS 'TOPLAM_Ä°ÅLEMÄ°',
	@CÄ°KARMA AS 'Ã‡IKARMA_Ä°ÅLEMÄ°',
	@CARPMA AS 'Ã‡ARPMA_Ä°ÅLEMÄ°',
	@BOLME AS 'BOLME_Ä°ÅLEMÄ°'
```

Bu ÅŸekilde sorunu Ã§Ã¶zmÃ¼ÅŸ oluruz.

***ALIÅTIRMA-2:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2037.png)

Bu soruyu ÅŸu ÅŸekilde Ã§Ã¶zebiliriz:

```sql
SELECT * FROM LAB02

-- date deÄŸiÅŸkeni verilerini teker teker alalÄ±m:

-- gÃ¼n deÄŸiÅŸkeni
DECLARE @GUN AS INT
SET @GUN = 18

-- ay deÄŸiÅŸkeni
DECLARE @AY AS INT
SET @AY = 10

-- yÄ±l deÄŸiÅŸkeni
DECLARE @YIL AS INT
SET @YIL = 1958

-- DATE TÃœRÃœNDEKÄ° DEÄÄ°ÅKENE BUNLARI ATAYALIM
DECLARE @TARIH AS DATE
SET @TARIH = DATEFROMPARTS(@YIL,@AY,@GUN) -- tarihleri bu ÅŸekilde bir araya getirebilirsin

-- tablo iÃ§erisinde sorgumuzu yapabiliriz.

SELECT * FROM LAB02 WHERE BIRTHDATE = @TARIH
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-3:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2038.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB03_CUSTOMERS

SELECT * FROM LAB03_ITEMS

DECLARE @CUSTOMERID AS INT
DECLARE @ITEMID AS INT
DECLARE @UNITPRICE AS FLOAT
SELECT TOP 1 @CUSTOMERID = ID FROM LAB03_CUSTOMERS ORDER BY NEWID()
SELECT TOP 1 @ITEMID = ID, @UNITPRICE = UNITPRICE FROM LAB03_ITEMS ORDER BY NEWID()
--SELECT @CUSTOMERID,@ITEMID, @UNITPRICE

-- RASTGELE TARÄ°H SAAT OLUÅTURMA
DECLARE @DATE AS DATETIME
DECLARE @RAND AS INT
DECLARE @AMOUNT AS INT
DECLARE @LINETOTAL AS FLOAT
SET @RAND = RAND()*365 -- gÃ¼n belirleme
SET @DATE = DATEADD(DAY, @RAND, '2021-01-01')
SET @DATE = DATEADD(HOUR,8, @DATE) -- maÄŸazanÄ±n aÃ§Ä±lÄ±ÅŸÄ± 8'de
SET @RAND = RAND()*12*60*60 -- saate dakika ekleme iÅŸlemi
SET @DATE = DATEADD(SECOND, @RAND, @DATE)
SET @AMOUNT = 1+(RAND()*19)
SET @LINETOTAL = @AMOUNT*@UNITPRICE

INSERT INTO LAB03_SALES (CUSTOMERID, DATE_, AMOUNT, UNITPRICE, LINETOTAL)
VALUES (@CUSTOMERID, @DATE, @AMOUNT, @UNITPRICE, @LINETOTAL)

SELECT * FROM LAB03_SALES
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-4:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2039.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
DECLARE @CUSTOMERID AS INT
SELECT TOP 1 @CUSTOMERID = ID FROM LAB04_CUSTOMERS
WHERE ID NOT IN (SELECT CUSTOMERID FROM RAFFLE) -- aynÄ± deÄŸerler gelirse alma
ORDER BY NEWID() -- tablo iÃ§erisinde tanÄ±mlÄ± olan idlerden seÃ§

DECLARE @CUSTOMERNAME AS VARCHAR(100)
DECLARE @TOTALSALE AS FLOAT
DECLARE @GIFTPERCENT AS FLOAT = 50
DECLARE @GIFTTOTAL AS FLOAT

SELECT 
@CUSTOMERNAME = C.CUSTOMERNAME, @TOTALSALE = SUM(TOTALPRICE), @GIFTTOTAL = SUM(TOTALPRICE)*@GIFTPERCENT/100 -- indirim
FROM LAB04_SALES S
JOIN LAB04_CUSTOMERS C ON C.ID = S.CUSTOMERID
WHERE CUSTOMERID= @CUSTOMERID 
GROUP BY C.ID, C.CUSTOMERNAME

-- yeni tablo iÃ§erisine deÄŸerleri atayalÄ±m:
--CREATE TABLE RAFFLE(ID INT IDENTITY(1,1), CUSTOMERID INT, CUSTOMERNAME VARCHAR(100), TOTALSALE FLOAT, GIFTPERCENT FLOAT, GIFTTOTAL FLOAT)

SELECT * FROM RAFFLE

INSERT INTO RAFFLE (CUSTOMERID, CUSTOMERNAME, TOTALSALE, GIFTPERCENT, GIFTTOTAL)

VALUES(@CUSTOMERID, @CUSTOMERNAME, @TOTALSALE, @GIFTPERCENT, @GIFTTOTAL)
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-5:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2040.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
DECLARE @CITY AS VARCHAR(100)
SET @CITY = 'Ä°STANBUL,KONYA,ANKARA,Ä°ZMÄ°R,BURSA,BÄ°LECÄ°K,TOKAT,GÄ°RESUN'

-- STRING ifadeleri birbirinden ayÄ±rmak iÃ§in string split fonksiyonu kullanabiliriz.

SELECT 
CITY, SUM(AMOUNT) AS 'TOTALAMOUNT', SUM(TOTALPRICE) AS 'TOTALSALE'
FROM LAB05
WHERE 
CITY  IN (SELECT value from string_split(@CITY, ','))
GROUP BY CITY
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

Genel itibariyle deÄŸiÅŸkenler konusu bu kadardÄ±. Bir sonraki konumuz ÅŸart bloklarÄ± olacaktÄ±r.

### Åart BloklarÄ±

Neredeyse bÃ¼tÃ¼n programlama dillerine Ã¶zgÃ¼ olan bu bloklar belirli ÅŸartlar doÄŸrultusunda yapÄ±lacak programa yÃ¶n vermeyi amaÃ§lamaktadÄ±r. SQLâ€™de genel anlamda ÅŸart bloklarÄ± Ã¼Ã§ kategoride incelenir:

- `if` bu ÅŸart bloklarÄ± sadece TSQLâ€™e Ã¶zgÃ¼dÃ¼r. DiÄŸer sade bir SQL sorgusunda bu yapÄ± Ã§alÄ±ÅŸmamaktadÄ±r.
- `CASE WHEN` ÅŸart bloklarÄ± sadece TSQLâ€™e Ã¶zgÃ¼ deÄŸildir. Normal SQL cÃ¼mle iÃ§erisinde de Ã§alÄ±ÅŸabilmektedir. Birden fazla ÅŸartÄ± iÃ§erisinde barÄ±ndÄ±rabilir.
- `lif` ÅŸart bloklarÄ± `CASE WHEN` ile aynÄ±dÄ±r. Tek farkÄ± sadece iki adet ÅŸartÄ± iÃ§erisinde barÄ±ndÄ±rÄ±r.

SÄ±rasÄ±yla bu ÅŸart yapÄ±larÄ± ele alalÄ±m:

**`*if` ÅART BLOKLARI***

BÃ¼tÃ¼n programlama dillerinin iÃ§erisinde var olan ÅŸart bloklarÄ±, belirli ÅŸartlara gÃ¶re bazÄ± sorgularÄ± veya sorgu bloklarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lan bir TSQL niteliÄŸidir.

Ã–rnek sorgularÄ± inceleyelim:

```sql
/*
	 IF - ÅART BLOKLARI 
*/

DECLARE @SAYI AS INT
SET @SAYI = 20

IF @SAYI >= 0
	SELECT 'SEÃ‡Ä°LEN SAYI POZÄ°TÄ°F' -- ÅŸart saÄŸlandÄ±ÄŸÄ± iÃ§in kod Ã§alÄ±ÅŸtÄ±

-- peki saÄŸlanmasaydÄ± ?
DECLARE @SAYI1 AS INT
SET @SAYI1 = -20

IF @SAYI1 >= 0
	SELECT 'SEÃ‡Ä°LEN SAYI POZÄ°TÄ°F' -- Commands completed successfully. (ÅŸart saÄŸlanmadÄ±)

-- if bloklarÄ± sadece kendisinden sonra gelen ÅŸart bloÄŸunu Ã§alÄ±ÅŸtÄ±rÄ±r. Ã¶rnek:

DECLARE @SAYI2 AS INT
SET @SAYI2 = -20

IF @SAYI2 >= 0
	SELECT 'SEÃ‡Ä°LEN SAYI POZÄ°TÄ°F' 
	SELECT 'BU KOD SATIRI DA IFDEN HEMEN SONRA GELMEDÄ°ÄÄ° Ä°Ã‡Ä°N ÅART SAÄLANSA DA SAÄLANMASA DA Ã‡ALIÅIR!!'

-- yani if ÅŸart bloklarÄ±nda sadece tek bir satÄ±r iÃ§erisinde Ã§alÄ±ÅŸmaktadÄ±r.
-- bu durumu egale etmek iÃ§in yani ÅŸart bloklarÄ±ndan sonra gelecek tÃ¼m ifadeleri if ÅŸart bloÄŸuna baÄŸlamak iÃ§in
-- begin end komutlarÄ± kullanÄ±lÄ±r. Ã–rneÄŸin:

DECLARE @SAYI3 AS INT
SET @SAYI3 = -20

IF @SAYI3 >= 0
BEGIN
	SELECT 'SEÃ‡Ä°LEN SAYI POZÄ°TÄ°F' 
	SELECT 'BU KOD SATIRI DA IF ÅARTINA BAÄLI KALDIÄI Ä°Ã‡Ä°N Ã‡ALIÅMAZ'
END -- Commands completed successfully.

-- yani begin-end ifadesi programlama dillerine Ã¶zgÃ¼ sÃ¼slÃ¼ parantez ifadesidir.

-- peki if ÅŸartÄ±na uymayan yapÄ±yÄ± baÅŸka bir ÅŸart ifadesinde Ã§alÄ±ÅŸtÄ±rabilir miyim 
-- evet iki yÃ¶ntemi vardÄ±r biri if-if diye yapÄ±lar kurmaktÄ±r. DiÄŸeri ise if-else yapÄ±sÄ± kurmaktÄ±r.
-- if else yapÄ±sÄ±nÄ± inceleyelim:

DECLARE @SAYI4 AS INT
SET @SAYI4 = -20

IF @SAYI4 >= 0
	SELECT 'SEÃ‡Ä°LEN SAYI POZÄ°TÄ°F'
ELSE
	SELECT 'SEÃ‡Ä°LEN SAYI NEGATÄ°F' -- bu sorgu Ã§alÄ±ÅŸÄ±r eÄŸer sayÄ± pozitif olsaydÄ± Ä±f ÅŸartÄ± Ã§alÄ±ÅŸÄ±rdÄ±.

-- else iÃ§erisinde de begin-end yapÄ±sÄ± kurulabilir:
DECLARE @SAYI5 AS INT
SET @SAYI5 = -20

IF @SAYI5 >= 0
BEGIN
	SELECT 'SEÃ‡Ä°LEN SAYI POZÄ°TÄ°F'
	SELECT 'SEÃ‡Ä°LEN SAYI SIFIRDAN BÃœYÃœK' 
END
ELSE
BEGIN
	SELECT 'SEÃ‡Ä°LEN SAYI NEGATÄ°F'
	SELECT 'SEÃ‡Ä°LEN SAYI SIFIRDAN KÃœÃ‡ÃœK' -- iki sorguda Ã§alÄ±ÅŸÄ±r.
END

-- peki sayÄ± sÄ±fÄ±r olarak verilirse ve sÄ±fÄ±rÄ± yakalamamÄ±z gerekirse nasÄ±l bir yapÄ± kurarÄ±z 
-- else iÃ§erisinde if yapÄ±sÄ±yla kurabiliriz.

DECLARE @SAYI6 AS INT
SET @SAYI6 = 0

IF @SAYI6 > 0
BEGIN
	SELECT 'SEÃ‡Ä°LEN SAYI POZÄ°TÄ°F'
	SELECT 'SEÃ‡Ä°LEN SAYI SIFIRDAN BÃœYÃœK' 
END
ELSE
BEGIN
	IF @SAYI6 = 0
		SELECT 'SEÃ‡Ä°LEN SAYI SIFIRDIR' -- sayÄ± 0 olduÄŸu iÃ§in burasÄ± Ã§alÄ±ÅŸacaktÄ±r.
	ELSE
		SELECT 'SEÃ‡Ä°LEN SAYI NEGATÄ°FTÄ°R.'
END

-- if ÅŸart bloklarÄ±yla belirli bir deÄŸiÅŸkenleri istediÄŸimiz gibi deÄŸiÅŸtirebiliriz:
-- Ã¶rneÄŸin
DECLARE @SAYI7 AS INT
SET @SAYI7 = 0
DECLARE @RESULT AS VARCHAR(100) -- dinamik olarak sonucu gÃ¶sterebilen deÄŸiÅŸken

IF @SAYI7 > 0
BEGIN
	SET @RESULT = 'SEÃ‡Ä°LEN SAYI POZÄ°TÄ°F'
	SET @RESULT =  'SEÃ‡Ä°LEN SAYI SIFIRDAN BÃœYÃœK' 
END
ELSE
BEGIN
	IF @SAYI7 = 0
		SET @RESULT =  'SEÃ‡Ä°LEN SAYI SIFIRDIR' -- sayÄ± 0 olduÄŸu iÃ§in burasÄ± Ã§alÄ±ÅŸacaktÄ±r.
	ELSE
		SET @RESULT =  'SEÃ‡Ä°LEN SAYI NEGATÄ°FTÄ°R.'
END

SELECT 'ÅART BLOKLARI SONUCU CEVAP:' + @RESULT
```

Bu ÅŸekilde `if` ÅŸart bloklarÄ±nÄ± incelemiÅŸ olduk.

**`*CASE WHEN` ÅART BLOKLARI***

Birden fazla ÅŸarta gÃ¶re Ã§alÄ±ÅŸtÄ±rÄ±labilen default olarak SQL iÃ§erisinde de bulunan sadece TSQLâ€™e Ã¶zgÃ¼ olmayan bir ÅŸart ifadesidir.

- `CASE WHEN` ÅŸart bloklarÄ± genel anlamda `*WHEN â€œÅARTâ€ THEN â€œDEÄERâ€`* ÅŸeklinde kurgulanÄ±r.
- Bu case yapÄ±larÄ±nÄ±n en sonunda yeni bir tablo ismi vereceÄŸi iÃ§in bir sÃ¼tun ismi olan *alliance* tanÄ±mlÄ± olmak zorundadÄ±r

Bu bilgiler Ä±ÅŸÄ±ÄŸÄ±nda aÅŸaÄŸÄ±daki iki adet sorgu yapÄ±sÄ±nÄ± inceleyelim:

```sql
SELECT * FROM CUSTOMERS

/* CASE WHEN ÅART Ä°FADELERÄ° */
-- Birden fazla ÅŸarta uygun olarak seÃ§imler yapmaya olanak saÄŸlayan bir ÅŸart ifadesi dÃ¶ngÃ¼sÃ¼dÃ¼r.
-- Genel anlamda yapÄ±: WHEN "ÅART" THEN "DEÄER" ÅŸeklinde kurgulanÄ±r.

-- cinsiyetlere gÃ¶re ÅŸart ifadelerini yazalÄ±m
SELECT 
CASE
	WHEN GENDER = 'E' THEN 'ERKEK' -- GENDER E olanlara yeni sÃ¼tun aÃ§Ä±p 'ERKEK' yazacak
	WHEN GENDER = 'K' THEN 'KADIN'-- GENDER K olanlara yeni sÃ¼tun aÃ§Ä±p 'KADIN' yazacak
END AS GENDEREXP, -- alliance tanÄ±mlanmasÄ± gereklidir.
* FROM CUSTOMERS

-- bir farklÄ± Ã¶rnek olarak mÃ¼ÅŸteri tablosundaki kiÅŸilerin yaÅŸlarÄ±nÄ± hesap edelim ve onlarÄ± genÃ§, orta yaÅŸlÄ± ve yaÅŸlÄ± olarak kategorize edelim:

SELECT 
CASE 
	WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) <= 35 THEN 'GENÃ‡' -- yaÅŸ 35'ten kÃ¼Ã§Ã¼kse 'GENÃ‡'
	WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) BETWEEN 36 AND 55  THEN 'ORTA YAÅLI' -- yaÅŸ 36 ve 55 arasÄ±nda (ikisi de dahildir.) "ORTA YAÅLI"
	WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) > 55 THEN 'YAÅLI' -- yaÅŸ 55'ten bÃ¼yÃ¼kse 'YAÅLI' olarak nitelendir.
END AS YASKATEGORI,
DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS 'AGE', -- yaÅŸÄ± hesaplattÄ±ran fonksiyon
* FROM CUSTOMERS
```

Bu ÅŸekilde yapÄ±lar kurgulanabilir.

**`*IIF` ÅART BLOKLARI***

Bu ÅŸart bloklarÄ± `case when` ifadesine Ã§ok benzerdir. Ancak sadece iki adet ÅŸarta uygun olarak yapÄ±labilir.

- Genel kurgusu: `*IIF(â€ÅARTâ€, â€œÅART UYGUNSA BURASI Ã‡ALIÅIR.â€, â€œUYGUN DEÄÄ°LSE BURASI Ã‡ALIÅIR.â€)*` ÅŸeklindedir.

Genel sorgularÄ± inceleyelim:

```sql
SELECT * FROM CUSTOMERS

/* IIF ÅART Ä°FADESÄ° */
-- case when'e benzerdir. Ancak sadece iki adet sorgu neticesini iÃ§erisinde barÄ±ndÄ±rÄ±r.
-- yapÄ± ÅŸu ÅŸekilde kurgulanÄ±r:
-- IIF("ÅART", "ÅART SAÄLANIRSA BURASI Ã‡ALIÅIR", "ÅART SAÄLANMAZSA BURASI Ã‡ALIÅIR"). ÅŸeklindedir:

-- Bir Ã¶ncekinde yapmÄ±ÅŸ olduÄŸumuz kadÄ±n erkek iÅŸaretlemesini burada da gerÃ§ekleÅŸtirelim

SELECT 
IIF(GENDER= 'E', 'ERKEK', 'KADIN') -- eÄŸer ÅŸart uyarsa 'ERKEK', uymazsa 'KADIN' yazacak.
,* FROM CUSTOMERS
```

Bu ÅŸekilde sorgularÄ±mÄ±zÄ± bitirdik. 

Åimdi Ã¼Ã§ adet alÄ±ÅŸtÄ±rma yaparak bu konularÄ± pekiÅŸtirelim:

***ALIÅTIRMA-1:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2041.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
-- DEÄÄ°ÅKENLERÄ°N TANIMLANMASI
DECLARE @PLATE AS VARCHAR(20) = ''
DECLARE @COLOR AS VARCHAR(20) = ''
DECLARE @TITLE AS VARCHAR(100) = ''
DECLARE @BRAND AS VARCHAR(20) = ''
DECLARE @LICENCEDATE1 AS DATE = ''
DECLARE @LICENCEDATE2 AS DATE = '20201231'

-- BOÅ VERÄ° KONTROLÃœ
IF @PLATE = ''
	SET @PLATE = '%'
IF @COLOR = ''
	SET @COLOR = '%'
IF @TITLE = ''
	SET @TITLE = '%'
IF @BRAND = ''
	SET @BRAND = '%'

-- License date boÅŸ olarak kalÄ±rsa null deÄŸer dÃ¶ndÃ¼rÃ¼r date tÃ¼rÃ¼nde olduÄŸu iÃ§in 
-- null veri iÃ§in ÅŸÃ¶yle bir yol izlemek gerekir: (birinci yol)
/*
IF @LICENCEDATE1 IS NULL
	SET @LICENCEDATE1 = '20180101'
IF @LICENCEDATE2 IS NULL
	SET @LICENCEDATE2 = GETDATE()
*/ -- ikinci yol ise sorgunun iÃ§erisinde 

-- Sorgunun Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±

SELECT * FROM LAB01
WHERE PLATE LIKE @PLATE
AND COLOR LIKE @COLOR
AND TITLE LIKE @TITLE
AND BRAND LIKE @BRAND
AND LICENCEDATE BETWEEN ISNULL(@LICENCEDATE1,'20180101') AND ISNULL(@LICENCEDATE2, GETDATE()) -- ikinci yol null veei kontrolÃ¼
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-2:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2042.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
SELECT * FROM LAB02

-- licence date ile year kolonundaki verileri kÄ±yasla veya farkÄ±nÄ± al ona gÃ¶re iÅŸlem yap

SELECT 
BRAND, -- ARAÃ‡ MARKASI
CASE -- YILLARA GÃ–RE CASE SORGUSU
	WHEN YEAR(LICENCEDATE) - YEAR_ = 0 THEN 'ARAÃ‡ AYNI YIL TRAFÄ°ÄE Ã‡IKMIÅTIR!'
	WHEN YEAR(LICENCEDATE) - YEAR_ = 1 THEN 'ARAÃ‡ BÄ°R SENE SONRA TRAFÄ°ÄE Ã‡IKMIÅTIR!'
	WHEN YEAR(LICENCEDATE) - YEAR_ = 2 THEN 'ARAÃ‡ Ä°KÄ° SENE SONRA TRAFÄ°ÄE Ã‡IKMIÅTIR!'
	WHEN YEAR(LICENCEDATE) - YEAR_ = 3 THEN 'ARAÃ‡ ÃœÃ‡ SENE SONRA TRAFÄ°ÄE Ã‡IKMIÅTIR!'
END AS STATUS_,
COUNT(*) AS COUNT_ -- TOPLAM
FROM LAB02
GROUP BY -- COUNT iÃ§in gerekli gruplama iÅŸlemi
BRAND, -- birinci gruplama parametresi araÃ§ markasÄ±
YEAR(LICENCEDATE) - YEAR_ -- trafiÄŸe Ã§Ä±kÄ±ÅŸ yÄ±lÄ± farkÄ±
ORDER BY 1,2
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

### DÃ¶ngÃ¼ler

Programlama dillerine Ã¶zgÃ¼ olan dÃ¶ngÃ¼ler TSQL iÃ§erisinde de yer almaktadÄ±r. Genel anlamda iki adet dÃ¶ngÃ¼ kullanÄ±lmaktadÄ±r.

- **`*GO:*`** Bir sorguyu birden fazla Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± iÃ§in kullanÄ±lan bir sorgudur. Programlama dillerine Ã¶zgÃ¼n olan for dÃ¶ngÃ¼sÃ¼ne benzerdir. Ancak for dÃ¶ngÃ¼sÃ¼ gibi bir dÃ¶ngÃ¼ TSQL iÃ§erisinde yer almaz.
- **`*WHILE:`*** Belirli bir ÅŸart saÄŸlanasÄ±ya kadar veya belirli bir iÅŸlemi tekrar tekrar gerÃ§ekleÅŸtirmek iÃ§in TSQLâ€™de sÄ±klÄ±kla kullanÄ±lan bir dÃ¶ngÃ¼ yapÄ±sÄ±dÄ±r.

**`*GO` DÃ–NGÃœSÃœ***

Bir sorguyu birden fazla Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lan bir yapÄ±ya sahiptir.

***Ã–rneÄŸin:***

```sql
/*
	GO DÃ–NGÃœSÃœ: Bir sorguyu birden fazla kez Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.
*/

SELECT * FROM DATES

INSERT INTO DATES (DATE_) VALUES (GETDATE())
GO 5 -- beÅŸ kere insert ekleme iÅŸlemini gerÃ§ekleÅŸtirir.

INSERT INTO DATES (DATE_) VALUES (GETDATE())
GO 100 -- 100 kere insert yani ekleme iÅŸlemini gerÃ§ekleÅŸtirir.
```

Bu ÅŸekilde Ã§alÄ±ÅŸtÄ±rÄ±lmaktadÄ±r.

**`*WHILE` DÃ–NGÃœSÃœ***

TSQLâ€™de en fazla kullanÄ±lan bu dÃ¶ngÃ¼ yapÄ±sÄ±nda, belirli bir ÅŸart saÄŸlanasÄ±ya kadar bir sorgu yapÄ±sÄ±nÄ± veya sorgu bloklarÄ±nÄ± tekrar tekrar Ã§alÄ±ÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r.

- TSQLâ€™de en fazla kullanÄ±lan dÃ¶ngÃ¼dÃ¼r.
- KullanÄ±mÄ± basittir. Ama kullanÄ±rken oldukÃ§a dikkatli olmak gerekir. SayÄ±sal olarak bir iÅŸlem gerÃ§ekleÅŸtirilecekse en ufak deÄŸiÅŸken arttÄ±rÄ±mÄ± ifadesi eksik kalÄ±rsa sorgu sonsuz dÃ¶ngÃ¼ye girer.
- TSQLâ€™de bekleme komutlarÄ±ndan bir tanesi de `WAITFOR DELAY â€˜00:00:01â€™` ifadesidir. Bu ifadede sÄ±rasÄ±yla (saat, dakika, saniye) ÅŸeklinde bekletmeler sÃ¶z konusu olabilmektedir.

Bu dÃ¶ngÃ¼yle ilgili sorgu yapÄ±sÄ± ÅŸu ÅŸekildedir:

```sql
/*
	WHILE KOMUTU: Belirli bir ÅŸart saÄŸlandÄ±ÄŸÄ± sÃ¼rece tekrar tekrar Ã§alÄ±ÅŸtÄ±rÄ±lan bir dÃ¶ngÃ¼ yapÄ±sÄ±dÄ±r.
*/

SELECT * FROM DATES

DECLARE @I INT = 0

WHILE @I < 10
BEGIN
	INSERT INTO DATES (DATE_) VALUES (GETDATE())
	SET @I = @I+1 -- eÄŸer ki bu yapÄ± yazÄ±lmazsa sorgu sonsuz dÃ¶ngÃ¼ye girer.
END

DECLARE @I2 INT = 0

WHILE @I2 < 10
BEGIN
	INSERT INTO DATES (DATE_) VALUES (GETDATE())
	WAITFOR DELAY '00:00:01' -- sorguda bekleme sÃ¼resini verir (saat-dk-sn) ÅŸeklinde Ã§alÄ±ÅŸmaktadÄ±r.
	SET @I2 = @I2 + 1 -- eÄŸer ki bu yapÄ± yazÄ±lmazsa sorgu sonsuz dÃ¶ngÃ¼ye girer.
END
```

Bu ÅŸekilde `WHILE` dÃ¶ngÃ¼sÃ¼ kullanÄ±labilmektedir.

Åimdi birkaÃ§ alÄ±ÅŸtÄ±rma yaparak dÃ¶ngÃ¼ler konusunu pekiÅŸtirelim.

***ALIÅTIRMA-1:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2043.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir

```sql
SELECT * FROM LAB01

INSERT INTO LAB01 (DEVICENAME, CURRENTVALUE) VALUES ('TERMOMETER-0001', 18.6) -- istenilen yapÄ± bu ÅŸekilde

DECLARE @I INT = 2 -- bir sayÄ±sal deÄŸiÅŸkene gÃ¶re dÃ¶ngÃ¼yÃ¼ Ã§alÄ±ÅŸtÄ±ralÄ±m
WHILE @I <= 100 -- @I deÄŸiÅŸkeni 100 olasÄ±ya kadar Ã§alÄ±ÅŸ
BEGIN
	DECLARE @DEVICENAME VARCHAR(100) -- termometre ismi deÄŸiÅŸkeni
	SET @DEVICENAME = 'TERMOMETER-'+REPLICATE(0,4-LEN(@I))+CONVERT(VARCHAR, @I) -- TERMOMETER-0001
	DECLARE @CURRENTVALUE FLOAT -- derecenin deÄŸiÅŸkeni
	SET @CURRENTVALUE = ROUND(18+RAND()*5,2) -- 18 ile 23 derece arasÄ±nda deÄŸiÅŸkenlik gÃ¶sterir

	--SELECT @DEVICENAME, @CURRENTVALUE
	INSERT INTO LAB01 (DEVICENAME, CURRENTVALUE) VALUES (@DEVICENAME, @CURRENTVALUE) -- insert sorgusu
	SET @I = @I + 1 -- deÄŸiÅŸkeni bir arttÄ±rarak sorguyu Ã§alÄ±ÅŸtÄ±r.
END
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-2:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2044.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql

DECLARE @I AS INT = 1
WHILE @I <=100
BEGIN
DECLARE @DEVICEID AS INT = 1
DECLARE @DATE AS DATETIME = '2022-08-27 7:30:00'
	WHILE @DATE <= '2022-08-27 17:30:00'
	BEGIN
		DECLARE @CURRENTVALUE AS FLOAT
		SELECT @CURRENTVALUE = CURRENTVALUE FROM LAB02_DEVICES WHERE ID = @DEVICEID
		IF @CURRENTVALUE = 0
		BEGIN
			SET @CURRENTVALUE = 18
		END
		DECLARE @NEWVALUE AS FLOAT
		SET @NEWVALUE = ROUND(@CURRENTVALUE-0.5+RAND(),2)
		UPDATE LAB02_DEVICES SET CURRENTVALUE = @NEWVALUE WHERE ID = @DEVICEID
		INSERT INTO LAB02_LOG (DEVICEID, DATE_, VALUE_) VALUES (@DEVICEID,@DATE,@NEWVALUE)
		SET @DATE = DATEADD(SECOND,30,@DATE)
	END
SET @I = @I+1
END

SELECT * FROM LAB02_DEVICES WHERE ID = 1
SELECT * FROM LAB02_LOG
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-3:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2045.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
DECLARE @I AS INT = 0

WHILE @I < 1000
BEGIN
	DECLARE @PLATE AS VARCHAR(20)
	DECLARE @CARID AS INT = 1
	DECLARE @CITYID AS INT = 34
	DECLARE @LETTER1 AS VARCHAR(1) = 'A'
	DECLARE @LETTER2 AS VARCHAR(1) = 'B'
	DECLARE @NUMBER AS INT = 149
	DECLARE @RANDID AS INT

	-- DEÄERLERÄ° RASTGELE VERELÄ°M
	SET @CARID = 1 + (RAND()*6537) -- +1 dememizin sebebi 0'Ä± yakalamaktan kurtulmak
	SET @CITYID = 1 + (RAND()*80)
	SET @RANDID = 1 + (RAND()*21)
	SELECT @LETTER1 = LETTER FROM LAB03_LETTERS WHERE ID = @RANDID
	SET @RANDID = 1 + (RAND()*21)
	SELECT @LETTER2 = LETTER FROM LAB03_LETTERS WHERE ID = @RANDID
	SET @NUMBER = 1 + (RAND()*9999)

	SET @PLATE = REPLICATE('0',2-LEN(@CITYID)) + CONVERT(VARCHAR, @CITYID) -- plaka dÃ¼zenlenmesi Ã¶rn: 1 deÄŸil 01 yazmasÄ±
	SET @PLATE = @PLATE+@LETTER1+@LETTER2
	SET @PLATE = @PLATE + REPLICATE('0', 4-LEN(@NUMBER)) + CONVERT(VARCHAR,@NUMBER)
	INSERT INTO LAB03_PLATES(PLATE, CARID) VALUES (@PLATE, @CARID)
SET @I = @I+1
END
SELECT P.PLATE, C.* FROM LAB03_PLATES P
JOIN LAB03_CARMODELS C ON C.ID = P.CARID
```

Sorun bu ÅŸekilde Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-4:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2046.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
DECLARE @I AS INT = 0

WHILE @I < 100000
BEGIN
	DECLARE @PLATE AS VARCHAR(20)
	DECLARE @PTSPOINTID AS INT = 1
	DECLARE @DATE AS DATETIME ='2022-08-27 00:00:00'
	DECLARE @RANDID AS INT
	DECLARE @RANDTIME AS INT
	SET @RANDID = 1 + RAND()*999999
	SELECT @PLATE = PLATE FROM LAB04_PLATES WHERE ID = @RANDID

	SET @RANDTIME = RAND()*24*60*60 -- 24 saat 60 dakika 60 saniye (rastgele saniye Ã¼retme)
	SET @DATE = DATEADD(SECOND, @RANDTIME, @DATE) -- date tÃ¼rÃ¼ne saniye ekleme iÅŸlemi
	SET @RANDTIME = RAND()*1000
	SET @DATE = DATEADD(MS, @RANDTIME, @DATE) -- milisaniye tÃ¼rÃ¼nÃ¼ de rastgele ekledim

	-- insert etme iÅŸlemi
	INSERT INTO LAB04_PTSLOG (PTSPOINTID, PLATE, DATE_)
	VALUES (@PTSPOINTID, @PLATE, @DATE)

SET @I = @I + 1
END

-- veriyi listeleyelim
SELECT 
P.PTSNAME, L.DATE_, L.PLATE, CM.TITLE
FROM LAB04_PTSLOG L
JOIN LAB04_PTSPOINT P ON P.ID = L.PTSPOINTID
JOIN LAB04_PLATES PL ON PL.PLATE = L.PLATE
JOIN LAB04_CARMODELS CM ON CM.ID = PL.CARID
ORDER BY L.DATE_
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

## TSQL VERÄ° TABANI NESNELERÄ°

Bir veya birden fazla iÅŸlemleri otomatik olarak gerÃ§ekleÅŸtirmeye Ã§alÄ±ÅŸan veya veri tabanÄ±nÄ±n performansÄ±nÄ± arttÄ±rmaya yÃ¶nelik tÃ¼m fonksiyonlara veri tabanÄ± nesneleri adÄ± verilir.

Bu nesneler sÄ±rasÄ±yla

- View: KarmaÅŸÄ±k SQL sorgularÄ±nÄ±n tek bir sanal tablo haline getiren bir yapÄ±dÄ±r. Bu yapÄ± sayesinde veri tabanÄ±nda farklÄ± tablolar iÃ§erisinde bulunan verileri tek bir tablo halinde gÃ¶stermemize olanak saÄŸlanmaktadÄ±r. Bu fonksiyonda sadece tek bir `SELECT` sorgusu Ã§alÄ±ÅŸmaktadÄ±r.
- User Defined Function: SQL iÃ§erisinde gÃ¶mÃ¼lÃ¼ fonksiyonlar (`DATEDIFF()`) gibi fonksiyonlar varken aynÄ± zamanda kullanÄ±cÄ± tarafÄ±ndan oluÅŸturulabilecek fonksiyonlarda vardÄ±r. Bu tanÄ±mlanabilecek fonksiyonlarÄ±n her birine User Defined Function adÄ± verilir.
- Stored Procedure: KarmaÅŸÄ±k SQL sorgularÄ±nÄ± tek bir sanal tablo halinde yazmaya okumaya, manipÃ¼le etmeye olanak saÄŸlayan Viewâ€™Ä±n bir nevi CRUD iÅŸlemlerini gerÃ§ekleÅŸtiren bir fonksiyon olarak ele alÄ±nabilmektedir.
- Trigger: Eventlere benzer yapÄ±da olan triggerlar, belirli bir ÅŸarta gÃ¶re dÃ¼zenli olarak Ã§alÄ±ÅŸan bir takÄ±m veri tabanÄ± fonksiyonlarÄ±dÄ±r.
- Index: Veri tabanÄ± performanslarÄ±na yÃ¶nelik olarak Ã§alÄ±ÅŸan indexler veri tabanÄ±nÄ±n ÅŸiÅŸmesi gibi bazÄ± problemlerin yaÅŸanmasÄ±nÄ±n Ã¶nÃ¼ne geÃ§mesi amacÄ±yla kullanÄ±lan bir takÄ±m fonksiyonlardÄ±r.

Åimdi sÄ±rasÄ±yla hepsini ele alalÄ±m

### View

T-SQL'de (Transact-SQL) view, bir veya daha fazla tablodan veri Ã§ekmek iÃ§in kullanÄ±lan sanal bir tablo olarak tanÄ±mlanabilir. View, aslÄ±nda bir SQL sorgusudur ve bir tablo gibi davranÄ±r. View'lar, karmaÅŸÄ±k sorgularÄ± daha basit hale getirmek, veri gÃ¼venliÄŸini artÄ±rmak ve tekrarlanan sorgularÄ± yeniden kullanmak amacÄ±yla kullanÄ±lÄ±r. 

Ya da bir ya da birden fazla tablodan select sorgusu Ã§ekerek oluÅŸan verisetinin bir tablo gibi kullanÄ±lmasÄ±dÄ±r.

SQL sorgusunda dÃ¶nen alanlar filtreleme, sÄ±ralama, gruplama, aggregation gibi iÅŸlemler iÃ§in aynÄ± bir tablo alanÄ± gibi kullanÄ±labilir.

Viewâ€™lar diskte yer kaplamazlar. Yani verinin kopyasÄ± oluÅŸturulmaz.

TÃ¼m veriyi Ã§ekmek yerine ilgili veriyi Ã§ekerek performansÄ± arttÄ±rÄ±r.

Birden fazla join ile birleÅŸen tablolarÄ±n oluÅŸturduÄŸu karmaÅŸÄ±k sorgularÄ± bir tablo gibi basitleÅŸtirir.

Veri tabanlarÄ±nda genelde Ä°ngilizce olarak tutulan alanlarÄ±n raporlama tarafÄ±nda rahat kullanÄ±lmasÄ± iÃ§in TÃ¼rkÃ§e gibi daha anlaÅŸÄ±labilir halde kullanÄ±lmasÄ±nÄ± saÄŸlar.

Viewâ€™lar raporlama amaÃ§lÄ± ya da bir uygulama iÃ§inde kullanÄ±ldÄ±klarÄ±nda herhangi bir deÄŸiÅŸiklikte view Ã¼zerinde bu deÄŸiÅŸikliÄŸi yapmak Ã§ok daha pratiktir.

Genel olarak joinler kullanarak farklÄ± farklÄ± tablolardaki verileri ÅŸu ÅŸekilde bir araya getirebiliriz.

```sql

/*
SELECT * FROM USERS
SELECT * FROM ADDRESS
SELECT * FROM ORDERS
SELECT * FROM ORDERDETAILS

SELECT * FROM INVOICES
SELECT * FROM INVOICEDETAILS

*/

SELECT 
O.ID ORDERID, O.DATE_, U.ID USERID, U.USERNAME_, U.NAMESURNAME, U.GENDER, U.EMAIL, U.TELNR1,
A.ADDRESSTEXT, A.POSTALCODE, C.CITY, T.TOWN,
I.ITEMCODE, I.ITEMNAME, I.BRAND, I.CATEGORY1,
OD.AMOUNT, OD.UNITPRICE, OD.LINETOTAL, OD.ITEMID
FROM ORDERS O
JOIN ORDERDETAILS OD ON OD.ORDERID = O.ID
JOIN ITEMS I ON I.ID = OD.ITEMID 
JOIN USERS U ON U.ID = O.USERID
JOIN ADDRESS A ON A.ID = O.ADDRESSID
JOIN CITIES C ON C.ID = A.CITYID
JOIN TOWNS T ON T.ID = A.TOWNID

WHERE T.TOWN = 'MERAM'
```

Bu ÅŸekilde joinler kullanarak farklÄ± veri tablolarÄ± arasÄ±nda gÃ¶sterimler saÄŸlayabiliriz.

View kullanarak ise bunlarÄ± bir gerÃ§ekte var olmayan tablo ÅŸeklinde de tutabiliriz.

Veri tabanÄ± tablolarÄ± iÃ§erisinde yapmÄ±ÅŸ olduÄŸumuz `CREATE, ALTER, DROP` gibi sÄ±rasÄ±yla tablo oluÅŸturma, tablo gÃ¼ncelleme veya tablo silme gibi iÅŸlemlerin her birini view aracÄ±lÄ±ÄŸÄ± ile gerÃ§ekleÅŸtirebiliriz.

- Bir view oluÅŸturulmak istenildiÄŸinde create kullanÄ±larak oluÅŸturulur.

Ã–rnek kodlara bakalÄ±m:

```sql
CREATE VIEW VWORDER -- VÄ°EW NESNESÄ° OLUÅTUR
AS -- BU SORGUDAN SONRASI VÄ°EW NESNESÄ° OLUR.
SELECT 
O.ID ORDERID, O.DATE_, 
DATENAME(MONTH, O.DATE_) 'MONTH_',
U.ID USERID, U.USERNAME_, U.NAMESURNAME, U.GENDER, U.EMAIL, U.TELNR1,
A.ADDRESSTEXT, A.POSTALCODE, C.CITY, T.TOWN,
I.ITEMCODE, I.ITEMNAME, I.BRAND, I.CATEGORY1,
OD.AMOUNT, OD.UNITPRICE, OD.LINETOTAL, OD.ITEMID
FROM ORDERS O
JOIN ORDERDETAILS OD ON OD.ORDERID = O.ID
JOIN ITEMS I ON I.ID = OD.ITEMID 
JOIN USERS U ON U.ID = O.USERID
JOIN ADDRESS A ON A.ID = O.ADDRESSID
JOIN CITIES C ON C.ID = A.CITYID
JOIN TOWNS T ON T.ID = A.TOWNID
```

Bu ÅŸekilde bir sorguyu view nesnesine dÃ¶nÃ¼ÅŸtÃ¼rebiliriz.

ViewlarÄ±n gerÃ§ekte var olmadÄ±ÄŸÄ±nÄ± sanalda bir bellek tutmadÄ±ÄŸÄ±nÄ± sÃ¶ylemiÅŸtik ve bunlarÄ±n Ã¼zerinde gÃ¼ncellemeler yapÄ±larak bir tablo Ã¼zerinde yapÄ±labilecek deÄŸiÅŸiklikleri yapabileceÄŸimizden bahsetmiÅŸtik. Buna gÃ¶re tablo Ã¼zerinde bir gÃ¼ncelleme yapÄ±lmasÄ±ndan bahsedebiliriz.

Ã–rnek kodlar:

```sql
-- TABLOYU GÃœNCELLEMEK Ä°Ã‡Ä°N ALTER KULLANIRSIN

ALTER VIEW VWORDER -- view gÃ¼ncelleme
AS
SELECT 
O.ID ORDERID, O.DATE_, 
DATENAME(MONTH, O.DATE_) 'MONTH_',
DATENAME(DW,O.DATE_)AS 'DAYOFWEEK', -- haftanÄ±n gÃ¼nleri
U.ID USERID, U.USERNAME_, U.NAMESURNAME, U.GENDER, U.EMAIL, U.TELNR1,
A.ADDRESSTEXT, A.POSTALCODE, C.CITY, T.TOWN,
I.ITEMCODE, I.ITEMNAME, I.BRAND, I.CATEGORY1,
OD.AMOUNT, OD.UNITPRICE, OD.LINETOTAL, OD.ITEMID
FROM ORDERS O
JOIN ORDERDETAILS OD ON OD.ORDERID = O.ID
JOIN ITEMS I ON I.ID = OD.ITEMID 
JOIN USERS U ON U.ID = O.USERID
JOIN ADDRESS A ON A.ID = O.ADDRESSID
JOIN CITIES C ON C.ID = A.CITYID
JOIN TOWNS T ON T.ID = A.TOWNID

```

- Burada view Ã¼zerinde bir gÃ¼ncelleme yapacaÄŸÄ±mÄ±z iÃ§in `ALTER VIEW` komutunu kullandÄ±k.
- Bu tablo Ã¼zerinde Ã¶nceki sorguya nazaran haftanÄ±n da gÃ¼nlerinin gelmesini istediÄŸimiz iÃ§in `DATENAME(DW,O.DATE_)AS 'DAYOFWEEK'` yapÄ±sÄ±nÄ± kullanarak haftanÄ±n gÃ¼nlerini de bir sÃ¼tun halinde bu tablonun iÃ§erisine entegre ettik.

Bir baÅŸka Ã¶rneÄŸe bakalÄ±m:

```sql
ALTER VIEW VWORDER
AS
SELECT 
O.ID SIPARIS_NO,O.DATE_,
YEAR(O.DATE_) YIL,
DATENAME(MONTH, O.DATE_) 'AY',
DATENAME(DW,O.DATE_)AS 'HAFTANIN_GÃœNÃœ',
U.ID KULLANICI_ID, U.USERNAME_ KULLANICI_ADI, U.NAMESURNAME KULLANICI_ADSOYAD, U.GENDER KULLANICI_CÄ°NSÄ°YET, U.EMAIL KULLANICIEMAIL, U.TELNR1 KULLANICI_TELEFON_NO,
A.ADDRESSTEXT KULLANICI_ADRES, A.POSTALCODE KULLANICI_POSTAKODU, C.CITY KULLANICI_SEHÄ°R, T.TOWN KULLANICI_Ä°LCE,
I.ITEMCODE URUN_KODU, I.ITEMNAME URUN_ISMI, I.BRAND URUN_TURU, I.CATEGORY1 URUN_KATEGORÄ°,
OD.AMOUNT URUN_SATISI, OD.UNITPRICE URUN_BIRIM_FIYAT, OD.LINETOTAL KALEM_SATIS_SAYISI, OD.ITEMID URUN_ID
FROM ORDERS O
JOIN ORDERDETAILS OD ON OD.ORDERID = O.ID
JOIN ITEMS I ON I.ID = OD.ITEMID 
JOIN USERS U ON U.ID = O.USERID
JOIN ADDRESS A ON A.ID = O.ADDRESSID
JOIN CITIES C ON C.ID = A.CITYID
JOIN TOWNS T ON T.ID = A.TOWNID 
```

Burada ise sÃ¼tun isimleri veri tabanÄ±nÄ±n default dili olan Ä°ngilizceâ€™den Ã§evirerek TÃ¼rkÃ§e haline getirdik. Bu ÅŸekilde sÃ¼tun isimleri daha anlamlÄ± hale gelmiÅŸ oldu.

AyrÄ±ca bu tip viewâ€™larÄ±n her birini excel Ã¼zerinden veri tabanÄ± baÄŸlantÄ±sÄ± kullanarak verileri oraya Ã§ekerek istediÄŸimiz gibi kullanÄ±ma sunabiliriz.

<aside>
ğŸ’¡ viewâ€™lar her ne kadar veri tabanlarÄ±nda bellek tutmasalar da belirli bir sÃ¼re sonra sÃ¼rekli view oluÅŸturmak iyi bir adÄ±m deÄŸildir. Bunun iÃ§in farklÄ± yÃ¶ntemler izlenerek viewlar egale edilebilmektedir. Bunun iÃ§in ise dinamik viewlar oluÅŸturulabilmektedir.

</aside>

***Dinamik View:*** Bir SQL sorgusunun view gibi kullanÄ±ldÄ±ÄŸÄ± ancak gerÃ§ek bir view oluÅŸturulmadÄ±ÄŸÄ± yapÄ±lara denilmektedir.

Dinamik viewlar ise aslÄ±nda bir subquery mantÄ±ÄŸÄ±yla Ã§alÄ±ÅŸmaktadÄ±r.

Ã–rnek kodlar:

```sql
-- dinamik view oluÅŸturma

SELECT DV.AY, SUM(DV.KALEM_SATIS_SAYISI) AS 'KALEM SATIÅ SAYISI TOPLAM' FROM ( -- dinamik view baÅŸlangÄ±Ã§Ä±
	SELECT 
	O.ID SIPARIS_NO,O.DATE_,
	YEAR(O.DATE_) YIL,
	DATENAME(MONTH, O.DATE_) 'AY',
	DATENAME(DW,O.DATE_)AS 'HAFTANIN_GÃœNÃœ',
	U.ID KULLANICI_ID, U.USERNAME_ KULLANICI_ADI, U.NAMESURNAME KULLANICI_ADSOYAD, U.GENDER KULLANICI_CÄ°NSÄ°YET, U.EMAIL KULLANICIEMAIL, U.TELNR1 KULLANICI_TELEFON_NO,
	A.ADDRESSTEXT KULLANICI_ADRES, A.POSTALCODE KULLANICI_POSTAKODU, C.CITY KULLANICI_SEHÄ°R, T.TOWN KULLANICI_Ä°LCE,
	I.ITEMCODE URUN_KODU, I.ITEMNAME URUN_ISMI, I.BRAND URUN_TURU, I.CATEGORY1 URUN_KATEGORÄ°,
	OD.AMOUNT URUN_SATISI, OD.UNITPRICE URUN_BIRIM_FIYAT, OD.LINETOTAL KALEM_SATIS_SAYISI, OD.ITEMID URUN_ID
	FROM ORDERS O
	JOIN ORDERDETAILS OD ON OD.ORDERID = O.ID
	JOIN ITEMS I ON I.ID = OD.ITEMID 
	JOIN USERS U ON U.ID = O.USERID
	JOIN ADDRESS A ON A.ID = O.ADDRESSID
	JOIN CITIES C ON C.ID = A.CITYID
	JOIN TOWNS T ON T.ID = A.TOWNID 
) DV -- dinamik view bitiÅŸi

GROUP BY AY 
```

Bu ÅŸekilde bir dinamik viewâ€™da oluÅŸturulabilir.

Genel anlamda viewlar bu kadardÄ±. BirkaÃ§ Ã¶rnekle Ã¶ÄŸrendiklerimizi pekiÅŸtirelim:

***ALIÅTIRMA-1:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2047.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir.

```sql
-- veri tabanÄ± iÃ§erisindeki tablolarÄ± gÃ¶rÃ¼ntÃ¼leyelim:
SELECT * FROM ADDRESS
SELECT * FROM CITIES
SELECT * FROM COUNTRIES
SELECT * FROM DISTRICTS
SELECT * FROM INVOICES
SELECT * FROM INVOICEDETAILS
SELECT * FROM ITEMS
SELECT * FROM ORDERDETAILS
SELECT * FROM ORDERS
SELECT * FROM PAYMENTS
SELECT * FROM TOWNS
SELECT * FROM USERS

-- Ã¶ncelikle sql sorgusunu bir yazalÄ±m:

SELECT 
DATEPART(MONTH, DATE_) MONTHNR_,
DATENAME(MONTH, DATE_) MONTHNAME_,
SUM(TOTALPRICE) AS TOTALSALE
FROM ORDERS 
GROUP BY DATENAME(MONTH, DATE_), DATEPART(MONTH, DATE_)
ORDER BY 1

-- bu sorguyu view haline getirelim

CREATE VIEW MONTH_SALES -- view'Ä± oluÅŸturduk
AS
	SELECT 
	DATEPART(MONTH, DATE_) MONTHNR_,
	DATENAME(MONTH, DATE_) MONTHNAME_,
	SUM(TOTALPRICE) AS TOTALSALE
	FROM ORDERS 
	GROUP BY DATENAME(MONTH, DATE_), DATEPART(MONTH, DATE_)

-- artÄ±k istenilen formatta tÃ¼rkÃ§e ve toplam ay bazlÄ± satÄ±ÅŸlarÄ± getirelim
SET LANGUAGE turkish -- dili tÃ¼rkÃ§e yaptÄ±k
SELECT MONTHNAME_, TOTALSALE FROM MONTH_SALES
ORDER BY MONTHNR_
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-2:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2048.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekilde gerÃ§ekleÅŸtirilebilir.

```sql
-- veri tabanÄ± iÃ§erisindeki tablolarÄ± gÃ¶rÃ¼ntÃ¼leyelim:
SELECT * FROM ADDRESS
SELECT * FROM CITIES
SELECT * FROM COUNTRIES
SELECT * FROM DISTRICTS
SELECT * FROM INVOICES
SELECT * FROM INVOICEDETAILS
SELECT * FROM ITEMS
SELECT * FROM ORDERDETAILS
SELECT * FROM ORDERS
SELECT * FROM PAYMENTS
SELECT * FROM TOWNS
SELECT * FROM USERS

-- Ã¶ncelikle sql sorgusunu bir yazalÄ±m:
SELECT C.CITY AS 'ÅEHÄ°R',
AVG(DATEDIFF(HOUR, O.DATE_, I.DATE_)) AS 'ORTALAMA HAZIRLIK'
FROM ORDERS O
JOIN INVOICES I ON I.ORDERID = O.ID
JOIN ADDRESS A ON A.ID = I.ADDRESSID
JOIN CITIES C ON C.ID = A.CITYID
GROUP BY C.CITY

-- view oluÅŸturma
CREATE VIEW VWINVOICEDURATION
AS
	SELECT C.CITY AS 'ÅEHÄ°R',
	AVG(DATEDIFF(HOUR, O.DATE_, I.DATE_)) AS 'ORTALAMA_HAZIRLIK'
	FROM ORDERS O
	JOIN INVOICES I ON I.ORDERID = O.ID
	JOIN ADDRESS A ON A.ID = I.ADDRESSID
	JOIN CITIES C ON C.ID = A.CITYID
	GROUP BY C.CITY
	
	-- view gÃ¶rÃ¼ntÃ¼leme
SELECT * FROM VWINVOICEDURATION

SELECT TOP 10 * FROM VWINVOICEDURATION 
ORDER BY ORTALAMA_HAZIRLIK -- sipariÅŸin en hÄ±zlÄ± hazÄ±rlandÄ±ÄŸÄ± 10 ÅŸehir.

SELECT TOP 10 * FROM VWINVOICEDURATION 
ORDER BY ORTALAMA_HAZIRLIK DESC -- sipariÅŸin en yavaÅŸ hazÄ±rlandÄ±ÄŸÄ± 10 ÅŸehir.

```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-3:***

![Untitled](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Untitled%2049.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ bu ÅŸekildedir:

```sql
-- veri tabanÄ± iÃ§erisindeki tablolarÄ± gÃ¶rÃ¼ntÃ¼leyelim:
SELECT * FROM ADDRESS
SELECT * FROM CITIES
SELECT * FROM COUNTRIES
SELECT * FROM DISTRICTS
SELECT * FROM INVOICES
SELECT * FROM INVOICEDETAILS
SELECT * FROM ITEMS
SELECT * FROM ORDERDETAILS
SELECT * FROM ORDERS
SELECT * FROM PAYMENTS
SELECT * FROM TOWNS
SELECT * FROM USERS

-- Ã¶ncelikle sql sorgusunu bir yazalÄ±m:

SELECT 
NAMESURNAME AS 'ADSOYAD', -- ad soyad bilgisi
GENDER AS 'CÄ°NSÄ°YET', -- cinsiyet
DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS 'YAÅ', -- yaÅŸ deÄŸiÅŸkeni
BIRTHDATE, -- doÄŸum tarihi
CASE -- cinsiyete uygun olarak bey veya hanÄ±m ÅŸeklinde mesajlar
WHEN GENDER = 'K' THEN 'SN. '+NAMESURNAME+' HanÄ±m '+ CONVERT(VARCHAR, DATEDIFF(YEAR, BIRTHDATE, GETDATE()))+'. yaÅŸÄ±nÄ±zÄ± kutlar. Ailenizle ve sevdiklerinizle mutlu bir yÄ±l dileriz...'
WHEN GENDER = 'E' THEN 'SN. '+NAMESURNAME+' Bey '+ CONVERT(VARCHAR, DATEDIFF(YEAR, BIRTHDATE, GETDATE()))+'. yaÅŸÄ±nÄ±zÄ± kutlar. Ailenizle ve sevdiklerinizle mutlu bir yÄ±l dileriz...'
END AS MESAJ
FROM USERS

-- view oluÅŸturma
CREATE VIEW VWBUGUNDOGANLAR
AS
	SELECT 
	NAMESURNAME AS 'ADSOYAD', -- ad soyad bilgisi
	GENDER AS 'CÄ°NSÄ°YET', -- cinsiyet
	DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS 'YAÅ', -- yaÅŸ deÄŸiÅŸkeni
	BIRTHDATE, -- doÄŸum tarihi
	CASE -- cinsiyete uygun olarak bey veya hanÄ±m ÅŸeklinde mesajlar
	WHEN GENDER = 'K' THEN 'SN. '+NAMESURNAME+' HanÄ±m '+ CONVERT(VARCHAR, DATEDIFF(YEAR, BIRTHDATE, GETDATE()))+'. yaÅŸÄ±nÄ±zÄ± kutlar. Ailenizle ve sevdiklerinizle mutlu bir yÄ±l dileriz...'
	WHEN GENDER = 'E' THEN 'SN. '+NAMESURNAME+' Bey '+ CONVERT(VARCHAR, DATEDIFF(YEAR, BIRTHDATE, GETDATE()))+'. yaÅŸÄ±nÄ±zÄ± kutlar. Ailenizle ve sevdiklerinizle mutlu bir yÄ±l dileriz...'
	END AS MESAJ
	FROM USERS
	
	SELECT * FROM VWBUGUNDOGANLAR -- view'Ä±n gÃ¶rÃ¼ntÃ¼lenmesi
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

Viewâ€™la ilgili anlatÄ±lacaklar bu kadardÄ±. Bir sonraki konumuz:

### User Defined Function

KullanÄ±cÄ±nÄ±n kendisinin tanÄ±mladÄ±ÄŸÄ± fonksiyonlara user defined function adÄ± verilir. Bu fonksiyonlar iÃ§ine hiÃ§ parametre almayabilir veya birden fazla parametre alarak sonuÃ§ dÃ¶ndÃ¼ren fonksiyonlardÄ±r.

- Scalar valued ve table valued olarak ikiye ayrÄ±lmaktadÄ±r.
- Scalar valued: Ä°Ã§erisine sadece bir adet parametre alan fonksiyonlardÄ±r. Ã–rneÄŸin `DATEDIFF()` fonksiyonlarÄ± birer scalar valued fonksiyonudur.
- Table valued: FarklÄ± ÅŸekillerde kullanÄ±lan table valued fonksiyonlarÄ± genellikle birden fazla parametre alabilir. Ã–rneÄŸin `string_split()` fonksiyonu bir table valued fonksiyonudur.
- Sorgu iÃ§erisinde kullanÄ±labilir ve her satÄ±r iÃ§in Ã§alÄ±ÅŸtÄ±rÄ±labilir.
- FonksiyonlarÄ±n iÃ§inde insert, update, delete cÃ¼mleleri kullanÄ±lmaz, select cÃ¼mleleri kullanÄ±lÄ±r.
- Viewâ€™dan farklÄ± olaraka iÃ§inde deÄŸiÅŸken tanÄ±mlanabilir, bu deÄŸiÅŸkenlere deÄŸer atanabilir.
- Kodu sadeleÅŸtirir.
- SÃ¼rekli yapÄ±lan iÅŸlemler iÃ§in aynÄ± kodu sÃ¼rekli yazmak yerine tek seferde yazmamÄ±zÄ± saÄŸlar. BÃ¶ylece deÄŸiÅŸiklik yapÄ±lacaÄŸÄ± zaman sadece fonksiyonda deÄŸiÅŸiklik yapÄ±lmasÄ± yeterlidir.

***SCALAR VALUED FUNCTIONS***

BÃ¼tÃ¼n veri tabanÄ± nesnelerinde olduÄŸu gibi user defined functionâ€™da create ile oluÅŸturulur, alter ile deÄŸiÅŸtirilir, drop ile silinir.

Genel anlamda bir scalar valued function ÅŸu ÅŸekilde oluÅŸturulur.

```sql
CREATE FUNCTION DBO.TOPLA(@SAYI1 AS INT, @SAYI2 AS INT)
RETURNS INT -- ne tÃ¼r sonuÃ§ dÃ¶ndÃ¼rÃ¼leceÄŸi belirtilir
AS 
BEGIN  -- fonksiyonlarÄ±n yapacaÄŸÄ± iÅŸlemler bu kÄ±sÄ±mda belirtilir.

RETURN @SAYI1 + @SAYI2 -- en son sonucun dÃ¶ndÃ¼ÄŸÃ¼ kÄ±sÄ±m burasÄ±dÄ±r.
END
```

Bu ÅŸekilde ilgili veri tabanÄ±nda sorgu Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rsa ÅŸu ÅŸekilde fonksiyon oluÅŸturulmuÅŸ olur.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi fonksiyon oluÅŸturuldu.

Fonksiyonu kullanmak istediÄŸimiz zaman ÅŸu tip bir sorguyla fonksiyonu Ã§aÄŸÄ±rabiliriz.

`SELECT dbo.TOPLA(30,15) -- 45`

Bu ÅŸekilde fonksiyon Ã§alÄ±ÅŸtÄ±rÄ±lmÄ±ÅŸ olur.

Fonksiyonlarda gÃ¼ncelleme yapmak iÃ§in ise `ALTER` fonksiyonu kullanÄ±lÄ±r.

```sql
-- fonksiyonda gÃ¼ncelleme yapmak iÃ§in ise
ALTER FUNCTION DBO.TOPLA(@SAYI1 AS INT, @SAYI2 AS INT)
RETURNS INT -- ne tÃ¼r sonuÃ§ dÃ¶ndÃ¼rÃ¼leceÄŸi belirtilir
AS 
BEGIN  -- fonksiyonlarÄ±n yapacaÄŸÄ± iÅŸlemler bu kÄ±sÄ±mda belirtilir.

RETURN @SAYI1 + @SAYI2
END
```

Bu ÅŸekilde fonksiyonu gÃ¼ncellemiÅŸ oluruz.

Genellikle yapÄ±lacak iÅŸlemler yukarÄ±da belirtildiÄŸi gibi sadece `RETURN` kÄ±smÄ±nda belirtilmez. YapÄ±lacak iÅŸlemlerin tamamÄ± `BEGIN - END` bloklarÄ± iÃ§erisinde ele alÄ±nÄ±r. 

```sql
ALTER FUNCTION DBO.TOPLA(@SAYI1 AS INT, @SAYI2 AS INT)
RETURNS INT -- ne tÃ¼r sonuÃ§ dÃ¶ndÃ¼rÃ¼leceÄŸi belirtilir
AS 
BEGIN  -- fonksiyonlarÄ±n yapacaÄŸÄ± iÅŸlemler bu kÄ±sÄ±mda belirtilir.
DECLARE @SONUC AS INT
SET @SONUC = @SAYI1 + @SAYI2
RETURN @SONUC
END
```

Bu kÄ±sÄ±mda ise bir sonuc deÄŸiÅŸkeni belirtilir. Bu sonuc deÄŸiÅŸkeni set edilerek return kÄ±smÄ±nda bu Ã§aÄŸÄ±rÄ±larak fonksiyon iÅŸlemi yapÄ±lÄ±r.

YukarÄ±da yazÄ±lan sorgularÄ±n tamamÄ± ÅŸu ÅŸekildedir:

```sql
/*
	BÃ¼tÃ¼n veri tabanÄ± nesnelerinde olduÄŸu gibi user defined functionlarda
	create ile oluÅŸturulur.
	alter ile deÄŸiÅŸtirilir
	drop ile silinir.
*/
/*
CREATE FUNCTION DBO.TOPLA(@SAYI1 AS INT, @SAYI2 AS INT)
RETURNS INT -- ne tÃ¼r sonuÃ§ dÃ¶ndÃ¼rÃ¼leceÄŸi belirtilir
AS 
BEGIN  -- fonksiyonlarÄ±n yapacaÄŸÄ± iÅŸlemler bu kÄ±sÄ±mda belirtilir.

RETURN @SAYI1 + @SAYI2
END
*/
SELECT dbo.TOPLA(30,15) -- 45

-- fonksiyonda gÃ¼ncelleme yapmak iÃ§in ise
ALTER FUNCTION DBO.TOPLA(@SAYI1 AS INT, @SAYI2 AS INT)
RETURNS INT -- ne tÃ¼r sonuÃ§ dÃ¶ndÃ¼rÃ¼leceÄŸi belirtilir
AS 
BEGIN  -- fonksiyonlarÄ±n yapacaÄŸÄ± iÅŸlemler bu kÄ±sÄ±mda belirtilir.

RETURN @SAYI1 + @SAYI2
END

-- begin end bloklarÄ± iÃ§erisinde ise ÅŸu ÅŸekilde bir yapÄ± da kurgulayabiliriz.

ALTER FUNCTION DBO.TOPLA(@SAYI1 AS INT, @SAYI2 AS INT)
RETURNS INT -- ne tÃ¼r sonuÃ§ dÃ¶ndÃ¼rÃ¼leceÄŸi belirtilir
AS 
BEGIN  -- fonksiyonlarÄ±n yapacaÄŸÄ± iÅŸlemler bu kÄ±sÄ±mda belirtilir.
DECLARE @SONUC AS INT
SET @SONUC = @SAYI1 + @SAYI2
RETURN @SONUC
END
```

BaÅŸka bir Ã¶rnekte ise date verilerine gÃ¶re ay bilgilerini getiren bir fonksiyon yazalÄ±m.

```sql
/*
	Ay bilgilerini getiren bir fonksiyon oluÅŸturalÄ±m.
*/

CREATE FUNCTION DBO.GETMONTHNAME(@DATE AS DATETIME) -- fonksiyonu oluÅŸturduk
RETURNS VARCHAR(20) 
AS
BEGIN

DECLARE @RESULT AS VARCHAR(20)
IF MONTH(@DATE) = 1 SET @RESULT = '01.OCAK' -- aylara gÃ¶re durum deÄŸerlendirmesi
IF MONTH(@DATE) = 2 SET @RESULT = '02.ÅUBAT'
IF MONTH(@DATE) = 3 SET @RESULT = '03.MART'
IF MONTH(@DATE) = 4 SET @RESULT = '04.NÄ°SAN'
IF MONTH(@DATE) = 5 SET @RESULT = '05.MAYIS'
IF MONTH(@DATE) = 6 SET @RESULT = '06.HAZÄ°RAN'
IF MONTH(@DATE) = 7 SET @RESULT = '07.TEMMUZ'
IF MONTH(@DATE) = 8 SET @RESULT = '08.AÄUSTOS'
IF MONTH(@DATE) = 9 SET @RESULT = '09.EYLÃœL'
IF MONTH(@DATE) = 10 SET @RESULT = '10.EKÄ°M'
IF MONTH(@DATE) = 11 SET @RESULT = '11.KASIM'
IF MONTH(@DATE) = 12 SET @RESULT = '12.ARALIK'

RETURN @RESULT

END

SELECT dbo.GETMONTHNAME('2022-02-06') -- veri giriÅŸi

-- bir talep doÄŸrultusunda raporda deÄŸiÅŸiklik yapÄ±lmasÄ± istenildi.

ALTER FUNCTION DBO.GETMONTHNAME(@DATE AS DATETIME) -- fonksiyonu gÃ¼ncelledik.
RETURNS VARCHAR(20)
AS
BEGIN

DECLARE @RESULT AS VARCHAR(20)
IF MONTH(@DATE) = 1 SET @RESULT = '01.OCK'
IF MONTH(@DATE) = 2 SET @RESULT = '02.ÅBT'
IF MONTH(@DATE) = 3 SET @RESULT = '03.MRT'
IF MONTH(@DATE) = 4 SET @RESULT = '04.NSN'
IF MONTH(@DATE) = 5 SET @RESULT = '05.MYS'
IF MONTH(@DATE) = 6 SET @RESULT = '06.HZRN'
IF MONTH(@DATE) = 7 SET @RESULT = '07.TMMZ'
IF MONTH(@DATE) = 8 SET @RESULT = '08.AÄSTS'
IF MONTH(@DATE) = 9 SET @RESULT = '09.EYLL'
IF MONTH(@DATE) = 10 SET @RESULT = '10.EKM'
IF MONTH(@DATE) = 11 SET @RESULT = '11.KSIM'
IF MONTH(@DATE) = 12 SET @RESULT = '12.ARLK'

RETURN @RESULT

END

SELECT dbo.GETMONTHNAME('2022-02-06')
```

Bu ÅŸekilde bir fonksiyon yapÄ±lmÄ±ÅŸ oldu.

User defined functionlar kullanarak karmaÅŸÄ±k yapÄ±larda olan subquery sorgularÄ±nÄ± ya da hesaplama gibi iÅŸlem gerektiren durumlarÄ± kolaylÄ±kla halledebilirsin.

Ã–rnek sorgular:

```sql
SELECT I.ID, I.ITEMCODE, I.ITEMNAME, I.CATEGORY1, I.BRAND, 
(SELECT SUM(AMOUNT) FROM ORDERDETAILS WHERE ITEMID = I.ID) TOTALAMOUNT
FROM ITEMS I

-- bir Ã¼rÃ¼nden toplamda ne kadar satÄ±ldÄ± bilgisini getirtelim
--SELECT SUM(AMOUNT) FROM ORDERDETAILS WHERE ITEMID = 1

-- fonksiyonu kullanarak verileri alalÄ±m

SELECT DBO.GETTOTALAMOUNT(2)

-- bu fonksiyonu ise bir subquery olarak kullanabiliriz.
SELECT I.ID, I.ITEMCODE, I.ITEMNAME, I.CATEGORY1, I.BRAND, 
(SELECT SUM(AMOUNT) FROM ORDERDETAILS WHERE ITEMID = I.ID) TOTALAMOUNT,
DBO.GETTOTALAMOUNT(I.ID) TOTALAMOUNT2 -- subquery olarak yazÄ±lmÄ±ÅŸ fonksiyon
FROM ITEMS I

-- peki parasal olarak ne kadar satÄ±ldÄ±ÄŸÄ±na bir bakalÄ±m
SELECT I.ID, I.ITEMCODE, I.ITEMNAME, I.CATEGORY1, I.BRAND, 
(SELECT SUM(AMOUNT) FROM ORDERDETAILS WHERE ITEMID = I.ID) TOTALAMOUNT,
DBO.GETTOTALAMOUNT(I.ID) TOTALAMOUNT2, -- subquery olarak yazÄ±lmÄ±ÅŸ toplam satÄ±ÅŸ adeti fonksiyon
(SELECT SUM(LINETOTAL) FROM ORDERDETAILS WHERE ITEMID = I.ID) TOTALSALE -- parasal olarak ne kadar satÄ±ldÄ± ?
FROM ITEMS I

-- parasal olarak ne kadar satÄ±ldÄ±ÄŸÄ±na dair yapÄ±yÄ± bir de fonksiyon kullanarak yazalÄ±m
SELECT I.ID, I.ITEMCODE, I.ITEMNAME, I.CATEGORY1, I.BRAND, 
(SELECT SUM(AMOUNT) FROM ORDERDETAILS WHERE ITEMID = I.ID) TOTALAMOUNT,
DBO.GETTOTALAMOUNT(I.ID) TOTALAMOUNT2, -- subquery olarak yazÄ±lmÄ±ÅŸ toplam satÄ±ÅŸ adeti fonksiyon
(SELECT SUM(LINETOTAL) FROM ORDERDETAILS WHERE ITEMID = I.ID) TOTALSALE, -- parasal olarak ne kadar satÄ±ldÄ± ?
DBO.GETTOTALSALE(I.ID) TOTALSALE2 -- subquery olarak yazÄ±lmÄ±ÅŸ parasal olarak ne kadar satÄ±ldÄ± bilgisini gÃ¶steren fonksiyon
FROM ITEMS I
```

Bu ÅŸekilde karmaÅŸÄ±k sorgularÄ± daha da sade hale getirebilmek ve daha esnek halde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayabilmek iÃ§in kullandÄ±ÄŸÄ±mÄ±z iki adet fonksiyon bulunmaktadÄ±r. Bu fonksiyonlardan bir tanesi olan `DBO.GETTOTALAMOUNT(I.ID) TOTALAMOUNT2, -- subquery olarak yazÄ±lmÄ±ÅŸ toplam satÄ±ÅŸ adeti fonksiyonu` sorgusunun iÃ§eriÄŸini ve `DBO.GETTOTALSALE(I.ID) TOTALSALE2 -- subquery olarak yazÄ±lmÄ±ÅŸ parasal olarak ne kadar satÄ±ldÄ± bilgisini gÃ¶steren fonksiyonunu` iÃ§eriÄŸini beraber inceleyelim.

*Birinci fonksiyon:*

```sql
-- toplam satÄ±ÅŸÄ±yla ilgili bir fonksiyon oluÅŸturalÄ±m.

CREATE FUNCTION DBO.GETTOTALAMOUNT(@ITEMID INT)
RETURNS INT
AS 
BEGIN
	DECLARE @RESULT AS INT

	SELECT @RESULT = SUM(AMOUNT) FROM ORDERDETAILS WHERE ITEMID = @ITEMID

	RETURN @RESULT
END
```

Bu ÅŸekilde birinci fonksiyon tanÄ±mlanmaktadÄ±r.

*Ä°kinci fonksiyon:*

```sql
-- parasal anlamda ne kadar satÄ±ÅŸ yapÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶steren fonksiyon

CREATE FUNCTION DBO.GETTOTALSALE(@ITEMID INT)
RETURNS FLOAT
AS
BEGIN

	DECLARE @RESULT AS FLOAT

	SELECT @RESULT = SUM(LINETOTAL) FROM ORDERDETAILS WHERE ITEMID = @ITEMID

	RETURN @RESULT

END
```

Bu ÅŸekilde de ikinci fonksiyon tanÄ±mlanmaktadÄ±r.

BaÅŸka bir Ã¶rnek yapmak gerekirse bir veri seti iÃ§erisindeki bir Ã¼rÃ¼nÃ¼n maksimum fiyatÄ±, minimum fiyatÄ±, ortalama fiyatÄ± gibi diÄŸer parametreleri nasÄ±l yapabiliriz.

Fonksiyon sorgularÄ±mÄ±zÄ± yazalÄ±m:

```sql
--  en dÃ¼ÅŸÃ¼k fiyatlÄ± Ã¼rÃ¼nÃ¼ getiren fonksiyon
CREATE FUNCTION DBO.GETMINPRICE(@ITEMID INT)
RETURNS FLOAT
AS
BEGIN
	DECLARE @RESULT AS FLOAT
	SELECT @RESULT = MIN(UNITPRICE) FROM ORDERDETAILS WHERE ITEMID = @ITEMID
	RETURN @RESULT
END

-- en yÃ¼ksek fiyatlÄ±
CREATE FUNCTION DBO.GETMAXPRICE(@ITEMID INT)
RETURNS FLOAT
AS
BEGIN
	DECLARE @RESULT AS FLOAT
	SELECT @RESULT = MAX(UNITPRICE) FROM ORDERDETAILS WHERE ITEMID = @ITEMID
	RETURN @RESULT
END

-- fiyatlarÄ±n ortalamasÄ±
CREATE FUNCTION DBO.AVERAGEPRICE(@ITEMID INT)
RETURNS FLOAT
AS
BEGIN
	DECLARE @RESULT AS FLOAT
	SELECT @RESULT = AVG(UNITPRICE) FROM ORDERDETAILS WHERE ITEMID = @ITEMID
	RETURN @RESULT
END
```

Bu ÅŸekilde fonksiyonlarÄ± yazmÄ±ÅŸ olduk. Bunu bu sefer sorgu iÃ§erisinde tekrardan yazarak Ã§alÄ±ÅŸtÄ±ralÄ±m:

```sql
SELECT I.ID, I.ITEMCODE, I.CATEGORY1, I.BRAND,
DBO.GETTOTALAMOUNT(I.ID) TOTALAMOUNT,
DBO.GETTOTALSALE(I.ID) TOTALSALE,
DBO.GETMINPRICE(I.ID) MINPRICE, -- Ã¼rÃ¼nlerin minimum fiyata sahip hali fonksiyonu
DBO.GETMAXPRICE(I.ID) MAXPRICE, -- Ã¼rÃ¼nlerin maksimum fiyata sahip hali fonksiyonu
DBO.AVERAGEPRICE(I.ID) AVERAGEPRICE -- Ã¼rÃ¼nlerin ortalama fiyatlarÄ±
FROM ITEMS I
```

Bu ÅŸekilde sorgu iÃ§erisinde fonksiyonlarÄ± Ã§alÄ±ÅŸtÄ±rmÄ±ÅŸ olduk.

Ancak bu tip bir Ã§alÄ±ÅŸtÄ±rmalar bize olumsuz olarak dÃ¶nÃ¼ÅŸ saÄŸlar. Ã‡Ã¼nkÃ¼ bu fonksiyonlarÄ±n her biri veri setindeki toplam veri adeti kadar RAMâ€™e yÃ¼klenir. Ä°ÅŸte bu tip bir problemi aÅŸmak iÃ§in ise inline table valued kullanÄ±lÄ±r.

***Inline Table Valued***

Scalar valued fonksiyonlar genellikle bir adet veri tipinde dÃ¶nÃ¼ÅŸÃ¼m saÄŸlayabileceÄŸi iÃ§in tek bir fonksiyonu bir araya getirtebilir. Birden fazla fonksiyonu bir araya getirebilmek iÃ§in Inline Table Valued Functionlar kullanÄ±lÄ±r. Bu fonksiyonlarda genellikle yapÄ±lar bir tablo deÄŸeriyle dÃ¶nÃ¼ÅŸ yaparlar. Ã–rnek sorgu yapÄ±sÄ±nÄ± inceleyelim:

```sql

CREATE FUNCTION DBO.ITEMINFO
(	
	@ITEMID INT -- alabileceÄŸi parametreler buraya eklenir
)
RETURNS TABLE -- temel farklÄ±lÄ±k buradadÄ±r. DiÄŸer fonksiyonlarda deÄŸiÅŸkenin veri tipini dÃ¶ndÃ¼rÃ¼rken burada table tÃ¼rÃ¼nde dÃ¶ndÃ¼rebiliriz.
AS
RETURN -- dÃ¶ndÃ¼rÃ¼lmesi istenilen iÅŸlemler bu parantez iÃ§erisine yazÄ±lÄ±r
(
	SELECT I.ID, I.ITEMCODE, I.ITEMNAME, SUM(OD.AMOUNT) TOTALAMOUNT, SUM(OD.LINETOTAL) TOTALSALE,
	MIN(OD.UNITPRICE) MINPRICE, MAX(OD.UNITPRICE) MAXPRICE, AVG(OD.UNITPRICE) AVGPRICE
	FROM ITEMS I
	JOIN ORDERDETAILS OD ON OD.ITEMID = I.ID
	WHERE I.ID = @ITEMID
	GROUP BY I.ID, I.ITEMCODE, I.ITEMNAME

)
GO
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi `RETURNS` ifadesinden sonra dÃ¶nÃ¼ÅŸ table tÃ¼rÃ¼ndedir. Bu table tÃ¼rÃ¼nde olduÄŸu iÃ§in table valued functionlarÄ±n kullanÄ±mÄ± da Ã§aÄŸrÄ±lmasÄ± da scalar value functiona gÃ¶re farklÄ±lÄ±k gÃ¶stermektedir.

Bu fonksiyon iÃ§erisinde `RETURN` ifadesinden sonra istenilen sorgu Ã§alÄ±ÅŸtÄ±rÄ±larak bir tablo yapÄ±sÄ± kurgulanÄ±r.

Bu fonksiyonu Ã§aÄŸÄ±rmak iÃ§in ise:

```sql
-- scalar value ifadeleri tek baÅŸÄ±na select ifadesiyle Ã§aÄŸÄ±rabiliriz ancak
-- table valued fonksiyonlarÄ±nda return ifadesi bir scalar value olmadÄ±ÄŸÄ± iÃ§in bir table value olarak deÄŸer
-- dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iÃ§in aÅŸaÄŸÄ±daki gibi bir kullanÄ±m hatalÄ±dÄ±r.

--SELECT DBO.ITEMINFO(1)
/*
	Msg 4121, Level 16, State 1, Line 5
	Cannot find either column "DBO" or the user-defined function or aggregate "DBO.ITEMINFO", or the name is ambiguous.
*/

-- Ã¶nceden de dediÄŸimiz gibi table valued iÅŸlemlerde SELECT * FROM sÃ¶zcÃ¼ÄŸÃ¼ kullanÄ±larak Ã§aÄŸÄ±rÄ±labilmektedir.
-- Ã–rnek kullanÄ±m aÅŸaÄŸÄ±daki gibidir.

SELECT * FROM DBO.ITEMINFO(1)
```

Bu ÅŸekilde Ã§aÄŸÄ±rÄ±lmÄ±ÅŸ olur.

Daha Ã¶nceden de sÃ¶ylenildiÄŸi gibi aslÄ±nda dÃ¶nÃ¼ÅŸÃ¼mler bir tablo olarak saÄŸlanÄ±r. Tablo olarak dÃ¶nÃ¼ÅŸÃ¼m saÄŸlanmasÄ± neticesinde ise diÄŸer yapÄ±lan tablolarÄ± birleÅŸtirme iÅŸlemi *(joinlemeler)* burada da gerÃ§ekleÅŸtirilebilir.

```sql
-- bir tablo olarak dÃ¶nÃ¼ÅŸÃ¼m saÄŸladÄ±ÄŸÄ± iÃ§in farklÄ± tablolarla joinlemeler yaparak farklÄ± tablolarÄ± bir araya getirebiliriz
-- ANCAK burada bir istisna vardÄ±r:
/*
	buradaki istisna ise ÅŸudur ki klasik olarak yapÄ±lan joinleme iÅŸlemi table valued fonksiyonlarÄ±nda kullanÄ±lamaz
	bunun yerine kullanÄ±lacak fonksiyon ise cross apply ifadesidir. Bu ifade sayesinde joinlemeler gerÃ§ekleÅŸtirilebilir.

*/
SELECT I.ID, I.ITEMCODE, I.ITEMNAME,
INF.TOTALAMOUNT, INF.TOTALSALE, INF.MINPRICE, INF.MAXPRICE, INF.AVGPRICE
FROM ITEMS I
CROSS APPLY DBO.ITEMINFO(I.ID) INF -- table-valued fonksiyonu iÃ§in cross apply ifadesidir
```

Burada `CROSS APPLY` kullanÄ±larak ise joinleme yani farklÄ± tablolarÄ± bir araya getirme iÅŸlemi yapÄ±lmÄ±ÅŸ olur.

***Multi Statement Function***

Inline table valued functionlarda sadece tek bir iÅŸlem gerÃ§ekleÅŸtirilebilir. Bu baÄŸÄ±mlÄ±lÄ±klardan kurtulmak ve tek bir fonksiyonda daha fazla iÅŸlemi gerÃ§ekleÅŸtirmek iÃ§in *(insert, update, delete)* gibi iÅŸlemlerin tamamÄ±nÄ± tek bir fonksiyonda gerÃ§ekleÅŸtirmek iÃ§in Multi Statement Function kullanÄ±lÄ±r.

```sql

ALTER FUNCTION DBO.ITEMINFO3 
(
	@ITEMID INT
)
RETURNS 
@RESULT TABLE 
(
	ID INT, ITEMCODE VARCHAR(50), ITEMNAME VARCHAR(100),
	TOTALAMOUNT INT, TOTALSALE FLOAT, MINPRICE FLOAT,
	MAXPRICE FLOAT, AVGPRICE FLOAT
)
AS
BEGIN -- birden fazla iÅŸlemi (insert, update, delete) iÅŸlemlerinin tamamÄ± gerÃ§ekleÅŸtirilebilir. inline table valued'da sadece tek bir iÅŸlem gerÃ§ekleÅŸtirilir.
	INSERT INTO @RESULT (ID,ITEMCODE, ITEMNAME, TOTALAMOUNT, TOTALSALE, MINPRICE, MAXPRICE, AVGPRICE)
	SELECT I.ID, I.ITEMCODE, I.ITEMNAME, SUM(OD.AMOUNT) TOTALAMOUNT, SUM(OD.LINETOTAL) TOTALSALE,
	MIN(OD.UNITPRICE) MINPRICE, MAX(OD.UNITPRICE) MAXPRICE, AVG(OD.UNITPRICE) AVGPRICE
	FROM ITEMS I
	JOIN ORDERDETAILS OD ON OD.ITEMID = I.ID
	WHERE I.ID = @ITEMID
	GROUP BY I.ID, I.ITEMCODE, I.ITEMNAME
	
	RETURN 
END
GO
```

YukarÄ±da gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi birden fazla iÅŸlemi *(insert, update, delete)* gibi iÅŸlemlerin her biri tek bir fonksiyon iÃ§erisinde yazÄ±lmÄ±ÅŸ oldu. Bu ÅŸekilde yapÄ±lar kurgulanabilir.

Bu fonksiyonun Ã§aÄŸÄ±rÄ±larak kullanÄ±lmasÄ± ise ÅŸu ÅŸekildedir:

```sql
-- belirtilen fonksiyonu kullanmak iÃ§in ise ÅŸu ÅŸekilde bir yÃ¶ntem izleyebiliriz
SELECT * FROM DBO.ITEMINFO3(54545454) -- elle girdiÄŸimiz deÄŸerleri getirdi
```

Bu ÅŸekilde sorgu Ã§alÄ±ÅŸtÄ±rÄ±larak istenilen dÃ¼zeyde kullanÄ±labilmektedir.

Genel anlamda fonksiyonlar bu kadardÄ±. 

Biraz alÄ±ÅŸtÄ±rmalarla bu konuyu daha da pekiÅŸtirelim:

***ALIÅTIRMA-1:***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%201.png)

Ã–ncelikle fonksiyonu yazalÄ±m:

```sql
-- futbolcularÄ±n yaÅŸlarÄ±nÄ± getirecek fonksiyonu yazacaÄŸÄ±z.

CREATE FUNCTION DBO.AGE(@BIRTHDATE AS DATE)
RETURNS INT
AS
BEGIN
DECLARE @AGE AS INT
SET @AGE = YEAR(GETDATE()) - YEAR(@BIRTHDATE)

RETURN @AGE
END
```

Bu ÅŸekilde tarih verileri iÃ§erisinden yÄ±l verilerini alarak bir fonksiyon oluÅŸturmuÅŸ olduk. ArtÄ±k gÃ¶rselde de istenilen formatta verilerimizi Ã§ekelim:

```sql
SELECT 
	P.ID, P.PLAYER_NAME, P.BIRTHDATE, 
	DBO.AGE(P.BIRTHDATE) AGE
FROM LAB_PLAYER P
```

Bu ÅŸekilde de sorunumuz Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-2:***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%202.png)

Ã–ncelikle yaÅŸ gruplarÄ±nÄ± getirecek fonksiyonu yazalÄ±m:

```sql
-- oyuncularÄ±n yaÅŸ gruplarÄ±nÄ± yazdÄ±ran fonksiyonu yazalÄ±m

ALTER FUNCTION DBO.AGEGROUP(@BIRTHDATE AS DATE)
RETURNS VARCHAR(20)
AS
BEGIN
DECLARE @AGE AS INT
SET @AGE = DATEDIFF(YEAR, @BIRTHDATE, GETDATE())

DECLARE @RESULT AS VARCHAR(20)
IF @AGE > 20 
	SET @RESULT = '20 DEN KÃœÃ‡ÃœK'
IF @AGE BETWEEN 20 AND 30
	SET @RESULT = '20 ile 30 ARASI'
IF @AGE BETWEEN 30 AND 40
	SET @RESULT = '30 ile 40 ARASI'
IF @AGE > 40
	SET @RESULT = '40 DAN BÃœYÃœK'

RETURN @RESULT
END
```

Åimdi eskiden yazmÄ±ÅŸ olduÄŸumuz age fonksiyonunu da kullanarak bu fonksiyonu kullanalÄ±m:

```sql
SELECT L.ID, L.PLAYER_NAME, L.BIRTHDATE,
DBO.AGE(L.BIRTHDATE) AGE,
DBO.AGEGROUP(L.BIRTHDATE) AGE_EXP
FROM LAB_PLAYER L
```

Bu ÅŸekilde fonksiyonumuzu kullanmÄ±ÅŸ olduk.

***ALIÅTIRMA-3:***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%203.png)

SÄ±rasÄ±yla fonksiyonlarÄ± oluÅŸturalÄ±m:

*Mevcut oynadÄ±ÄŸÄ± takÄ±mÄ± getiren fonksiyon:*

```sql
-- futbolcunun mevcut oynadÄ±ÄŸÄ± takÄ±mÄ± getiren fonksiyon

CREATE FUNCTION DBO.GETTEAMNAME(@PLAYERID INT)
RETURNS VARCHAR(200)
AS
BEGIN
	DECLARE @RESULT AS VARCHAR(200)
	SELECT @RESULT = LM.TEAM FROM LAB_MATCH_PLAYER LM WHERE PLAYERID = @PLAYERID

	RETURN @RESULT
END
```

Oyuncunun PLAYERIDâ€™sini fonksiyona parametre olarak gÃ¶ndererek ÅŸuanda mevcut olarak oynadÄ±ÄŸÄ± takÄ±mÄ± bize gÃ¶sterdi.

*Oyuncunun kaÃ§ farklÄ± takÄ±mda oynadÄ±ÄŸÄ±nÄ± getiren fonksiyon:*

```sql
-- kaÃ§ farklÄ± takÄ±mda oynadÄ±ÄŸÄ±nÄ± gÃ¶steren fonksiyon
/*
SELECT COUNT(DISTINCT LBP.TEAMID) FROM LAB_MATCH_PLAYER LBP
WHERE PLAYERID = 39562
*/

CREATE FUNCTION DBO.GETTEAMCOUNT(@PLAYERID INT)
RETURNS INT
AS
BEGIN
	DECLARE @RESULT AS INT
	SELECT @RESULT = COUNT(DISTINCT LBP.TEAMID) FROM LAB_MATCH_PLAYER LBP
	WHERE PLAYERID = @PLAYERID

RETURN @RESULT
END
```

Oyuncunun PLAYERIDâ€™sini fonksiyona parametre olarak gÃ¶ndererek oyuncunun toplamda kaÃ§ farklÄ± takÄ±mda oynadÄ±ÄŸÄ±nÄ± `COUNT(DISTINCT LBP.TEAM)` fonksiyonuyla bulduk.

*Oyuncunun kaÃ§ maÃ§ yaptÄ±ÄŸÄ±nÄ± getiren fonksiyon:*

```sql
-- toplam kaÃ§ maÃ§ yaptÄ±ÄŸÄ±nÄ±
SELECT * FROM LAB_MATCH_PLAYER

SELECT COUNT(*) TOPLAM_MAC_SAYISI, PLAYER_NAME  FROM LAB_MATCH_PLAYER
GROUP BY  PLAYER_NAME

CREATE FUNCTION DBO.GETMATCHCOUNT(@PLAYERID AS INT)
RETURNS INT
AS
BEGIN
	DECLARE @RESULT AS INT
	SELECT @RESULT = COUNT(*) FROM LAB_MATCH_PLAYER 
	WHERE PLAYERID = @PLAYERID

RETURN @RESULT
END
```

Oyuncunun PLAYERIDâ€™sini fonksiyona parametre olarak gÃ¶ndererek oyuncunun toplamda kaÃ§ farklÄ± takÄ±mda oynadÄ±ÄŸÄ±nÄ± `COUNT(*)` fonksiyonuyla bulduk.

*Oyuncunun kaÃ§ yÄ±ldÄ±r futbol oynadÄ±ÄŸÄ±nÄ± gÃ¶steren fonksiyon:*

```sql
-- kaÃ§ yÄ±ldÄ±r futbol oynadÄ±ÄŸÄ±nÄ±

SELECT * FROM LAB_PLAYER
SELECT 
PLAYERID, 
DATEDIFF(YEAR, MIN(DATE_), MAX(DATE_)) AS TOPCU_SURESI
FROM LAB_MATCH_PLAYER 
GROUP BY PLAYERID

CREATE FUNCTION DBO.YEARSACTIVE(@PLAYERID INT)
RETURNS INT
AS 
BEGIN
	DECLARE @RESULT AS INT
	SELECT @RESULT = DATEDIFF(YEAR, MIN(DATE_), MAX(DATE_)) FROM LAB_MATCH_PLAYER
	WHERE PLAYERID = @PLAYERID

	RETURN @RESULT
END
```

Oyuncunun PLAYER_IDâ€™sini fonksiyona parametre olarak gÃ¶ndererek oyuncunun kaÃ§ yÄ±ldÄ±r futbol oynadÄ±ÄŸÄ±nÄ± `DATEDIFF()` fonksiyonuyla bulduk.

*Son olarak fonksiyonlarÄ±n hepsini bir araya getiren sonuÃ§ sorgusunu yazalÄ±m:*

```sql
-- SORGUNUN SON HALÄ°

SELECT LMP.PLAYERID, LMP.PLAYER_NAME, 
DBO.GETTEAMNAME(LMP.PLAYERID) AS TEAMNAME,
DBO.GETTEAMCOUNT(LMP.PLAYERID) AS TEAMCOUNT,
DBO.YEARSACTIVE(LMP.PLAYERID) AS YEARSACTIVE,
DBO.GETMATCHCOUNT(LMP.PLAYERID) AS MATCHCOUNT
FROM LAB_MATCH_PLAYER LMP
GROUP BY PLAYERID, PLAYER_NAME
```

Bu ÅŸekilde problemi Ã§Ã¶zÃ¼me kavuÅŸturmuÅŸ olduk.

***ALIÅTIRMA-4:***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%204.png)

Ã–ncelikle istenilen soruya uygun olarak verileri Ã§ekelim:

```sql
/*
	Her bir futbolcunun yaÅŸÄ±nÄ± ve yaÅŸ grubunu,
	futbolcunun puanÄ±nÄ±,
	kaÃ§ kez yedek kadroda Ã§Ä±ktÄ±ÄŸÄ±nÄ±
	kaÃ§ kez asÄ±l kadroda Ã§Ä±ktÄ±ÄŸÄ±nÄ±
	kaÃ§ farklÄ± takÄ±mda oynadÄ±ÄŸÄ±nÄ±
	toplam kaÃ§ maÃ§ yaptÄ±ÄŸÄ±nÄ±
	kaÃ§ yÄ±ldÄ±r futbol oynadÄ±ÄŸÄ±nÄ±
table valued kullanarak gÃ¶steriniz.
*/

SELECT * FROM LAB_PLAYER

SELECT PLAYER_NAME,
DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS AGE,
CASE 
	WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) < 20 THEN '20 DEN KÃœÃ‡ÃœK'
	WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) BETWEEN 20 AND 30 THEN '20 ile 30 ARASINDA'
	WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) BETWEEN 30 AND 40 THEN '30 ile 40 ARASINDA'
	WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) > 40 THEN '40 DAN BÃœYÃœK'
END AS AGEGROUP,
RATING,
(SELECT COUNT(*) FROM LAB_MATCH_PLAYER WHERE PLAYERID = P.PLAYER_API_ID AND PLAYERTYPE = 'REAL') REALCOUNT,
(SELECT COUNT(*) FROM LAB_MATCH_PLAYER WHERE PLAYERID = P.PLAYER_API_ID AND PLAYERTYPE = 'BACKUP') BACKUPCOUNT,
(SELECT COUNT(DISTINCT LM.TEAMID) FROM LAB_MATCH_PLAYER LM WHERE PLAYERID = P.PLAYER_API_ID) TOTALTEAMCOUNT,
(SELECT COUNT(*) FROM LAB_MATCH_PLAYER WHERE PLAYERID = P.PLAYER_API_ID) TOTALMATCHCOUNT,
(SELECT DATEDIFF(YEAR, MIN(DATE_), MAX(DATE_)) FROM LAB_MATCH_PLAYER WHERE PLAYERID = P.PLAYER_API_ID) TOTALSINCE
FROM LAB_PLAYER P
```

Bu ÅŸekilde sorgumuzu oluÅŸturduk.

Åimdi bunu istenilen durum olan inline table valued fonksiyonu haline getirelim:

```sql

CREATE FUNCTION DBO.INFO 
(	
	@PLAYERID INT
)
RETURNS TABLE 
AS
RETURN 
(
	SELECT PLAYER_NAME,
	DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS AGE,
	CASE 
		WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) < 20 THEN '20 DEN KÃœÃ‡ÃœK'
		WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) BETWEEN 20 AND 30 THEN '20 ile 30 ARASINDA'
		WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) BETWEEN 30 AND 40 THEN '30 ile 40 ARASINDA'
		WHEN DATEDIFF(YEAR, BIRTHDATE, GETDATE()) > 40 THEN '40 DAN BÃœYÃœK'
	END AS AGEGROUP,
	RATING,
	(SELECT COUNT(*) FROM LAB_MATCH_PLAYER WHERE PLAYERID = P.PLAYER_API_ID AND PLAYERTYPE = 'REAL') REALCOUNT,
	(SELECT COUNT(*) FROM LAB_MATCH_PLAYER WHERE PLAYERID = P.PLAYER_API_ID AND PLAYERTYPE = 'BACKUP') BACKUPCOUNT,
	(SELECT COUNT(DISTINCT LM.TEAMID) FROM LAB_MATCH_PLAYER LM WHERE PLAYERID = P.PLAYER_API_ID) TOTALTEAMCOUNT,
	(SELECT COUNT(*) FROM LAB_MATCH_PLAYER WHERE PLAYERID = P.PLAYER_API_ID) TOTALMATCHCOUNT,
	(SELECT DATEDIFF(YEAR, MIN(DATE_), MAX(DATE_)) FROM LAB_MATCH_PLAYER WHERE PLAYERID = P.PLAYER_API_ID) TOTALSINCE
	FROM LAB_PLAYER P
)
GO

```

Bu ÅŸekilde de fonksiyonumuzu oluÅŸturduk.

Åimdi ise kullanÄ±labilir halde mi kontrol edelim:

```sql
SELECT * FROM DBO.INFO(206592)
```

Bu ÅŸekilde de fonksiyonu Ã§aÄŸÄ±rabiliyoruz. BÃ¶ylelikle sorunu Ã§Ã¶zmÃ¼ÅŸ olduk.

### Stored Procedure

- Birden fazla TSQL kodunun birlikte yazÄ±lÄ±p, sunucu Ã¼zerine derlenerek kaydedildiÄŸi yapÄ±lardÄ±r.
- Stored procedureâ€™lar iÃ§inde TSQL kodlarÄ±nÄ±n tamamÄ± yazÄ±labilir.

Procedureler iÃ§erisinde ÅŸunlar yapÄ±labilir:

- Select, insert, update delete iÅŸlemlerini kullanma
- DeÄŸiÅŸken tanÄ±mlama
- DÃ¶ngÃ¼ oluÅŸturma
- if ÅŸartlarÄ±nÄ± kullanma
- Dosya okuma, veya yazma
- BaÅŸka bir procedureâ€™Ã¼ fonksiyonu ya da viewâ€™i iÃ§inden Ã§aÄŸÄ±rma
- Web servislerine baÄŸlanma
- Temp table kullanma
- Cursor kullanma
- Mail servislerini kullanarak mail gÃ¶nderme

gibi iÅŸlemlerin her birinde yapÄ±labilir. Genelde operasyonel iÅŸlemlerin tamamÄ±nda bu kullanÄ±labilmektedir. Yine aynÄ± ÅŸekilde raporlama ekranlarÄ±nda da kullanÄ±labilmektedir. 

***AD HOC QUERY***

Bir SQL sorgusunu doÄŸrudan SQL Server iÃ§erisine dÃ¶ndÃ¼rÃ¼lÃ¼p kullanÄ±lmasÄ±na ad hoc query denilir. Genel anlamda INSERT, UPDATE, DELETE gibi klasikleÅŸmiÅŸ olan sorgular bu ÅŸekilde kullanÄ±lmaktadÄ±r.

***STORED PROCEDURE OLUÅTURMA***

Bir store procedure oluÅŸturmak, viewâ€™larla benzerlik gÃ¶sterir. Ancak aralarÄ±nda temel olarak farklar vardÄ±r.

```sql
/*
	Bir store procedure oluÅŸturmak view'la benzerlik gÃ¶sterir.
	bir procedure oluÅŸturmak iÃ§in --> CREATE
	bir procedure gÃ¼ncellemek iÃ§in --> ALTER
	bir procedure silmek iÃ§in --> DROP
	kullanÄ±lmaktadÄ±r.
*/

SELECT * FROM SALES

-- bu sorguyu bir procedure olarak oluÅŸturalÄ±m

CREATE PROCEDURE SP_GETSALES
AS
SELECT * FROM SALES 

-- bu ÅŸekilde bir procedure oluÅŸturulur.
----------

-- bir store procedure'Ä±n iki tÃ¼rlÃ¼ Ã§aÄŸrÄ±lmasÄ± mÃ¼mkÃ¼ndÃ¼r.
-- birincisi
SP_GETSALES

-- ikincisi ise 
EXEC SP_GETSALES
```

Bu ÅŸekilde oluÅŸturulabilir.

Ancak Ã¶nceden de bahsettiÄŸimiz gibi SPâ€™ler Viewâ€™larla benzerlik gÃ¶sterir demiÅŸtik. AralarÄ±ndaki farklar ise ÅŸu ÅŸekilde aÃ§Ä±klanabilir.

```sql
/*
Temel olarak bir store precedure'Ä±n view'la benzerlik gÃ¶sterdiÄŸini belirtmiÅŸtik. Ancak
aralarÄ±ndaki temel fark ise ÅŸudur:
bir store procedure'a parametre gÃ¶nderemezsin ancak view'a gÃ¶nderebilirsin.
*/

-- Ã¶rnek bir view oluÅŸturalÄ±m:

CREATE VIEW VW_GETSALES
AS
SELECT * FROM SALES 

-- bu view'Ä± ÅŸu ÅŸekilde kullanabiliriz.

SELECT * FROM VW_GETSALES
WHERE BRANCH = 'Ä°STANBUL' -- gÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi parametre atabiliyorum 

-- ancak bir store procedure'a parametre gÃ¶nderemem

-- EXEC SP_GETSALES WHERE BRANCH = 'Ä°STANBUL' (hatalÄ± bir ifade olduÄŸundan dolayÄ± Ã§alÄ±ÅŸmayacaktÄ±r.)

-- bir sp'ye parametreyi ancak gÃ¼ncelleyerek atabiliriz.
```

Bu ÅŸekilde yapÄ± kurulmuÅŸ olur. 

Parametre gÃ¶nderme iÅŸlemi ise ÅŸu ÅŸekildedir:

```sql
-- bir store procedure'a gÃ¼ncellemeyle parametre gÃ¶nderme iÅŸlemi

ALTER PROCEDURE SP_GETSALES
@CITY AS VARCHAR(50) -- procedure'a gÃ¶ndereceÄŸim parametre
AS
SELECT * FROM SALES
WHERE
CITY = @CITY

-- bu parametreli SP'yi ÅŸimdi Ã§aÄŸÄ±ralÄ±m

-- eÄŸer parametresiz Ã§aÄŸÄ±rÄ±rsak
-- EXEC SP_GETSALES -- (Procedure or function 'SP_GETSALES' expects parameter '@CITY', which was not supplied.)

-- parametreli olarak Ã§aÄŸÄ±ralÄ±m
EXEC SP_GETSALES 'BURSA' -- bursa kayÄ±tlarÄ± gelir.
EXEC SP_GETSALES 'Ä°ZMÄ°R' -- Ä°ZMÄ°R KAYITLARI GELÄ°R
```

Bu ÅŸekilde SPâ€™lere parametre gÃ¶nderilebilir.

SPâ€™ler sadece bir adet parametreyle Ã§alÄ±ÅŸmayabilir. Birden fazla parametreyle de Ã§alÄ±ÅŸabilir. 

Bu durumu ise ÅŸu ÅŸekilde aÃ§Ä±klayabiliriz:

```sql
-- ST'lere birden fazla da parametre atÄ±labilir.
-- Ã¶rneÄŸin begdate ve enddate parametreleri atalÄ±m

ALTER PROCEDURE SP_GETSALES
@CITY AS VARCHAR(50), -- procedure'a gÃ¶ndereceÄŸim parametre
@BEGDATE AS DATE, -- ikinci parametre
@ENDDATE AS DATE -- Ã¼Ã§Ã¼ncÃ¼ parametre
AS
SELECT * FROM SALES
WHERE
CITY = @CITY
AND
DATE_ BETWEEN @BEGDATE AND @ENDDATE -- ikinci ÅŸart  

-- gÃ¼ncellenmiÅŸ Ã§ok parametreli SP'yi Ã§aÄŸÄ±rma
EXEC SP_GETSALES 'Ä°STANBUL', '20190802','20190906'
```

Bu ÅŸekilde de parametreleri gÃ¶ndermiÅŸ olduk.

Burada Ã¶nemli olan noktalardan bir tanesi ise parametrelerin ya doÄŸru sÄ±rada ya da deÄŸiÅŸkenlerin isimleri Ã¶nceden belirtilerek gÃ¶nderilmesidir. DiÄŸer tÃ¼rlÃ¼ yapÄ±lacak her iÅŸlemde veri tipi dÃ¶nÃ¼ÅŸtÃ¼rme hatalarÄ± alÄ±nabilmektedir.

```sql
-- SP'lerde parametreler doÄŸru sÄ±rada gÃ¶nderilmelidir.
-- ya da parametre isimleriyle gÃ¶nderilmelidir.
EXEC SP_GETSALES @BEGDATE = '20190802', @ENDDATE = '20190906', @CITY = 'Ä°STANBUL' -- bu ÅŸekilde de Ã§alÄ±ÅŸabilmektedir.
```

Bu ÅŸekilde de gÃ¶nderilerek daha dÃ¼zgÃ¼n procedureâ€™lar yazÄ±labilmektedir.

***DEFAULT DEÄERE SAHÄ°P STORED PROCEDURE OLUÅTURMA***

SPâ€™lere parametreler gÃ¶nderilmediÄŸinde hatalar alÄ±nabildiÄŸinden bahsetmiÅŸtik. EÄŸer ki parametreler default olarak tanÄ±mlanÄ±rsa hatalar alÄ±nmadan da iÅŸlemlere devam edilebilir.

```sql
-- bazen procedure'lara parametre gÃ¶ndermeyebiliriz. Ä°ÅŸte bu gÃ¶nderilme durumunu ise default parametrelerle gÃ¶nderebiliriz.

ALTER PROCEDURE SP_GETSALES
@CITY AS VARCHAR(50) = 'Ä°ZMÄ°R',
@BEGDATE DATE,
@ENDDATE DATE
AS
SELECT * FROM SALES
WHERE CITY = @CITY AND 
DATE_ BETWEEN @BEGDATE AND @ENDDATE 

-- Ã¶rneÄŸin ÅŸehir yerine herhangi bir deÄŸer girilmediÄŸinde tÃ¼m ÅŸehirleri getirmesini isteyelim:

ALTER PROCEDURE SP_GETSALES
@CITY AS VARCHAR(50) = '%',
@BEGDATE DATE,
@ENDDATE DATE
AS
SELECT * FROM SALES
WHERE CITY LIKE @CITY AND 
DATE_ BETWEEN @BEGDATE AND @ENDDATE 
```

Bu ÅŸekilde parametre gÃ¶nderilmeden ÅŸehir deÄŸiÅŸkenini manipÃ¼le ettik. EÄŸer ki ÅŸehir deÄŸiÅŸkeni iÃ§erisinde deÄŸer girilmezse bÃ¼tÃ¼n ÅŸehirleri bize listeleyecektir.

```sql
-- default parametreli sorgu
EXEC SP_GETSALES @BEGDATE = '20190618', @ENDDATE = '20190718' --, @CITY = 'Ä°STANBUL' (parametre default olarak gÃ¶nderildiÄŸi iÃ§in hata alÄ±nmaz)

-- default parametreli % sorgusu
-- default deÄŸerinde % olduÄŸu iÃ§in eÄŸer ÅŸehir parametresi girilmezse tÃ¼m ÅŸehirleri getirir.
EXEC SP_GETSALES @BEGDATE = '20190618', @ENDDATE = '20190718'
```

Bu ÅŸekilde tÃ¼m ÅŸehirleri bize listeleyecektir.

Bir de tarih deÄŸiÅŸkenlerine default deÄŸerler tanÄ±mlayalÄ±m:

```sql
-- tarih deÄŸiÅŸkenleriyle oynayalÄ±m
-- tarih deÄŸiÅŸkenleri eÄŸer girilmezse hata almayalÄ±m null girelim
ALTER PROCEDURE SP_GETSALES
@CITY AS VARCHAR(50) = '%',
@BEGDATE DATE = NULL,
@ENDDATE DATE = NULL
AS
SELECT * FROM SALES
WHERE CITY LIKE @CITY AND 
DATE_ BETWEEN @BEGDATE AND @ENDDATE 
```

Bu ÅŸekilde eÄŸer tarih deÄŸerleri SP Ã§aÄŸÄ±rÄ±lÄ±rken getirtilmezse hata alÄ±nmadan Ã§alÄ±ÅŸmaya devam edecektir.

```sql
-- default deÄŸeri null olan date verilerine bi bakalÄ±m
EXEC SP_GETSALES -- hata alÄ±nmadÄ± ama veri de alÄ±nmadÄ±
```

Bu ÅŸekilde sorgu Ã§alÄ±ÅŸmaya devam edecektir.

Ã–nceden de bahsettiÄŸimiz gibi SPâ€™ler iÃ§erisinde TSQL sorgularÄ± yazabiliriz. Ä°ÅŸte bu sorgularÄ±n yazÄ±lmÄ±ÅŸ hali aÅŸaÄŸÄ±dadÄ±r:

```sql
-- Ã¶nceden de bahsettiÄŸimiz gibi store procedure'larda TSQL kodlarÄ± yazabilirdik.
-- Buna gÃ¶re tarih girilmediÄŸi zaman ilk Ã¼Ã§ aylÄ±k verileri aldÄ±ralÄ±m
ALTER PROCEDURE SP_GETSALES
@CITY AS VARCHAR(50) = '%',
@BEGDATE DATE = NULL,
@ENDDATE DATE = NULL
AS
-- tarih deÄŸeri boÅŸ girilmiÅŸse ilk Ã¼Ã§ aylÄ±k yapÄ±yÄ± getirir.
SET @ENDDATE = ISNULL(@ENDDATE, '20190401') -- bu da ikinci bir yÃ¶ntem if kullanmadan yapÄ±labilir.
IF @BEGDATE IS NULL
	SET @BEGDATE = '20190101'

SELECT * FROM SALES
WHERE CITY LIKE @CITY AND 
DATE_ BETWEEN @BEGDATE AND @ENDDATE 
ORDER BY DATE_
```

EÄŸer ki tarih verisi girilmemiÅŸse null olduÄŸundan Ã¶tÃ¼rÃ¼ bize ilk Ã¼Ã§ aylÄ±k verileri listeleyecektir.

```sql
-- default tarih deÄŸeri girildiÄŸi iÃ§in aÅŸaÄŸÄ±daki sorgu Ã§alÄ±ÅŸacaktÄ±r.
EXEC SP_GETSALES

-- default deÄŸer girdik diye parametre gÃ¶ndermeye de devam edebiliriz.
EXEC SP_GETSALES @CITY = 'A%'
```

Bu ÅŸekilde sorgu Ã§alÄ±ÅŸmaya devam edecektir.

YukarÄ±da denildiÄŸi gibi default deÄŸer girildi diye herhangi bir parametre giriÅŸi olmayacak anlamÄ±na gelmemektedir. EÄŸer ki parametre girilirse yine aynÄ± ÅŸekilde sorgu istenilen parametreye uygun olarak Ã§alÄ±ÅŸacaktÄ±r. Burada en Ã¶nemli nokta hata vermeden hata yÃ¶netimini saÄŸlamaya Ã§alÄ±ÅŸmaktÄ±r.

***RAISERROR KULLANIMI***

RAISERROR, SQL Server'da hata mesajlarÄ± oluÅŸturmak ve kullanÄ±cÄ±ya Ã¶zel hata mesajlarÄ± iletmek iÃ§in kullanÄ±lan bir komuttur. Bu komut, belirli bir hata durumu tespit edildiÄŸinde kullanÄ±cÄ±ya anlamlÄ± bir geri bildirim saÄŸlamak amacÄ±yla kullanÄ±lÄ±r. RAISERROR, hata mesajÄ±nÄ±n metnini, Ã¶nem derecesini (severity), ve hata durumunu (state) belirlemenize olanak tanÄ±r.

Åimdi bir store procedure oluÅŸturalÄ±m ve raiseerror kullanalÄ±m:

```sql
-- iliÅŸkisel bir sorguyu stored procedure yapalÄ±m

CREATE PROC SP_GETORDERS
@USERNAME VARCHAR(100),
@BEGDATE AS DATETIME,
@ENDDATE AS DATETIME,
@CITY AS VARCHAR(100)
AS
SELECT 
	O.ID, O.DATE_, U.USERNAME_ ,U.NAMESURNAME,
	C.CITY, T.TOWN, D.DISTRICT, A.POSTALCODE, A.ADDRESSTEXT,
	I.ITEMCODE, I.ITEMNAME, I.BRAND, I.CATEGORY1, I.CATEGORY2, I.CATEGORY3, I.CATEGORY4,
	I.UNITPRICE ITEMPRICE, OD.UNITPRICE, OD.AMOUNT, OD.LINETOTAL
FROM ORDERS O
JOIN USERS U ON U.ID = O.USERID
JOIN ADDRESS A ON A.ID = O.ADDRESSID
JOIN CITIES C ON C.ID = A.CITYID
JOIN TOWNS T ON T.ID = A.TOWNID
JOIN DISTRICTS D ON D.ID = A.DISTRICTID
JOIN ORDERDETAILS OD ON OD.ORDERID = O.ID
JOIN ITEMS I ON I.ID = OD.ITEMID
WHERE U.USERNAME_ LIKE @USERNAME AND
O.DATE_ BETWEEN @BEGDATE AND @ENDDATE
AND C.CITY LIKE @CITY
```

Bu ÅŸekilde bir iliÅŸkisel tablolar arasÄ±nda bir store procedure oluÅŸturduk.

```sql
-- iliÅŸkisel sorguyla oluÅŸturulmuÅŸ procedure'u Ã§aÄŸÄ±rma
EXEC SP_GETORDERS
@USERNAME = '%',
@BEGDATE = '20190501',
@ENDDATE = '20190531',
@CITY = 'BURSA'
```

Bu ÅŸekilde de spâ€™mizi Ã§alÄ±ÅŸtÄ±rdÄ±k.

Åimdi ise kullanÄ±cÄ±yÄ± uyaracak bir raiserrorâ€™lu bir yapÄ± haline getirelim

```sql
-- Ã¶rneÄŸin kullanÄ±cÄ±yÄ± en fazla 3 aylÄ±k bir aralÄ±kta deÄŸer girmesine zorlayalÄ±m fazlasÄ± olursa hata versin

ALTER PROC SP_GETORDERS
@USERNAME VARCHAR(100),
@BEGDATE AS DATETIME,
@ENDDATE AS DATETIME,
@CITY AS VARCHAR(100)
AS
IF DATEDIFF(MONTH, @BEGDATE, @ENDDATE) > 3 -- Ã¼Ã§ aylÄ±k uyarÄ± kÄ±smÄ±
BEGIN
	RAISERROR('LÃ¼tfen 3 aydan daha kÄ±sa bir aralÄ±k giriniz!',16,1) -- hatayÄ± verir ama programÄ± durdurmaz verileri getirmeye devam eder
	RETURN -- bu eÄŸer girilirse hata programÄ± kÄ±rarak durdurur
END
SELECT 
	O.ID, O.DATE_, U.USERNAME_ ,U.NAMESURNAME,
	C.CITY, T.TOWN, D.DISTRICT, A.POSTALCODE, A.ADDRESSTEXT,
	I.ITEMCODE, I.ITEMNAME, I.BRAND, I.CATEGORY1, I.CATEGORY2, I.CATEGORY3, I.CATEGORY4,
	I.UNITPRICE ITEMPRICE, OD.UNITPRICE, OD.AMOUNT, OD.LINETOTAL
FROM ORDERS O
JOIN USERS U ON U.ID = O.USERID
JOIN ADDRESS A ON A.ID = O.ADDRESSID
JOIN CITIES C ON C.ID = A.CITYID
JOIN TOWNS T ON T.ID = A.TOWNID
JOIN DISTRICTS D ON D.ID = A.DISTRICTID
JOIN ORDERDETAILS OD ON OD.ORDERID = O.ID
JOIN ITEMS I ON I.ID = OD.ITEMID
WHERE U.USERNAME_ LIKE @USERNAME AND
O.DATE_ BETWEEN @BEGDATE AND @ENDDATE
AND C.CITY LIKE @CITY
```

EÄŸer ki girilen date tÃ¼rÃ¼ndeki deÄŸerler 3 aydan daha fazla bir sÃ¼reye sahipse program hata alacaktÄ±r. 

Burada Ã¶nemli noktalar ÅŸudur:

```sql
IF DATEDIFF(MONTH, @BEGDATE, @ENDDATE) > 3 -- Ã¼Ã§ aylÄ±k uyarÄ± kÄ±smÄ±
BEGIN
	RAISERROR('LÃ¼tfen 3 aydan daha kÄ±sa bir aralÄ±k giriniz!',16,1) -- hatayÄ± verir ama programÄ± durdurmaz verileri getirmeye devam eder
	RETURN -- bu eÄŸer girilirse hata programÄ± kÄ±rarak durdurur
END
```

ÅŸart bloklarÄ±nÄ±n iÃ§erisinde yazÄ±lan raise error ifadesi bize durumuna gÃ¶re program hata kodunu ve mesajÄ±nÄ± iletir. Burada eÄŸer `RETURN` ifadesi girilmezse program Ã§alÄ±ÅŸÄ±r, verileri getirir sonra hata mesajÄ±nÄ± verir. Ancak `RETURN` ifadesi girilirse program Ã§alÄ±ÅŸmadan hata olarak kendini durdurur.

Åimdi bu sorguyu Ã§alÄ±ÅŸtÄ±ralÄ±m:

```sql
-- raiserror'lu sorguyu deneyelim
EXEC SP_GETORDERS
@USERNAME = '%',
@BEGDATE = '20190501',
@ENDDATE = '20190930',
@CITY = 'BURSA'
```

YukarÄ±da girilen tarih tÃ¼rÃ¼ndeki veriler 3 aydan daha uzun sÃ¼reyi ifade ettiÄŸi iÃ§in program `return` girildiÄŸi iÃ§in durur ve hata mesajÄ± aÅŸaÄŸÄ±daki gibidir.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%205.png)

Bu ÅŸekilde client tarafÄ±nda bir `try/catch` hata yÃ¶netim bloklarÄ±yla programÄ±n Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸÄ±lmadÄ±ÄŸÄ±nÄ± kontrol etmeye olanak saÄŸlamaktadÄ±r.

***INSERT INTO EXEC***

Stored procedureâ€™larda deÄŸiÅŸiklik yapmak bazen yetkinlik isteyen veya bu procedureâ€™Ä± kullanan bazÄ± yapÄ±larda deÄŸiÅŸiklik yapmasÄ±nÄ± gerektirdiÄŸi iÃ§in problemli olabilir. Bundan dolayÄ± da ise stored procedureâ€™larÄ±n her birini ayrÄ± bir tablo haline getirip ayrÄ± ayrÄ± iÅŸlemler gerÃ§ekleÅŸtirmek gÃ¶rece daha kolay olabilir. Ä°ÅŸte bu durumu Ã§Ã¶zebilmemiz iÃ§in insert into exec yapÄ±sÄ±nÄ± kullanÄ±rÄ±z.

Ã–ncelikle SPâ€™ye gÃ¶re Ã¶zelleÅŸtirilmiÅŸ tablo yapÄ±sÄ±nÄ± CREATE TABLE diyerek oluÅŸturalÄ±m:

```sql
-- bazen SP'lerde deÄŸiÅŸiklik yapmaya yetkimiz olmayabilir
-- ancak belirli bir koÅŸulda verileri Ã¶rneÄŸin markasÄ± 'falÄ±m' olan Ã¼rÃ¼nleri getirmemiz gerekebilir
-- sp'lerde where koÅŸulu kullanamadÄ±ÄŸÄ±mÄ±z iÃ§in bunlarÄ± ayrÄ± bir tablo iÃ§erisinde kurgulamak daha kolaydÄ±r.

-- tabloyu oluÅŸturalÄ±m
CREATE TABLE RESULT (
ID INT, DATE_ DATETIME, USERNAME_ VARCHAR(100),
NAMESURNAME VARCHAR(100), CITY VARCHAR(100),
TOWN VARCHAR(100), DISTRICT VARCHAR(100),
POSTALCODE VARCHAR(100), ADDRESSTEXT VARCHAR(100),
ITEMCODE VARCHAR(100), ITEMNAME VARCHAR(100),
BRAND VARCHAR(100), CATEGORY1 VARCHAR(100),
CATEGORY2 VARCHAR(100), CATEGORY3 VARCHAR(100),
CATEGORY4 VARCHAR(100), ITEMPRICE FLOAT, 
UNITPRICE FLOAT, AMOUNT INT, LINETOTAL FLOAT
)
```

Bu ÅŸekilde tablomuzu oluÅŸturduk.

Åimdi bu tablomuzun iÃ§erisine spâ€™nin Ã¶zelleÅŸtirdiÄŸi verileri ekleyelim.

Bu durum iÃ§in `INSERT INTO â€˜tablo_ismiâ€™ EXEC â€˜SP_ismiâ€™` ÅŸeklinde kurgulayabiliriz.

```sql
-- burada sÄ±rasÄ± ve veri tiplerinin aynÄ± olmasÄ± gerekir.
INSERT INTO RESULT

EXEC SP_GETORDERS
@USERNAME = '%',
@BEGDATE = '20190501',
@ENDDATE = '20190531',
@CITY = 'Ä°STANBUL'
```

Bu ÅŸekilde tablo iÃ§erisine SPâ€™nin verilerini eklemiÅŸ olduk.

Bu tabloyu klasikleÅŸmiÅŸ SQL tablo sorgularÄ± gibi kullanabiliriz.

```sql
-- tabloyu getirtelim

SELECT * FROM RESULT 

-- Ã¶zelleÅŸtirerek getirtelim

SELECT * FROM RESULT WHERE BRAND = 'ULKER'
```

Bu ÅŸekilde kullanÄ±m sÃ¶z konusudur.

Ä°ÅŸlem bittikten sonra tabloyu silebiliriz.

```sql
-- tabloyu tekrardan silelim
DROP TABLE RESULT
```

Bu ÅŸekilde de tabloyu silebiliriz.

Bu tip iÅŸlemlerde sÃ¼rekli olarak tablolar oluÅŸturmak silmek hafÄ±zaya yÃ¼k olmakla beraber yine aynÄ± bir veri tabanÄ± uzmanÄ±yla aynÄ± anda iÅŸlemler gerÃ§ekleÅŸtiriyorsanÄ±z Ã§akÄ±ÅŸmalara neden olacaktÄ±r. Ä°ÅŸte bu Ã§akÄ±ÅŸmalarÄ± Ã¶nlemek iÃ§in ise temp table kullanÄ±lÄ±r.

Åimdi temp table olarak tabloyu tekrardan oluÅŸturalÄ±m

```sql
-- sÃ¼rekli olarak tablolar oluÅŸturmak hafÄ±zada yÃ¼k olmakla beraber
-- aynÄ± zamanda baÅŸka zamanda aynÄ± tablo isminde Ã§Ä±ktÄ±lar oluÅŸturmak Ã§akÄ±ÅŸmalara sebep olacaktÄ±r.
-- bundan Ã¶tÃ¼rÃ¼ de bu durumu aÅŸabilmek iÃ§in temp table kullanÄ±lÄ±r.

-- temp table (#) ifadesi geÃ§ici olarak oluÅŸturulur ve oturum kapandÄ±ÄŸÄ± zaman yapÄ±lan iÅŸlemlerin tamamÄ±nÄ± silmeye olanak saÄŸlayan bir yapÄ±dÄ±r.
-- ÅŸimdi aynÄ± iÅŸlemi temp table kullanarak yapalÄ±m

-- tabloyu oluÅŸturalÄ±m
CREATE TABLE #RESULT ( -- # temp table yani geÃ§ici tablo oluÅŸturma
ID INT, DATE_ DATETIME, USERNAME_ VARCHAR(100),
NAMESURNAME VARCHAR(100), CITY VARCHAR(100),
TOWN VARCHAR(100), DISTRICT VARCHAR(100),
POSTALCODE VARCHAR(100), ADDRESSTEXT VARCHAR(100),
ITEMCODE VARCHAR(100), ITEMNAME VARCHAR(100),
BRAND VARCHAR(100), CATEGORY1 VARCHAR(100),
CATEGORY2 VARCHAR(100), CATEGORY3 VARCHAR(100),
CATEGORY4 VARCHAR(100), ITEMPRICE FLOAT, 
UNITPRICE FLOAT, AMOUNT INT, LINETOTAL FLOAT
)
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi tabloyu oluÅŸturduk.

Yine aynÄ± ÅŸekilde temp table iÃ§erisine verilerimizi ekleyelim:

```sql
-- SP ile temp table'a ekleme

INSERT INTO #RESULT

EXEC SP_GETORDERS
@USERNAME = '%',
@BEGDATE = '20190501',
@ENDDATE = '20190531',
@CITY = 'Ä°STANBUL'
```

Verilerimizi temp tableâ€™a ekledik.

Verilerimizi getirtelim

```sql
-- temp table getirtme
SELECT * FROM #RESULT
```

Bu ÅŸekilde de verilerimizi listeledik.

<aside>
ğŸ’¡ ***Temp tableâ€™Ä±n en bÃ¼yÃ¼k Ã¶zelliÄŸi, hafÄ±zada geÃ§ici yere sahip olmasÄ± ve oturum sonlandÄ±rÄ±ldÄ±ÄŸÄ±nda ise tablonun da silinip gitmesidir. Bu oturuma baÄŸlÄ±lÄ±k Ã§akÄ±ÅŸmalarÄ± Ã¶nlemektedir.***

</aside>

```sql
-- temp table'Ä± baÅŸka bir sayfada kullanÄ±rsam hata alÄ±rÄ±m
SELECT * FROM #RESULT
```

Bunu baÅŸka bir sayfa aÃ§Ä±p tekrardan orada Ã§alÄ±ÅŸtÄ±rÄ±rsam hata alÄ±rÄ±m.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%206.png)

Temp tableâ€™larÄ± da istediÄŸimiz gibi Ã¶zelleÅŸtirebiliriz.

```sql
-- temp table'Ä± istediÄŸimiz gibi Ã¶zelleÅŸtirebiliriz.

-- Birinci Ã¶rnek:
SELECT * FROM #RESULT WHERE BRAND = 'ULKER'

-- ikinci Ã¶rnek
SELECT BRAND, SUM(UNITPRICE) FROM #RESULT
GROUP BY BRAND
```

Bu ÅŸekilde hem temp table kullanÄ±mÄ±nÄ± hem de stored procedureâ€™larÄ±n istediÄŸimiz where koÅŸulunu kullanarak verilerimizi Ã¶zelleÅŸtirilmiÅŸ ÅŸekilde kullanmayÄ± Ã¶ÄŸrendik.

SÄ±rada alÄ±ÅŸtÄ±rmalarÄ±mÄ±z var.

***ALIÅTIRMA - 1:***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%207.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
-- ÅŸu ÅŸekilde yapÄ±mÄ±zÄ± kurgulayalÄ±m

CREATE PROC SP_GETPLATES
@BRAND AS VARCHAR(100),
@BEGDATE AS DATE,
@ENDDATE AS DATE
AS
SELECT * FROM LAB_PLATES
WHERE
BRAND = @BRAND AND
LICENCEDATE BETWEEN @BEGDATE AND @ENDDATE

--iki farklÄ± ÅŸekilde verileri getirtebiliriz
-- 1.yÃ¶ntem
EXEC SP_GETPLATES 'AUDÄ°', '20150101', '20191231'

-- 2. yÃ¶ntem
EXEC SP_GETPLATES 
@BRAND = 'AUDÄ°', 
@BEGDATE = '20150101',
@ENDDATE = '20191231'

```

Bu ÅŸekilde alÄ±ÅŸtÄ±rmamÄ±zÄ± Ã§Ã¶zmÃ¼ÅŸ olduk.

***ALIÅTIRMA-2:***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%208.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
-- Ã¶ncelikle sorgumuzu oluÅŸturalÄ±m

SELECT 
	C.ID, C.CITYNAME SEHIR, C.POPULATION NUFUS, C.REGION BOLGE,
	COUNT(P.PLATE) ARACSAYISI,
	ROUND(COUNT(P.PLATE) / CONVERT(FLOAT, C.POPULATION),3) KISIBASI_ARACSAYISI
FROM LAB_CITIES C
JOIN LAB_PLATES P ON P.CITYNR = C.ID

GROUP BY C.ID, C.CITYNAME, C.POPULATION, C.REGION

-- ÅŸimdi ise process'i oluÅŸturalÄ±m

CREATE PROC SP_GETVEHICLES
@BRAND AS VARCHAR(100) = '%',
@BEGDATE AS DATE,
@ENDDATE AS DATE,
@REGION AS VARCHAR(200)
AS
SELECT 
	C.ID, C.CITYNAME SEHIR, C.POPULATION NUFUS, C.REGION BOLGE,
	COUNT(P.PLATE) ARACSAYISI,
	ROUND(COUNT(P.PLATE) / CONVERT(FLOAT, C.POPULATION),3) KISIBASI_ARACSAYISI
FROM LAB_CITIES C
JOIN LAB_PLATES P ON P.CITYNR = C.ID
WHERE P.BRAND LIKE @BRAND
AND P.LICENCEDATE BETWEEN @BEGDATE AND @ENDDATE
AND C.REGION IN (SELECT VALUE FROM string_split(@REGION, ','))
GROUP BY C.ID, C.CITYNAME, C.POPULATION, C.REGION

-- iki tane dataset istenilmiÅŸti
ALTER PROC SP_GETVEHICLES
@BRAND AS VARCHAR(100) = '%',
@BEGDATE AS DATE,
@ENDDATE AS DATE,
@REGION AS VARCHAR(200)
AS
SELECT 
	C.ID, C.CITYNAME SEHIR, C.POPULATION NUFUS, C.REGION BOLGE,
	COUNT(P.PLATE) ARACSAYISI,
	ROUND(COUNT(P.PLATE) / CONVERT(FLOAT, C.POPULATION),3) KISIBASI_ARACSAYISI
FROM LAB_CITIES C
JOIN LAB_PLATES P ON P.CITYNR = C.ID
WHERE P.BRAND LIKE @BRAND
AND P.LICENCEDATE BETWEEN @BEGDATE AND @ENDDATE
AND C.REGION IN (SELECT VALUE FROM string_split(@REGION, ','))
GROUP BY C.ID, C.CITYNAME, C.POPULATION, C.REGION

SELECT 
	C.ID, C.CITYNAME SEHIR, C.POPULATION NUFUS, C.REGION BOLGE,
	P.BRAND MARKA,
	COUNT(P.PLATE) ARACSAYISI,
	ROUND(COUNT(P.PLATE) / CONVERT(FLOAT, C.POPULATION),3) KISIBASI_ARACSAYISI
FROM LAB_CITIES C
JOIN LAB_PLATES P ON P.CITYNR = C.ID
WHERE P.BRAND LIKE @BRAND
AND P.LICENCEDATE BETWEEN @BEGDATE AND @ENDDATE
AND C.REGION IN (SELECT VALUE FROM string_split(@REGION, ','))
GROUP BY C.ID, C.CITYNAME, C.POPULATION, C.REGION, P.BRAND
ORDER BY C.ID, P.BRAND
```

Åimdi bu prosedÃ¼rÃ¼ Ã§aÄŸÄ±ralÄ±m:

```sql
-- stored procedure Ã§aÄŸÄ±rma

EXEC SP_GETVEHICLES 
@BRAND = '%',
@BEGDATE = '20000101',
@ENDDATE = '20221231',
@REGION = 'KARADENÄ°Z, AKDENÄ°Z, MARMARA'
```

Bu ÅŸekilde sorun Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-3:***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%209.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
-- Ã¶ncelikle sorgumuzu hazÄ±rlayalÄ±m

ALTER PROC SP_LOGIN
@USERNAME AS VARCHAR(100) = NULL,
@EMAIL AS VARCHAR(100) = NULL,
@PASSWORD AS VARCHAR(50),
@IPADDRESS AS VARCHAR(50)

AS
DECLARE @USERID AS INT
DECLARE @LOGINTYPE AS VARCHAR(100)

IF @USERNAME IS NOT NULL
BEGIN 
	SELECT @USERID = ID FROM LAB_USER WHERE USERNAME_ = @USERNAME AND PASSWORD_ = @PASSWORD
	IF @USERID > 0
	BEGIN
		SET @LOGINTYPE = 'GÄ°RÄ°Å BAÅARILI'
		INSERT INTO LAB_USERLOGIN_LOG (USERID, USERNAME, LOGINTYPE, IPADDRESS, DATE_)
		VALUES (@USERID, @USERNAME, @LOGINTYPE, @IPADDRESS, GETDATE())
	END
	ELSE
	BEGIN
		SET @LOGINTYPE = 'GÄ°RÄ°Å BAÅARISIZ'
		INSERT INTO LAB_USERLOGIN_LOG (USERID, USERNAME, LOGINTYPE, IPADDRESS, DATE_)
		VALUES (@USERID, @EMAIL, @LOGINTYPE, @IPADDRESS, GETDATE())
	END

	SELECT * FROM LAB_USER WHERE USERNAME_ = @USERNAME AND PASSWORD_ = @PASSWORD
END

IF @EMAIL IS NOT NULL
BEGIN
	SELECT @USERID = ID FROM LAB_USER WHERE EMAIL = @EMAIL AND PASSWORD_ = @PASSWORD
	IF @USERID > 0
	BEGIN
		SET @LOGINTYPE = 'GÄ°RÄ°Å BAÅARILI'
		INSERT INTO LAB_USERLOGIN_LOG (USERID, USERNAME, LOGINTYPE, IPADDRESS, DATE_)
		VALUES (@USERID, @USERNAME, @LOGINTYPE, @IPADDRESS, GETDATE())
	END
	ELSE
	BEGIN
		SET @LOGINTYPE = 'GÄ°RÄ°Å BAÅARISIZ'
		INSERT INTO LAB_USERLOGIN_LOG (USERID, USERNAME, LOGINTYPE, IPADDRESS, DATE_)
		VALUES (@USERID, @USERNAME, @LOGINTYPE, @IPADDRESS, GETDATE())
	END

	SELECT * FROM LAB_USER WHERE EMAIL = @EMAIL AND PASSWORD_ = @PASSWORD
END
```

Åimdi bu prosedÃ¼rÃ¼mÃ¼zÃ¼ farklÄ± farklÄ± ÅŸekillerde Ã§aÄŸÄ±ralÄ±m:

```sql
EXEC SP_LOGIN 
@USERNAME = 'S_VLGEN',
@PASSWORD = 4042521,
@IPADDRESS = '136.58.97.214'

-- email parametresiyle gÃ¶nderim saÄŸlama
EXEC SP_LOGIN 
@EMAIL = 'S_VLGEN@sqlegitimbtk.com',
@PASSWORD = 4042521,
@IPADDRESS = '136.58.97.214'

SELECT * FROM LAB_USERLOGIN_LOG
```

Bu ÅŸekilde problemimiz Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

***ALIÅTIRMA-4:***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2010.png)

Bu sorunun Ã§Ã¶zÃ¼mÃ¼ ÅŸu ÅŸekildedir:

```sql
CREATE PROC SP_SALES
@BEGDATE AS DATE,
@ENDDATE AS DATE,
@CITIES AS VARCHAR(200)
AS

SELECT * FROM LAB_SALES
WHERE DATE_ BETWEEN @BEGDATE AND @ENDDATE
AND CITY IN (SELECT VALUE FROM string_split(@CITIES, ','))

ALTER PROC SP_SALES
@BEGDATE AS DATE,
@ENDDATE AS DATE,
@CITIES AS VARCHAR(200)
AS

DECLARE @RESULT AS VARCHAR(1000)
SET @RESULT = 'BEGDATE: '+CONVERT(VARCHAR, @BEGDATE, 104)
SET @RESULT = @RESULT + CHAR(13) -- bir alt satÄ±ra gelsin
SET @RESULT = @RESULT+ 'ENDDATE: '+ CONVERT(VARCHAR, @BEGDATE, 104)
SET @RESULT = @RESULT + CHAR(13) -- bir alt satÄ±ra gelsin
SET @RESULT = @RESULT + 'CITIES: '+ @CITIES

PRINT @RESULT
SELECT @RESULT AS PARAMETER

SELECT 
CATEGORY1 CATEGORY, SUM(TOTALPRICE) TOTALSALE
FROM LAB_SALES
WHERE DATE_ BETWEEN @BEGDATE AND @ENDDATE
AND CITY IN (SELECT VALUE FROM string_split(@CITIES, ','))
GROUP BY CATEGORY1
ORDER BY 2 DESC
```

Åimdi bu prosedÃ¼rÃ¼mÃ¼zÃ¼ Ã§aÄŸÄ±ralÄ±m:

```sql
EXEC SP_SALES 
@BEGDATE = '20190501',
@ENDDATE = '20190601',
@CITIES = 'Ä°STANBUL, ANKARA, KONYA'
```

Bu ÅŸekilde sorunumuz Ã§Ã¶zÃ¼lmÃ¼ÅŸ olur.

### Trigger Nesneleri

Programlama dillerinde aÅŸina olduÄŸumuz â€˜eventlerâ€™ kavramÄ±nÄ±n veri tabanÄ± programlama kÄ±smÄ±ndaki karÅŸÄ±lÄ±ÄŸÄ± triggerâ€™dÄ±r. Triggerlar tÃ¼rkÃ§e karÅŸÄ±lÄ±k olarak tetikleyici anlamÄ±na gelmektedir. Triggerlar veritabanÄ± tablosunda bir iÅŸlem gerÃ§ekleÅŸtiÄŸinde baÅŸka bir iÅŸlemin otomatik olarak gerÃ§ekleÅŸmesi anlamÄ±na gelmektedir.

Burada iÅŸlem olarak kast edilen veri manipÃ¼lasyonlarÄ±dÄ±r. Veri manipÃ¼lasyonlarÄ± ise `INSERT, UPDATE, DELETE` iÅŸlemleridir. YazÄ±lan triggerlar, insert, update ve delete iÅŸlemlerinden sonra otomatik olarak Ã§alÄ±ÅŸan yapÄ±lardÄ±r.

TriggerlarÄ±n iÃ§inde sanal olarak Ã§alÄ±ÅŸan inserted ve deleted tablolarÄ± vardÄ±r.

Inserted tablosu yeni eklenen kaydÄ±n ya da update edildiÄŸinde kaydÄ±n yeni deÄŸerini tutmaktadÄ±r.

Deleted tablosu ise silinen kaydÄ± ya da deÄŸiÅŸtirilen kaydÄ±n eski deÄŸerini tutmaktadÄ±r.

Triggerlar genelde toplam hesaplama, son deÄŸeri alma ya da loglama amacÄ± ile kullanÄ±lÄ±r. Ã–rneÄŸin: Elimizde bulunan stok hareketleri tablosunda her bir Ã¼rÃ¼nÃ¼n stoÄŸun eksi ve hareketlerini alarak toplam stok adetini bulmak gibi kavramlar elde edilebilmektedir.

***INSERTED TRIGGER***

Triggerlara Ã¶nceden de bahsettiÄŸimiz gibi bazÄ± sorgular iÃ§in otomatik olarak Ã§alÄ±ÅŸtÄ±rÄ±labilen yapÄ±lar olduÄŸundan bahsetmiÅŸtik. Bir Ã¶rnek Ã¼zerinden bir tabloya kayÄ±t geldiÄŸi zaman Ã§alÄ±ÅŸabilen bir trigger nesnesi oluÅŸturabiliriz.

Klasik olarak bir veri tabanÄ± tablosuna veri eklediÄŸimizde *(1 row affected)* mesajÄ±nÄ± alÄ±rÄ±z. Bu mesaj tek baÅŸÄ±na gÃ¶nderilerek baÅŸka bir sonuÃ§ gÃ¶sterilmez. Ancak bir trigger yazÄ±ldÄ±ÄŸÄ±nda insert iÅŸlemini takip eden ve iÃ§erisinde bir selected ifadesi Ã§alÄ±ÅŸan bir triggerâ€™la birlikte ekleme yapÄ±lÄ±r yapÄ±lmaz sonuÃ§larÄ± da gÃ¶sterebilmemiz mÃ¼mkÃ¼ndÃ¼r.

Åimdi bir trigger iÅŸlemi gerÃ§ekleÅŸtirelim:

```sql
-- triggerlarda bir database nesnesidir ve bÃ¼tÃ¼n database nesnelerinde olduÄŸu gibi 
-- create ile oluÅŸturulur, alter ile deÄŸiÅŸtirilir ve drop ile silinir.

-- bir trigger oluÅŸturma

CREATE TRIGGER TRGCUSTOMERINSERT
ON CUSTOMERS -- hangi tabloda Ã§alÄ±ÅŸacaÄŸÄ±nÄ± belirtiyoruz.
AFTER INSERT -- insert komutundan sonra Ã§alÄ±ÅŸacaÄŸÄ±nÄ± belirtiyoruz.
AS
BEGIN
-- tablonun iÃ§erisindeki kolon isimlerini bir deÄŸiÅŸkene atayalÄ±m:
DECLARE @ID AS INT
DECLARE @CUSTOMERNAME AS VARCHAR(100)
DECLARE @BIRTHDATE AS DATE
DECLARE @TELNR AS VARCHAR(20)

SELECT @ID = ID, @CUSTOMERNAME = CUSTOMERNAME,
@BIRTHDATE = BIRTHDATE, @TELNR = TELNR FROM inserted -- inserted tablosu var olmayan bir trigger tablosudur girilen verileri otomatik olarak gÃ¶sterim saÄŸlayacaktÄ±r.

SELECT @ID AS ID, @CUSTOMERNAME AS CUSTOMERNAME, @BIRTHDATE AS BIRTHDATE, @TELNR AS TELNR
PRINT 'INSERT Ä°ÅLEMÄ° BAÅARIYLA GERÃ‡EKLEÅTÄ°' -- log mesajÄ±na ise yazÄ± gÃ¶ndererek Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol ediyoruz.
END
```

Bir trigger nesnesi oluÅŸturduk. Åimdi aynÄ± tablo iÃ§erisinde bir insert komutu gÃ¶ndererek sonuÃ§larÄ±na bakalÄ±m:

```sql
INSERT INTO CUSTOMERS(CUSTOMERNAME, BIRTHDATE, TELNR)
VALUES ('Ã–MER SAÄLAM', '1976-09-24', '05441678463')
```

Bu ÅŸekilde bir sorguyu Ã§alÄ±ÅŸtÄ±rdÄ±k ve Ã§Ä±ktÄ±yÄ± inceleyelim:

Burada iki adet Ã§Ä±ktÄ± olacaktÄ±r. Ä°lk olarak trigger iÃ§erisinde bir select ifadesi yazdÄ±ÄŸÄ±mÄ±z iÃ§in tablo gÃ¶zÃ¼kÃ¼rken diÄŸer kÄ±sÄ±mda ise messages yani log kÄ±smÄ±nda ise printâ€™le yazmÄ±ÅŸ olduÄŸumuz *â€œINSERT Ä°ÅLEMÄ° BAÅARIYLA GERÃ‡EKLEÅTÄ°â€* mesajÄ±nÄ± gÃ¶rÃ¼ntÃ¼leyeceÄŸiz.

Birinci Ã§Ä±ktÄ±:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2011.png)

Ä°kinci Ã§Ä±ktÄ±:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2012.png)

Bu ÅŸekilde yapÄ±lar kurgulanabilmektedir.

KÄ±saca triggerlar peÅŸin sÄ±ra bazÄ± sorgularÄ± takip etmektedir. EÄŸer ki gerekli sorgularÄ± yakaladÄ±klarÄ± anda farklÄ± iÅŸlemleri gerÃ§ekleÅŸtirebilecek fonksiyonel bir event de diyebiliriz.

***DELETED TRIGGER***

Deleted triggerÄ±nda ise bir tablodan deÄŸer silindiÄŸi zaman Ã§alÄ±ÅŸmaya tetiklenen trigger yapÄ±sÄ±dÄ±r.

Ã–rnek bir deleted triggerÄ± ÅŸu ÅŸekilde oluÅŸturulur:

```sql
-- trigger'Ä± oluÅŸturalÄ±m
CREATE TRIGGER TRGCUSTOMERDELETE
ON CUSTOMERS -- hangi tablonun triggerÄ±
AFTER DELETE -- bu triggerÄ±n tetikleyicisi delete sorgusu
AS
BEGIN
DECLARE @ID AS INT
DECLARE @CUSTOMERNAME AS VARCHAR(100)
DECLARE @BIRTHDATE AS DATE
DECLARE @TELNR AS VARCHAR(20)

SELECT @ID = ID, @CUSTOMERNAME = CUSTOMERNAME,
@BIRTHDATE = BIRTHDATE, @TELNR = TELNR FROM deleted -- silme iÅŸlemi gerÃ§ekleÅŸtirdiÄŸimiz iÃ§in deleted tablosuna yazacaktÄ±r 

SELECT @ID AS ID, @CUSTOMERNAME AS CUSTOMERNAME, @BIRTHDATE AS BIRTHDATE, @TELNR AS TELNR
PRINT 'DELETE Ä°ÅLEMÄ° BAÅARIYLA GERÃ‡EKLEÅTÄ°!'
END
```

Bu sorguyu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±z zaman yine aynÄ± ÅŸekilde bir deleted sorgusu kullanÄ±ldÄ±ÄŸÄ±nda bir log ekranÄ±na yazÄ± yazacak ve yine aynÄ± ÅŸekilde tabloyu bize getirtecektir.

***UPDATED TRIGGER***

Updated triggerÄ± biraz daha farklÄ±dÄ±r. Burada Ã¶nce update sorgusundan Ã¶nceki tabloyu ve update sorgusundan sonraki tabloyu da getirtilmesi istenildiÄŸi iÃ§in burada iki yÃ¶ntem uygulanmaktadÄ±r.

<aside>
ğŸ’¡ Ä°lk olarak update sorgusundan Ã¶nceki deÄŸerleri tutabilmesi iÃ§in bir OLD_deÄŸiÅŸken isimleri tutulur.

</aside>

<aside>
ğŸ’¡ Son olarak update sorgusundan sonraki deÄŸerleri tutabilmesi iÃ§in bir NEW_deÄŸiÅŸken isimleri tutulur.

</aside>

<aside>
ğŸ’¡ ***Update sorgusundan Ã¶nceki deÄŸerler iÃ§in deleted tablosu kullanÄ±lÄ±r.***

</aside>

<aside>
ğŸ’¡ ***Update sorgusundan sonraki deÄŸerler iÃ§in inserted tablosu kullanÄ±lÄ±r.***

</aside>

Bu bilgiler Ä±ÅŸÄ±ÄŸÄ±nda sorguyu oluÅŸturmak istersek:

```sql
-- update trigger'Ä± oluÅŸturalÄ±m
-- update trigger'Ä±nda hem eski tablo hem de update sorgusundan sonra gÃ¼ncel tablo
-- olduÄŸundan dolayÄ± deÄŸiÅŸkenleri hem eski hem de yeni olarak tanÄ±mlamak gereklidir.
CREATE TRIGGER TRGCUSTOMERUPDATE
ON CUSTOMERS -- hangi tablonun triggerÄ±
AFTER UPDATE -- bu triggerÄ±n tetikleyicisi update sorgusu
AS
BEGIN
DECLARE @ID AS INT -- id sabit olduÄŸu iÃ§in buna eski yeni diye deÄŸiÅŸken tanÄ±mlamaya gerek yoktur
-- update sorgusundan Ã¶nceki tabloyu getirtmek iÃ§in eski deÄŸiÅŸkenler
DECLARE @OLD_CUSTOMERNAME AS VARCHAR(100)
DECLARE @OLD_BIRTHDATE AS DATE
DECLARE @OLD_TELNR AS VARCHAR(20)

-- update sorgusundan sonraki gÃ¼ncel tabloyu getirtmek iÃ§in gÃ¼ncel deÄŸiÅŸkenler
DECLARE @NEW_CUSTOMERNAME AS VARCHAR(100)
DECLARE @NEW_BIRTHDATE AS DATE
DECLARE @NEW_TELNR AS VARCHAR(20)

-- update triggerÄ±nÄ±n eski deÄŸerleri deleted tablosunda tutulur.
SELECT @ID = ID, @OLD_CUSTOMERNAME = CUSTOMERNAME,
@OLD_BIRTHDATE = BIRTHDATE, @OLD_TELNR = TELNR FROM deleted -- update sorgusunun eski deÄŸerleriyle Ã§alÄ±ÅŸma gerÃ§ekleÅŸtirdiÄŸimiz iÃ§in deleted tablosuna yazacaktÄ±r 

-- update triggerÄ±nÄ±n yeni deÄŸerleri inserted tablosunda tutulur.
-- id'yi yukarÄ±da tanÄ±mlandÄ±ÄŸÄ± iÃ§in burada id'ye gerek yoktur.
SELECT  @NEW_CUSTOMERNAME = CUSTOMERNAME,
@NEW_BIRTHDATE = BIRTHDATE, @NEW_TELNR = TELNR FROM inserted -- update sorgusunun eski deÄŸerleriyle Ã§alÄ±ÅŸma gerÃ§ekleÅŸtirdiÄŸimiz iÃ§in inserted tablosuna yazacaktÄ±r 

SELECT @ID AS ID, @OLD_CUSTOMERNAME AS CUSTOMERNAME, @OLD_BIRTHDATE AS BIRTHDATE, @OLD_TELNR AS TELNR, -- update sorgusundan Ã¶nceki deÄŸerleri
@NEW_CUSTOMERNAME AS NEW_CUSTOMERNAME, @NEW_BIRTHDATE AS NEW_BIRTHDATE, @NEW_TELNR AS NEW_TELNR -- update sorgusundan sonraki deÄŸerleri

END
```

Bu ÅŸekilde sorgumuz oluÅŸmuÅŸ olur.

Bu triggerÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in ÅŸÃ¶yle bir update sorgusu yazabiliriz:

```sql
INSERT INTO CUSTOMERS(CUSTOMERNAME, BIRTHDATE,TELNR)
VALUES ('ZEYNEP KARAKAYA', '1998-08-19', '05515674893')

UPDATE CUSTOMERS SET 
CUSTOMERNAME = 'ZEYNEP KURUKAYA',
BIRTHDATE = '2018-09-20',
TELNR = '05674836273'
WHERE ID = 1
```

Bu sorguyu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±z zaman Ã§Ä±ktÄ±mÄ±z ÅŸu ÅŸekilde olacaktÄ±r.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2013.png)

Bu ÅŸekilde update triggerÄ±nÄ±n da Ã§alÄ±ÅŸma prensibini Ã¶ÄŸrenmiÅŸ olduk.

***TRIGGER LOGLAMA - INSERT***

Triggerlarla genellikle loglama iÅŸlemleri gerÃ§ekleÅŸtirilir. Loglama dediÄŸimiz kÄ±sÄ±m veri tabanÄ± Ã¼zerinde verilerde deÄŸiÅŸiklikleri kayÄ±t altÄ±na alÄ±nmasÄ± anlamÄ±na gelmektedir. Loglar genellikle aynÄ± veritabanÄ± iÃ§erisinde tutulmaz farklÄ± veritabanlarÄ± aÃ§Ä±larak onlarÄ±n iÃ§erisine kayÄ±t iÅŸlemi gerÃ§ekleÅŸtirilir.

LOG iÅŸleminin takip edileceÄŸi tablo ile log atÄ±lacak tablo aynÄ± olmak zorundadÄ±r. Bunun iÃ§in ilgili log tutulmak istenilen veri tabanÄ±nÄ±n tablosunun bir scriptini alarak iÅŸlemler gerÃ§ekleÅŸtirilmektedir.

```sql
/*
triggerlar ile genellikle log tutma iÅŸlemleri gerÃ§ekleÅŸtirilir.

bu loglarÄ±n genel olarak iÃ§erikleri:
bir kayÄ±t silindiÄŸinde ya da deÄŸiÅŸtirildiÄŸinde
-> kim tarafÄ±ndan?
-> ne zaman?
-> hangi bilgisayardan?
-> hangi kullanÄ±cÄ± ile?
-> hangi program ile?
-> hangi sql cÃ¼mlesi ile yapÄ±ldÄ±?
-> silinmeden/deÄŸiÅŸtirilmeden Ã¶nceki deÄŸerleri neydi?

gibi birÃ§ok sorular kayÄ±t altÄ±nda tutulur.
*/

-- loglarÄ± tutacaÄŸÄ±m bir database oluÅŸturduk.
-- bu database iÃ§erisinde ise logunu tutmak istediÄŸim veri tabanÄ±nÄ±n da verileri olmasÄ± gereklidir.
-- bu yÃ¼zden dolayÄ± ise buna benzer bir yapÄ±yÄ± Ã§Ä±kartmak gereklidir.
-- bundan dolayÄ± items tablosunun scriptini Ã§Ä±kartmak gereklidir.
SELECT * FROM ITEMS
```

Burada ***ITEMS*** tablosunun bir loglama iÅŸlemlerini takip edeceÄŸim iÃ§in bu tablonun bir adet scriptini alacaÄŸÄ±z. Bu scripti ilgili tabloya sol tÄ±k yaparak aÃ§Ä±lan ekrandan seÃ§imi yapabilirsiniz:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2014.png)

Bu ÅŸekilde scripti aldÄ±ktan sonra log iÃ§in gerekli alanlarÄ± da ekleyip yeni log database iÃ§erisine kaydetmemiz gerekmektedir.

```sql
CREATE TABLE [dbo].[ITEMS](
	[ID] [int] , -- log tutacaÄŸÄ± iÃ§in otomatik artan olmamalÄ±
	[ITEMCODE] [varchar](50) ,
	[ITEMNAME] [varchar](100) ,
	[UNITPRICE] [float] ,
	[CATEGORY1] [varchar](50) ,
	[CATEGORY2] [varchar](50) ,
	[CATEGORY3] [varchar](50) ,
	[CATEGORY4] [varchar](50) ,
	[BRAND] [varchar](50) ,
	-- loglarÄ±n tutulacaÄŸÄ± kÄ±sÄ±mlar
	LOG_ACTIONTYPE  VARCHAR(10), -- triggerÄ± hangi fonksiyon tetikledi
	LOG_DATE  DATETIME, -- ne zaman yapÄ±ldÄ±
	LOG_HOSTNAME VARCHAR(100), -- hangi hosttan gerÃ§ekleÅŸti
	LOG_PROGRAMNAME VARCHAR(100), -- hangi programdan gerÃ§ekleÅŸti
	LOG_USERNAME VARCHAR(100) -- kim tarafÄ±ndan gerÃ§ekleÅŸti
)
```

Burada *ITEMS* tablosunun iÃ§eriÄŸini almakla birlikte log iÃ§in tutacaÄŸÄ±mÄ±z sÃ¼tun isimlerini girerek tabloyu oluÅŸturduk.

***TRIGGER LOGLAMA - UPDATE***

Update loguyla ise veri tabanÄ± iÃ§erisindeki kayÄ±tlarÄ±n eski halini ve ne zaman deÄŸiÅŸtirildiÄŸi, kim tarafÄ±ndan, hangi programlama deÄŸiÅŸtiÄŸi gibi kavramlarÄ± log altÄ±nda tutabiliriz. 

Bunu bir update triggerÄ±yla oluÅŸturalÄ±m:

```sql
-- ÅŸimdi update triggerÄ±nÄ± yazmaya baÅŸlayalÄ±m
CREATE TRIGGER TRG_UPDATEITEMS
ON ITEMS
AFTER UPDATE
AS
BEGIN
	-- loglar iÃ§in bazÄ± Ã¶zellikleri trigger iÃ§erisinde eklememiz gerekir
	-- bunlarÄ± deÄŸiÅŸken iÃ§erisinde triggerda tanÄ±mlayalÄ±m
	DECLARE @LOG_ACTIONTYPE AS VARCHAR(10) = 'UPDATE' -- update iÃ§in Ã§alÄ±ÅŸacaÄŸÄ± iÃ§in bunu otomatik olarak update ayarlamamÄ±z gerekir.
	DECLARE @LOG_DATE AS  DATETIME 
	DECLARE @LOG_HOSTNAME AS VARCHAR(100) 
	DECLARE @LOG_PROGRAMNAME AS VARCHAR(100) 
	DECLARE @LOG_USERNAME AS VARCHAR(100) 

	-- ÅŸimdi bu deÄŸiÅŸkenleri dolduralÄ±m
	SET @LOG_DATE = GETDATE() -- triggerÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± zamanÄ± alÄ±r
	SET @LOG_HOSTNAME = HOST_NAME() -- sqlservera baÄŸlanan makinenin ismini verir.
	SET @LOG_PROGRAMNAME = PROGRAM_NAME() -- SQL servera hangi programa baÄŸlanÄ±ldÄ±ÄŸÄ±nÄ± verir.
	SET @LOG_USERNAME = SUSER_NAME() -- sql servera baÄŸlanan kiÅŸinin ismini verir.

	-- loglama iÅŸlemini yapma (eski kayÄ±tlarÄ± loglama)
	INSERT INTO LOGDB.dbo.ITEMS
	(ID, ITEMCODE, ITEMNAME, UNITPRICE, CATEGORY1, CATEGORY2, CATEGORY3, CATEGORY4,
	BRAND, LOG_ACTIONTYPE, LOG_DATE, LOG_HOSTNAME, LOG_PROGRAMNAME, LOG_USERNAME)

	-- eski kayÄ±tlarÄ± da getireceksin.
	SELECT 
	ID, ITEMCODE, ITEMNAME, UNITPRICE, CATEGORY1, CATEGORY2, CATEGORY3, CATEGORY4, BRAND, 
	@LOG_ACTIONTYPE, @LOG_DATE, @LOG_HOSTNAME, @LOG_PROGRAMNAME, @LOG_USERNAME -- tabloda tanÄ±mlÄ± olmadÄ±ÄŸÄ± iÃ§in buraya ekledik.
	FROM deleted

END
```

Bu ÅŸekilde logu tutacak triggerÄ± yazmÄ±ÅŸ olduk.

Åimdi bu deÄŸeri bi kontrol edelim:

```sql
-- ÅŸimdi triggerÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in bir adet veri Ã§ekip bunun Ã¼zerinde deÄŸiÅŸiklik yapalÄ±m

SELECT * FROM ITEMS WHERE ID = 1

-- fiyat gÃ¼ncelleyelim
UPDATE ITEMS SET UNITPRICE = 12 WHERE ID = 1

-- fiyatÄ± tekrar gÃ¼ncelleyelim
UPDATE ITEMS SET UNITPRICE = 15 WHERE ID = 1
```

Bu ÅŸekilde veriler Ã¼zerinde deÄŸiÅŸiklik yaptÄ±k. 

Åimdi logu tekrar kontrol edelim:

```sql
-- LOGUNA BAKALIM
SELECT * FROM ITEMS
```

LoglarÄ±n tutulduÄŸu tabloyu listeleyelim.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2015.png)

Bu ÅŸekilde loglarÄ±mÄ±z Ã¼rÃ¼nlerin eski fiyatlarÄ±nÄ± tuttuÄŸunu gÃ¶stermiÅŸ oldu.

***TRIGGER LOGLAMA - DELETE***

Ä°lgili tablodan veri silme iÅŸlemi gerÃ§ekleÅŸtirileceÄŸi zaman Ã§alÄ±ÅŸtÄ±rÄ±lacak bir trigger yazalÄ±m ve bunu log tablosu iÃ§erisinde tutalÄ±m:

```sql
-- ÅŸimdi delete triggerÄ±nÄ± yazmaya baÅŸlayalÄ±m
CREATE TRIGGER TRG_DELETEITEMS
ON ITEMS
AFTER DELETE
AS
BEGIN
	-- loglar iÃ§in bazÄ± Ã¶zellikleri trigger iÃ§erisinde eklememiz gerekir
	-- bunlarÄ± deÄŸiÅŸken iÃ§erisinde triggerda tanÄ±mlayalÄ±m
	DECLARE @LOG_ACTIONTYPE AS VARCHAR(10) = 'DELETE' -- DELETE iÃ§in Ã§alÄ±ÅŸacaÄŸÄ± iÃ§in bunu otomatik olarak delete ayarlamamÄ±z gerekir.
	DECLARE @LOG_DATE AS  DATETIME 
	DECLARE @LOG_HOSTNAME AS VARCHAR(100) 
	DECLARE @LOG_PROGRAMNAME AS VARCHAR(100) 
	DECLARE @LOG_USERNAME AS VARCHAR(100) 

	-- ÅŸimdi bu deÄŸiÅŸkenleri dolduralÄ±m
	SET @LOG_DATE = GETDATE() -- triggerÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± zamanÄ± alÄ±r
	SET @LOG_HOSTNAME = HOST_NAME() -- sqlservera baÄŸlanan makinenin ismini verir.
	SET @LOG_PROGRAMNAME = PROGRAM_NAME() -- SQL servera hangi programa baÄŸlanÄ±ldÄ±ÄŸÄ±nÄ± verir.
	SET @LOG_USERNAME = SUSER_NAME() -- sql servera baÄŸlanan kiÅŸinin ismini verir.

	-- loglama iÅŸlemini yapma (eski kayÄ±tlarÄ± loglama)
	INSERT INTO LOGDB.dbo.ITEMS
	(ID, ITEMCODE, ITEMNAME, UNITPRICE, CATEGORY1, CATEGORY2, CATEGORY3, CATEGORY4,
	BRAND, LOG_ACTIONTYPE, LOG_DATE, LOG_HOSTNAME, LOG_PROGRAMNAME, LOG_USERNAME)

	SELECT 
	ID, ITEMCODE, ITEMNAME, UNITPRICE, CATEGORY1, CATEGORY2, CATEGORY3, CATEGORY4, BRAND, 
	@LOG_ACTIONTYPE, @LOG_DATE, @LOG_HOSTNAME, @LOG_PROGRAMNAME, @LOG_USERNAME -- tabloda tanÄ±mlÄ± olmadÄ±ÄŸÄ± iÃ§in buraya ekledik.
	FROM deleted

END
```

Bu ÅŸekilde delete triggerÄ±nÄ± yazmÄ±ÅŸ olduk.

Åimdi ise triggerÄ±mÄ±zÄ± deneyelim:

```sql
SELECT * FROM ITEMS WHERE ID = 1

UPDATE ITEMS SET UNITPRICE = 30 WHERE ID = 1

-- triggerÄ± test edelim:
DELETE FROM ITEMS WHERE ID = 1
```

Bu ÅŸekilde triggerÄ±mÄ±zÄ± tetikledik. 

Åimdi ise bunu log tablosunda gÃ¶rÃ¼ntÃ¼leyelim:

```sql
SELECT * FROM ITEMS
```

Bu ÅŸekilde logumuzu kayÄ±t altÄ±na alÄ±ndÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemiÅŸ olduk.

***UPDATE ve DELETE Ä°ÅLEMLERÄ°NÄ°N BÄ°RLÄ°KTELÄ°ÄÄ°***

Update ve Delete iÅŸlemleri aynÄ± trigger iÃ§erisinde yazÄ±labilir. AÅŸaÄŸÄ±daki kod blogunda bunu gÃ¶rÃ¼ntÃ¼leyebiliriz.

```sql
-- hem silme hem de gÃ¼ncelleme fonksiyonlarÄ±nÄ± yakalayacak bir trigger oluÅŸturalÄ±m

CREATE TRIGGER TRG_UPDATE_DELETE_ITEMS
ON ITEMS
AFTER UPDATE, DELETE -- update ve delete sorgularÄ±nÄ± yakalayacak...
AS
BEGIN
	
	-- yapÄ±lan iÅŸlemin ne olduÄŸunu deÄŸiÅŸkenlere atamamÄ±z gereklidir.

	DECLARE @LOG_ACTIONTYPE AS VARCHAR(10)
	DECLARE @INSERTCOUNT AS INT
	DECLARE @DELETECOUNT AS INT

	SELECT @DELETECOUNT = COUNT(*) FROM deleted
	SELECT @INSERTCOUNT = COUNT(*) FROM inserted

	-- HANGÄ° Ä°ÅLEM OLDUÄUNU YAKALAYALIM

	IF @DELETECOUNT = 0 AND @INSERTCOUNT > 0 -- inserted iÅŸlemini yakalayacak fonksiyon
		SET @LOG_ACTIONTYPE = 'INSERT'
	IF @DELETECOUNT > 0 AND @INSERTCOUNT = 0 -- delete iÅŸlemini yakalayacak
		SET @LOG_ACTIONTYPE = 'DELETE'
	IF @DELETECOUNT > 0 AND @INSERTCOUNT > 0
		SET @LOG_ACTIONTYPE = 'UPDATE'

	DECLARE @LOG_DATE AS  DATETIME 
	DECLARE @LOG_HOSTNAME AS VARCHAR(100) 
	DECLARE @LOG_PROGRAMNAME AS VARCHAR(100) 
	DECLARE @LOG_USERNAME AS VARCHAR(100) 

	-- ÅŸimdi bu deÄŸiÅŸkenleri dolduralÄ±m
	SET @LOG_DATE = GETDATE() -- triggerÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± zamanÄ± alÄ±r
	SET @LOG_HOSTNAME = HOST_NAME() -- sqlservera baÄŸlanan makinenin ismini verir.
	SET @LOG_PROGRAMNAME = PROGRAM_NAME() -- SQL servera hangi programa baÄŸlanÄ±ldÄ±ÄŸÄ±nÄ± verir.
	SET @LOG_USERNAME = SUSER_NAME() -- sql servera baÄŸlanan kiÅŸinin ismini verir.

	-- loglama iÅŸlemini yapma (eski kayÄ±tlarÄ± loglama)
	INSERT INTO LOGDB.dbo.ITEMS
	(ID, ITEMCODE, ITEMNAME, UNITPRICE, CATEGORY1, CATEGORY2, CATEGORY3, CATEGORY4,
	BRAND, LOG_ACTIONTYPE, LOG_DATE, LOG_HOSTNAME, LOG_PROGRAMNAME, LOG_USERNAME)

	SELECT 
	ID, ITEMCODE, ITEMNAME, UNITPRICE, CATEGORY1, CATEGORY2, CATEGORY3, CATEGORY4, BRAND, 
	@LOG_ACTIONTYPE, @LOG_DATE, @LOG_HOSTNAME, @LOG_PROGRAMNAME, @LOG_USERNAME -- tabloda tanÄ±mlÄ± olmadÄ±ÄŸÄ± iÃ§in buraya ekledik.
	FROM deleted

END
```

Åimdi bu triggerÄ±mÄ±zÄ± Ã§alÄ±ÅŸtÄ±ralÄ±m:

```sql
SELECT * FROM ITEMS WHERE ID = 6

UPDATE ITEMS SET UNITPRICE = 50 WHERE ID = 6
UPDATE ITEMS SET UNITPRICE = 60 WHERE ID = 6

DELETE FROM ITEMS WHERE ID = 6

-- log database gÃ¶rÃ¼ntÃ¼lenmesi
SELECT * FROM LOGDB.dbo.ITEMS
```

Bu ÅŸekilde Ã§alÄ±ÅŸmÄ±ÅŸ oldu.

Burada Ã¶nemli olan nokta IF bloklarÄ±yla deleted ve Ä±nserted tablolarÄ±nÄ±n toplam kayÄ±t sayÄ±sÄ±nÄ± takip etmektir. Bu iÅŸlemi gerÃ§ekleÅŸtirdikten sonra istenildiÄŸi gibi trigger Ã¶zelleÅŸtirilebilir.

***TRIGGER LOGLAMA - INSTEAD OF***

Instead of terimi veritabanÄ± loglama kÄ±smÄ±nda Ã§ok fazla kullanÄ±lmaz. YapÄ±lan bir deÄŸiÅŸiklik veritabanÄ± log sayfasÄ±nda tutulmaktadÄ±r ancak gerÃ§ek verilerde herhangi bir deÄŸiÅŸiklik olmaz. 

TriggerÄ±mÄ±zÄ± yazalÄ±m:

```sql
-- bir triggerÄ±mÄ±z ise instead of triggerÄ±dÄ±r.
-- instead triggeri Ã§alÄ±ÅŸtÄ±ÄŸÄ± zaman veride deÄŸiÅŸiklik yapÄ±ldÄ± gibi gÃ¶rÃ¼lÃ¼r ancak,
-- gerÃ§ek veride herhangi bir deÄŸiÅŸme olmaz

ALTER TRIGGER TRG_UPDATE_DELETE_ITEMS
ON ITEMS
INSTEAD OF UPDATE, DELETE -- sorgularÄ± Ã§alÄ±ÅŸtÄ±rmayacaktÄ±r
AS
BEGIN
	
	-- yapÄ±lan iÅŸlemin ne olduÄŸunu deÄŸiÅŸkenlere atamamÄ±z gereklidir.

	DECLARE @LOG_ACTIONTYPE AS VARCHAR(10)
	DECLARE @INSERTCOUNT AS INT
	DECLARE @DELETECOUNT AS INT

	SELECT @DELETECOUNT = COUNT(*) FROM deleted
	SELECT @INSERTCOUNT = COUNT(*) FROM inserted

	-- HANGÄ° Ä°ÅLEM OLDUÄUNU YAKALAYALIM

	IF @DELETECOUNT = 0 AND @INSERTCOUNT > 0 -- inserted iÅŸlemini yakalayacak fonksiyon
		SET @LOG_ACTIONTYPE = 'INSERT'
	IF @DELETECOUNT > 0 AND @INSERTCOUNT = 0 -- delete iÅŸlemini yakalayacak
		SET @LOG_ACTIONTYPE = 'DELETE'
	IF @DELETECOUNT > 0 AND @INSERTCOUNT > 0
		SET @LOG_ACTIONTYPE = 'UPDATE'

	DECLARE @LOG_DATE AS  DATETIME 
	DECLARE @LOG_HOSTNAME AS VARCHAR(100) 
	DECLARE @LOG_PROGRAMNAME AS VARCHAR(100) 
	DECLARE @LOG_USERNAME AS VARCHAR(100) 

	-- ÅŸimdi bu deÄŸiÅŸkenleri dolduralÄ±m
	SET @LOG_DATE = GETDATE() -- triggerÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± zamanÄ± alÄ±r
	SET @LOG_HOSTNAME = HOST_NAME() -- sqlservera baÄŸlanan makinenin ismini verir.
	SET @LOG_PROGRAMNAME = PROGRAM_NAME() -- SQL servera hangi programa baÄŸlanÄ±ldÄ±ÄŸÄ±nÄ± verir.
	SET @LOG_USERNAME = SUSER_NAME() -- sql servera baÄŸlanan kiÅŸinin ismini verir.

	-- loglama iÅŸlemini yapma (eski kayÄ±tlarÄ± loglama)
	INSERT INTO LOGDB.dbo.ITEMS
	(ID, ITEMCODE, ITEMNAME, UNITPRICE, CATEGORY1, CATEGORY2, CATEGORY3, CATEGORY4,
	BRAND, LOG_ACTIONTYPE, LOG_DATE, LOG_HOSTNAME, LOG_PROGRAMNAME, LOG_USERNAME)

	SELECT 
	ID, ITEMCODE, ITEMNAME, UNITPRICE, CATEGORY1, CATEGORY2, CATEGORY3, CATEGORY4, BRAND, 
	@LOG_ACTIONTYPE, @LOG_DATE, @LOG_HOSTNAME, @LOG_PROGRAMNAME, @LOG_USERNAME -- tabloda tanÄ±mlÄ± olmadÄ±ÄŸÄ± iÃ§in buraya ekledik.
	FROM deleted

END
```

Bu ÅŸekilde instead of triggerÄ±mÄ±zÄ± yazdÄ±k. Åimdi item tablosu iÃ§erisinden veri manipÃ¼lasyonlarÄ± gerÃ§ekleÅŸtirelim.

```sql
SELECT * FROM ITEMS WHERE ID = 9

-- deÄŸiÅŸtirmeye Ã§alÄ±ÅŸalÄ±m
UPDATE ITEMS SET UNITPRICE = 65 WHERE ID = 9
UPDATE ITEMS SET UNITPRICE = 70 WHERE ID = 9

DELETE FROM ITEMS WHERE ID = 6

-- log database gÃ¶rÃ¼ntÃ¼lenmesi
SELECT * FROM LOGDB.dbo.ITEMS
```

Bu sorgumuzu adÄ±m adÄ±m inceleyelim:

```sql
SELECT * FROM ITEMS WHERE ID = 9
```

IDâ€™si 9 olan Ã¼rÃ¼nÃ¼ getirttik. 

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2016.png)

Åimdi bu veride fiyatta bir deÄŸiÅŸiklik gerÃ§ekleÅŸtirelim:

```sql
-- deÄŸiÅŸtirmeye Ã§alÄ±ÅŸalÄ±m
UPDATE ITEMS SET UNITPRICE = 65 WHERE ID = 9
UPDATE ITEMS SET UNITPRICE = 70 WHERE ID = 9
```

Bu sorgularÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±z zaman ÅŸÃ¶yle bir ekran gÃ¶rÃ¼ntÃ¼sÃ¼ gÃ¶receÄŸiz.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2017.png)

Yani sorgumuz Ã§alÄ±ÅŸÄ±yor ve veride fiyatÄ± gÃ¼ncellemiÅŸ olmasÄ± gerekidir.

Åimdi gerÃ§ek tablomuzdaki fiyatÄ±mÄ±za bakalÄ±m 65 ve 70 olmuÅŸ mu ?

```sql
SELECT * FROM ITEMS WHERE ID = 9
```

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2018.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi fiyat yenilenmemiÅŸ. Eski kayÄ±t durmaya devam ediyor. Peki log database iÃ§erisindeki log atÄ±lmÄ±ÅŸ mÄ± bide ona bakalÄ±m:

```sql
-- log database gÃ¶rÃ¼ntÃ¼lenmesi
SELECT * FROM LOGDB.dbo.ITEMS
```

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2019.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi loglama yapÄ±lmÄ±ÅŸ ama eski fiyat durmaya devam ediyor.

Ä°ÅŸte instead of triggerÄ± verilerde deÄŸiÅŸiklik yapmaya olanak saÄŸlamaz ama loglama gerÃ§ekleÅŸtirmeye devam eder. Bu ÅŸekilde izinsiz veri deÄŸiÅŸiklikleri Ã¶nlenmiÅŸ olur.

### Index Mimarisi

Veri tabanlarÄ±nÄ±n en Ã¶nemli kÄ±smÄ± veriyi yÃ¶netme kÄ±smÄ±dÄ±r. Veriyi yÃ¶netme kÄ±smÄ±nda en performanslÄ± bir ÅŸekilde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak amacÄ±yla oldukÃ§a fazla karÅŸÄ±laÅŸÄ±lan kavramlarÄ±n baÅŸÄ±nda gelir Index.

Genel ortalamaya baktÄ±ÄŸÄ±mÄ±zda veritabanÄ± yÃ¶netim sistemlerinin %5 oranÄ±nda yazma, %95 oranÄ±nda okuma yaptÄ±ÄŸÄ± gÃ¶rÃ¼lmektedir.

Ä°ÅŸte durum bÃ¶yle olunca okuma performansÄ±nÄ± arttÄ±rmak en Ã§ok yapÄ±lan iÅŸlemlerin baÅŸÄ±na gelmektedir.

***BINARY SEARCH***

Binary search (ikili arama), sÄ±ralÄ± bir veri dizisinde aranan deÄŸeri verimli bir ÅŸekilde bulmak iÃ§in kullanÄ±lan bir algoritmadÄ±r. Arama iÅŸlemi, her adÄ±mda diziyi ikiye bÃ¶lerek hedef deÄŸerin hangi yarÄ±da olduÄŸunu belirlemeye dayanÄ±r. Bu sayede, her adÄ±mda arama alanÄ± yarÄ±ya indirilir.

**AdÄ±m AdÄ±m AÃ§Ä±klama:**

1. **Dizinin ortasÄ±nÄ± bul:** Dizinin baÅŸÄ± ve sonu arasÄ±nda bir orta nokta belirlenir.
2. **Ortadaki elemanÄ± kontrol et:**
    - EÄŸer ortadaki eleman aranan deÄŸer ise, arama tamamlanÄ±r.
    - EÄŸer aranan deÄŸer ortadaki elemandan kÃ¼Ã§Ã¼kse, dizinin sol yarÄ±sÄ±nda arama yapÄ±lÄ±r.
    - EÄŸer aranan deÄŸer ortadaki elemandan bÃ¼yÃ¼kse, dizinin saÄŸ yarÄ±sÄ±nda arama yapÄ±lÄ±r.
3. **AdÄ±mlarÄ± tekrarla:** Dizi ikiye bÃ¶lÃ¼ndÃ¼kten sonra, arama iÅŸlemi kalan yarÄ± dizide tekrar edilir.

Bu sÃ¼reÃ§, hedef deÄŸer bulunana ya da arama alanÄ± kalmayana kadar devam eder.

**Ã–rnek:**

Åu sÄ±ralÄ± dizi iÃ§inde `7` sayÄ±sÄ±nÄ± arayalÄ±m:

`[1, 3, 5, 7, 9, 11, 13]`

1. Dizinin ortasÄ±nda `7` sayÄ±sÄ± var mÄ± diye bakalÄ±m.
    - Dizinin ortasÄ±: `9` (dizideki eleman sayÄ±sÄ± 7, ortadaki eleman: 4. pozisyondaki `9`).
    - `7 < 9`, yani sol yarÄ±da aramaya devam ederiz: `[1, 3, 5, 7]`.
2. Åimdi bu alt dizinin ortasÄ±na bakalÄ±m:
    - Ortadaki eleman: `5`.
    - `7 > 5`, bu sefer saÄŸ yarÄ±da aramaya devam ederiz: `[7]`.
3. Kalan dizinin tek elemanÄ± `7` ve aranan deÄŸer bulundu!

Bu yÃ¶ntem, her adÄ±mda diziyi ikiye bÃ¶ldÃ¼ÄŸÃ¼ iÃ§in, Ã¶zellikle bÃ¼yÃ¼k veri setlerinde oldukÃ§a verimlidir. Binary search'Ã¼n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(log n) olarak ifade edilir, yani dizinin boyutu bÃ¼yÃ¼dÃ¼kÃ§e iÅŸlem sÃ¼resi Ã§ok yavaÅŸ artar.

<aside>
ğŸ’¡

Burada binary search yapÄ±labilmesi iÃ§in en Ã¶nemli kÄ±sÄ±m verilerin indexlenmiÅŸ olmasÄ±dÄ±r. Ä°ndexten kastÄ±mÄ±z sayÄ±sal deÄŸerse bÃ¼yÃ¼kten kÃ¼Ã§Ã¼ÄŸe doÄŸru, alfabetik bir karakterse alfabetik sÄ±raya gÃ¶re aranmasÄ± gereklidir. Bu ÅŸekilde veritabanlarÄ±nda sorgusal yÃ¶netim performanslarÄ± oldukÃ§a arttÄ±rÄ±lmÄ±ÅŸ olmaktadÄ±r.

</aside>

![BaÅŸlÄ±ksÄ±z Diyagram.drawio.svg](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/Balksz_Diyagram.drawio.svg)

YukarÄ±da verilen Ã¶rnekte bir 5000 veri kapasitesine sahip bir verinin binary search kullanarak nasÄ±l 12 kademede bulunduÄŸu gÃ¶rselleÅŸtirilmiÅŸtir. Burada eÄŸer binary search kullanÄ±lmadan araÅŸtÄ±rma yapÄ±lsaydÄ± veriler teker teker gezilecek ve 5000 iÅŸlemde bulunabilecekti.

Veri kapasitesi arttÄ±kÃ§a binary iÅŸlem kullanmak zorunlu hale gelir. Åu tabloyu bir inceleyin.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2020.png)

Bu Ã¶rnek tabloda veri sayÄ±sÄ± arttÄ±kÃ§a iÅŸlem gÃ¼cÃ¼nÃ¼n ne kadar arttÄ±ÄŸÄ±nÄ± gÃ¶stermektedir. Nitekim Ã¶rnek incelendiÄŸinde 1 milyarlÄ±k bir veride 30 iÅŸlemde aranan verinin bulunduÄŸu gÃ¶sterilmektedir.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2021.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi arama performansÄ±na oldukÃ§a bÃ¼yÃ¼k bir faydasÄ± vardÄ±r.

***TABLE SCAN***

Table scan kavramÄ± oldukÃ§a basit bir kavramdÄ±r. Ä°ndekslenmemiÅŸ bir veri tabanÄ±nda arama yapÄ±lacaÄŸÄ± zaman sayfalarÄ± rastgele 8kbâ€™Ä± geÃ§meyecek derecede sayfa sayfa oluÅŸturulur ve arama iÅŸlemi o ÅŸekilde gerÃ§ekleÅŸir.

Ã–rnek kodlara bakalÄ±m:

```sql
SELECT * FROM CUSTOMERS

-- toplam kaÃ§ adet veri var?

SELECT COUNT(*) FROM CUSTOMERS -- 2.511.833 adet kayÄ±tlÄ± veri

/*
	Bu tip sorgularda table scan iÅŸlemi yapÄ±lÄ±r.
	bu sorgunun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±na dair bir bilgi almak istiyorsanÄ±z
	sorgudan sonra ctrl+L kombinasyonlarÄ±na tÄ±klayarak bakabilirsiniz.
*/
/*
	table scan iÅŸlemi iÅŸlemciyi ve hafÄ±zayÄ± oldukÃ§a yoran bir araÅŸtÄ±rma iÅŸlemidir.
	table scan iÅŸleminde 8kb pages oluÅŸturulur. ve sayfalar arasÄ±nda rastgele araÅŸtÄ±rma yapÄ±lÄ±r.
	index yoktur rastgele sayfalar oluÅŸturma olur.
*/

SELECT * FROM CUSTOMERS
WHERE
NAMESURNAME = 'Ã–MER Ã‡OLAKOÄLU' 

/*
	 mssql'de ne kadarlÄ±k okuma yaptÄ±ÄŸÄ±nÄ± ve
	 ne kadarlÄ±k sÃ¼re kullandÄ±ÄŸÄ±nÄ± ÅŸu ÅŸekilde Ã¶ÄŸrenebiliriz.
*/
SET STATISTICS IO ON -- ne kadarlÄ±k io yani okuma yaptÄ±? -- 30938
SET STATISTICS TIME ON -- ne kadar sÃ¼re harcadÄ±?
SELECT * FROM CUSTOMERS
WHERE
NAMESURNAME = 'Ã–MER Ã‡OLAKOÄLU' 

-- bir tablonun hafÄ±zada ne kadar yer kapladÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek istiyorsak
SP_SPACEUSED CUSTOMERS -- (KB)247720/1024 = 241 MB
```

Åimdi bu sorgu satÄ±rlarÄ±nÄ± teker teker ele alalÄ±m:

```sql
/*
	Bu tip sorgularda table scan iÅŸlemi yapÄ±lÄ±r.
	bu sorgunun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±na dair bir bilgi almak istiyorsanÄ±z
	sorgudan sonra ctrl+L kombinasyonlarÄ±na tÄ±klayarak bakabilirsiniz.
*/
/*
	table scan iÅŸlemi iÅŸlemciyi ve hafÄ±zayÄ± oldukÃ§a yoran bir araÅŸtÄ±rma iÅŸlemidir.
	table scan iÅŸleminde 8kb pages oluÅŸturulur. ve sayfalar arasÄ±nda rastgele araÅŸtÄ±rma yapÄ±lÄ±r.
	index yoktur rastgele sayfalar oluÅŸturma olur.
*/

SELECT * FROM CUSTOMERS
WHERE
NAMESURNAME = 'Ã–MER Ã‡OLAKOÄLU' 
```

Bu tip klasik sorgularda indexleme yapÄ±lmamÄ±ÅŸsa eÄŸer yani bir primary key yoksa table scan iÅŸlemi yapÄ±lÄ±r. Bu iÅŸlemi nasÄ±l gÃ¶rÃ¼ntÃ¼lendiÄŸini aÅŸaÄŸÄ±dan gÃ¶rÃ¼ntÃ¼leyebilirsin.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2022.png)

Table scan iÅŸleminin rastgele verileri 8kbâ€™Ä± geÃ§meyecek derecede kÃ¼Ã§Ã¼k sayfalara ayÄ±rÄ±p bu ÅŸekilde iÅŸlemler yaptÄ±ÄŸÄ±nÄ± sÃ¶ylemiÅŸtik.

Åimdi gelin bu iÅŸlemde ne kadar sÃ¼re harcanmÄ±ÅŸ ve ne kadarlÄ±k veri okunmuÅŸ bakalÄ±m:

```sql
/*
	 mssql'de ne kadarlÄ±k okuma yaptÄ±ÄŸÄ±nÄ± ve
	 ne kadarlÄ±k sÃ¼re kullandÄ±ÄŸÄ±nÄ± ÅŸu ÅŸekilde Ã¶ÄŸrenebiliriz.
*/
SET STATISTICS IO ON -- ne kadarlÄ±k io yani okuma yaptÄ±? -- 30938
SET STATISTICS TIME ON -- ne kadar sÃ¼re harcadÄ±?
SELECT * FROM CUSTOMERS
WHERE
NAMESURNAME = 'Ã–MER Ã‡OLAKOÄLU' 
```

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2023.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi bu sorgular neticesinde 3ms gibi hÄ±zlÄ± bir sonuÃ§la veriyi dÃ¶ndÃ¼rmÃ¼ÅŸ ancak bununla birlikte sorguyu getirmek iÃ§in ise 30.938 veri okumuÅŸ.

Bu veri sayÄ±sÄ± gÃ¶ze az gelse de veri sayÄ±sÄ± arttÄ±kÃ§a ve veritabanÄ± sunucusuna gÃ¶nderilecek sorgular neticesinde bunlarÄ±n her biri ayrÄ± ayrÄ± yÃ¼k olmaya baÅŸlamaktadÄ±r. Bundan dolayÄ± da indekslemeler yapmak gereklidir.

Bir tablonun hafÄ±zada ne kadar yer kapladÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek istiyorsak eÄŸer:

```sql
-- bir tablonun hafÄ±zada ne kadar yer kapladÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenmek istiyorsak
SP_SPACEUSED CUSTOMERS -- (KB)247720/1024 = 241 MB
```

Bu ÅŸekilde Ã¶ÄŸrenebiliriz. GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi bu tablonun veritabanÄ± sunucunda tuttuÄŸu alan 241 mbâ€™mÄ±ÅŸ.

EÄŸer bir veri tabanÄ±nda indeksleme yapÄ±lmÄ±ÅŸsa yani bir primary key alanÄ± varsa burada ise kullanacaÄŸÄ± arama yÃ¶ntemi table scan deÄŸil clustered index yÃ¶ntemidir. Bu yÃ¶ntem ise yine aynÄ± ÅŸekilde verileri 8kb sayfalar haline getirir ancak tablolarÄ± rastgele verilerle deÄŸil indeks sayÄ±sÄ±yla beraber alÄ±r.

Ä°ndekslenmiÅŸ ve primary key olan tablo ÅŸu ÅŸekilde Ã§alÄ±ÅŸmaktadÄ±r.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2024.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi iÅŸlem yapÄ±lmÄ±ÅŸtÄ±r. Ancak burada binary search gibi bir arama yapÄ±lmamÄ±ÅŸtÄ±r. Ã‡Ã¼nkÃ¼ sayÄ±sal olarak deÄŸer aramamaktayÄ±z. Karakter verisi aradÄ±ÄŸÄ±mÄ±z iÃ§in bu yÃ¼zden sorgu yine aynÄ± iÅŸlemci gÃ¼cÃ¼nÃ¼ kullanacaktÄ±r.

***NON-CLUSTERED***

Non-clustered index, veritabanÄ± yÃ¶netim sistemlerinde kullanÄ±lan bir indeks tÃ¼rÃ¼dÃ¼r. Bu indeks tÃ¼rÃ¼, tablodaki verilerin fiziksel sÄ±rasÄ±nÄ± deÄŸiÅŸtirmeden, belirli sÃ¼tunlar Ã¼zerinde hÄ±zlÄ± sorgulama yapmayÄ± saÄŸlar.

*Non-clustered Index'in Ã–zellikleri:*

- **Fiziksel SÄ±ra:** Non-clustered index, tablo verilerinin fiziksel sÄ±rasÄ±nÄ± deÄŸiÅŸtirmez. Veriler tablodaki orijinal sÄ±rada kalÄ±r, ancak indeks oluÅŸturulan sÃ¼tunlar iÃ§in bir ayrÄ± yapÄ± (B-tree gibi) oluÅŸturulur.
- **BaÄŸÄ±msÄ±z YapÄ±:** Bu indeks, verilerin tutulduÄŸu ana tablo dÄ±ÅŸÄ±nda ayrÄ± bir yapÄ±dadÄ±r. Bu yapÄ±da, anahtar sÃ¼tunlar ve bu sÃ¼tunlarÄ±n iÅŸaret ettiÄŸi tablo satÄ±rlarÄ±na yÃ¶nelik referanslar (pointerlar) bulunur.
- **Birden Fazla Olabilir:** Bir tabloda birden fazla non-clustered index olabilir. Bu sayede farklÄ± sorgularÄ±n performansÄ± artÄ±rÄ±labilir.
- **Veri EriÅŸimi:** Non-clustered index, Ã¶zellikle belirli bir sÃ¼tun Ã¼zerinde sÄ±k sorgulama yapÄ±ldÄ±ÄŸÄ±nda performansÄ± artÄ±rmak iÃ§in kullanÄ±lÄ±r. Ancak, birden fazla sÃ¼tun Ã¼zerinden sorgu yapÄ±ldÄ±ÄŸÄ±nda veya tÃ¼m satÄ±rlar gerektiÄŸinde, bu indeksin performansÄ± dÃ¼ÅŸebilir.

*Ã–rnek:*

Diyelim ki bir Ã¶ÄŸrenci tablonuz var ve bu tablodaki `StudentID` sÃ¼tunu iÃ§in non-clustered index oluÅŸturmak istiyorsunuz. Bu durumda, SQL veritabanÄ± sistemi, `StudentID` sÃ¼tununu ve her bir `StudentID` iÃ§in tablodaki diÄŸer bilgilerin nerede olduÄŸunu gÃ¶steren bir yapÄ± oluÅŸturur. EÄŸer tablodaki kayÄ±tlar alfabetik sÄ±rayla deÄŸil de kayÄ±t numarasÄ±na gÃ¶re sÄ±ralÄ±ysa, non-clustered index bu sÄ±ralamayÄ± bozmaz. Ama `StudentID` sÃ¼tununa gÃ¶re bir sorgu yapÄ±ldÄ±ÄŸÄ±nda, bu indeks kullanÄ±larak sorgu hÄ±zla sonuÃ§lanÄ±r.

Åimdi bunu bir Ã¶rnekle aÃ§Ä±klayalÄ±m ancak Ã¶ncelikle gelin bir clustered index kuralÄ±m:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2025.png)

Buradan non-clustered index seÃ§ilir.

Ve sonrasÄ±nda aÃ§Ä±lan ekranda hangi alana gÃ¶re indeksleme yapÄ±lacaksa o seÃ§ilir.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2026.png)

Burada biz namesurname alanÄ±nda bir indeksleme yaptÄ±k.

SonuÃ§ olarak performansÄ±nÄ± Ã¶lÃ§ecek olursak:

```sql
SET STATISTICS IO ON -- ne kadarlÄ±k io yani okuma yaptÄ±? -- 6
SET STATISTICS TIME ON -- ne kadar sÃ¼re harcadÄ±?
SELECT * FROM CUSTOMERS
WHERE
NAMESURNAME = 'Ã–MER Ã‡OLAKOÄLU' 
```

CTRL+L kombinasyonuna bi bakalÄ±m:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2027.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi clustered index kullanÄ±lmÄ±ÅŸ. 

Åimdi sorgu performansÄ±na bakalÄ±m:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2028.png)

Sadece 6 sayfa okumuÅŸ. Ã–ncesinde yapÄ±lan araÅŸtÄ±rmada ise 30938 sayfa veri okumuÅŸtu. Clustered indeks sayesinde bu sayÄ± 6â€™ya dÃ¼ÅŸmÃ¼ÅŸ. Bu ÅŸekilde sorgu performansÄ±nÄ± oldukÃ§a iyi bir konuma getirtmiÅŸ olduk.

***KEY LOOKUP***

**Key Lookup**, SQL Server gibi iliÅŸkisel veritabanÄ± yÃ¶netim sistemlerinde, bir sorgu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda karÅŸÄ±laÅŸÄ±lan bir iÅŸlemdir. Ã–zellikle, bir non-clustered index kullanÄ±ldÄ±ÄŸÄ±nda ve sorgunun ihtiyaÃ§ duyduÄŸu ek sÃ¼tunlar bu indeksin bir parÃ§asÄ± olmadÄ±ÄŸÄ±nda meydana gelir.

*Key Lookup NasÄ±l Ã‡alÄ±ÅŸÄ±r?*

1. **Sorgu Ã‡alÄ±ÅŸtÄ±rÄ±lÄ±r:** Bir sorgu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda, SQL Server Ã¶nce uygun bir indeks olup olmadÄ±ÄŸÄ±nÄ± kontrol eder. EÄŸer sorguda kullanÄ±lan sÃ¼tunlar iÃ§in bir non-clustered index varsa, bu indeks kullanÄ±larak hÄ±zlÄ± bir arama yapÄ±lÄ±r.
2. **Ek Bilgi Ä°htiyacÄ±:** Ancak, sorgunun dÃ¶ndÃ¼rmesi gereken ek sÃ¼tunlar varsa ve bu sÃ¼tunlar non-clustered index'in bir parÃ§asÄ± deÄŸilse, SQL Server bu ek bilgiyi almak iÃ§in tabloya geri dÃ¶nmek zorundadÄ±r.
3. **Clustered Index veya RID KullanÄ±mÄ±:** SQL Server, gerekli ek sÃ¼tun bilgilerini almak iÃ§in ya clustered index key'ini kullanarak ya da tabloya yÃ¶nelik satÄ±r tanÄ±mlayÄ±cÄ±sÄ± (RID) kullanarak tabloya dÃ¶ner. Bu iÅŸlem, **Key Lookup** olarak adlandÄ±rÄ±lÄ±r.
4. **Performans:** Key Lookup iÅŸlemi genellikle ek maliyet gerektirir Ã§Ã¼nkÃ¼ bu iÅŸlem, tabloya fazladan bir okuma iÅŸlemi ekler. Ã‡ok sÄ±k Key Lookup yapÄ±lmasÄ±, sorgu performansÄ±nÄ± olumsuz etkileyebilir. Bu durumu minimize etmek iÃ§in **covering index** adÄ± verilen bir teknik kullanÄ±labilir. Bu teknik, sorgunun ihtiyaÃ§ duyduÄŸu tÃ¼m sÃ¼tunlarÄ± kapsayan bir indeks oluÅŸturmayÄ± iÃ§erir.

*Ã–rnek:*

AÅŸaÄŸÄ±daki Ã¶rnekteki gibi Ã¶ncesinde olduÄŸu gibi namesurname alanÄ±nÄ± bir non-clustered indeks olarak belirlemiÅŸtik.

```sql
SET STATISTICS IO ON -- ne kadarlÄ±k io yani okuma yaptÄ±? -- 6
SET STATISTICS TIME ON -- ne kadar sÃ¼re harcadÄ±?
SELECT * FROM CUSTOMERS
WHERE
NAMESURNAME = 'Ã–MER Ã‡OLAKOÄLU' 
```

Bu sorguda `NAMESURNAME` sÃ¼tunu non-clustered index tarafÄ±ndan hÄ±zla bulunur. Ancak `FirstName`, `LastName` ve `Age` sÃ¼tunlarÄ± indeksin bir parÃ§asÄ± olmadÄ±ÄŸÄ±ndan, SQL Server bu sÃ¼tunlarÄ± almak iÃ§in tabloya dÃ¶nmek zorunda kalÄ±r. Bu iÅŸlem, Key Lookup olarak adlandÄ±rÄ±lÄ±r.

EÄŸer `FirstName`, `LastName` ve `Age` sÃ¼tunlarÄ± da indeksin bir parÃ§asÄ± olsaydÄ±, Key Lookup'a gerek kalmazdÄ± ve sorgu daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±rdÄ±.

Key Lookup iÅŸlemlerini minimumda tutmak iÃ§in sorgu optimizasyonu yapÄ±lmasÄ± Ã¶nemlidir. Bu genellikle gerekli tÃ¼m sÃ¼tunlarÄ± kapsayan indeksler oluÅŸturularak yapÄ±labilir.

Key lookupâ€™Ä± en azda tutmak iÃ§in ise ÅŸu ÅŸekilde yÃ¶ntem saÄŸlayabiliriz:

Ã–ncesinde Ã¶nceden oluÅŸturduÄŸumuz non-clustered indexin iÃ§erisine gidip, sonrasÄ±nda:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2029.png)

Åeklinde bir yapÄ± kurarsak,

Åimdi sorgumuzu tekrar Ã§alÄ±ÅŸtÄ±ralÄ±m:

```sql
SELECT * FROM CUSTOMERS
WHERE
NAMESURNAME = 'Ã–MER Ã‡OLAKOÄLU' 
```

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2030.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi key lookup iÅŸlemini azalttÄ±. Bu ÅŸekilde daha hÄ±zlÄ± sorgular elde etmeye olanak saÄŸlamaktayÄ±z.

Ancak her yerde kullanÄ±labilecek bir yapÄ± da deÄŸildir. Tablonun boyutunu *2 ÅŸeklinde de arttÄ±rmaktadÄ±r. BazÄ± yerlere gÃ¶re kullanÄ±lmasÄ± gereklidir.

***NON-CLUSTERED_INDEX - 2***

Ã–rneÄŸin elimizde bir telefon numarasÄ± var ve bu numaranÄ±n kime ait olduÄŸunu Ã¶ÄŸrenmek istiyoruz. Bu iÅŸlemi klasik olarak yaparsak yine aynÄ± ÅŸekilde yÃ¼ksek iÅŸlemci gÃ¼cÃ¼ne sahip arama ÅŸeklinde yaparÄ±z. 

```sql
SET STATISTICS IO ON -- ne kadarlÄ±k io yani okuma yaptÄ±? -- 32442
SET STATISTICS TIME ON -- ne kadar sÃ¼re harcadÄ±?
SELECT * FROM CUSTOMERS
WHERE
TELNR = '03222356749'
```

Bu sorguyu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda 32.442 sayfa arasÄ±ndan aradÄ±ÄŸÄ±mÄ±zÄ± buldu. Ancak bunu yine aynÄ± ÅŸekilde dÃ¼ÅŸÃ¼rmek istersek yani daha performanslÄ± bir ÅŸekilde Ã§alÄ±ÅŸtÄ±rmak istersek ÅŸu ÅŸekilde bir yÃ¶ntem izlemeliyiz.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2031.png)

Buradan non-clustered seÃ§ildikten sonra

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2032.png)

TELNR alanÄ± seÃ§ilir ve iÅŸleme devam edilir. 

Bu ÅŸekilde ayarladÄ±ktan sonra tekrardan aynÄ± sorguyu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda

```sql
SET STATISTICS IO ON -- ne kadarlÄ±k io yani okuma yaptÄ±? -- 7
SET STATISTICS TIME ON -- ne kadar sÃ¼re harcadÄ±?
SELECT * FROM CUSTOMERS
WHERE
TELNR = '03222356749'
```

Sorguyu Ã§alÄ±ÅŸtÄ±ralÄ±m

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2033.png)

Bu ÅŸekilde 30.938 olan sayfa arama sayÄ±sÄ± bu sefer 7â€™ye dÃ¼ÅŸmÃ¼ÅŸ oldu. 

SQL Server sorgunun tÃ¼rÃ¼ne gÃ¶re istenilen indexâ€™i Ã§alÄ±ÅŸtÄ±rÄ±r ve performanslÄ± bir ÅŸekilde sonuÃ§ dÃ¶nÃ¼ÅŸtÃ¼rebilir.

<aside>
ğŸ’¡

Bir tabloda bir adet *clustered-index* bulunabilirken, birden fazla *non_clustered-index* bulunabileceÄŸini unutmamamÄ±z gereklidir.

</aside>

***SQL SERVER INDEX Ã–NERÄ°LERÄ°***

Bazen Ã¶yle durumlarda hangi sorgularda hangi indexleri kullanamayacaÄŸÄ±mÄ±zÄ± bilemeyebiliriz. Ä°ÅŸte bu bilinemeyen durumlarda SQL Server bize uygun olan index yapÄ±sÄ±nÄ± sunabilir.

Bu yapÄ±yÄ± ise biz script olarak yazabiliriz. 

DiÄŸer database nesnelerinde olduÄŸu gibi bir index **CREATE** ile **OLUÅTURULUR**, **ALTER** ile **DEÄÄ°ÅTÄ°RÄ°LÄ°R** ve son olarak **DROP** ile **SÄ°LÄ°NÄ°R.**

Åimdi bu indeximizi oluÅŸturalÄ±m:

```sql
CREATE NONCLUSTERED INDEX IX_1 ON CUSTOMERS -- indexin ismi, hangi tabloda Ã§alÄ±ÅŸacaÄŸÄ±
(NAMESURNAME) -- tablodaki hangi alanÄ± seÃ§eceÄŸi
```

Bu ÅŸekilde indeximiz oluÅŸtu.

***INDEX FRAGMENTATION - INDEX BOZULMASI***

**Index fragmentation**, veri tabanlarÄ±nda ve Ã¶zellikle iliÅŸkisel veritabanÄ± yÃ¶netim sistemlerinde (RDBMS) sÄ±kÃ§a karÅŸÄ±laÅŸÄ±lan bir durumdur. Bir indeks oluÅŸturulduÄŸunda, veriler sÄ±ralÄ± ve dÃ¼zenli bir ÅŸekilde saklanÄ±r. Ancak zamanla, veri ekleme, gÃ¼ncelleme ve silme iÅŸlemleri sonucunda bu dÃ¼zen bozulur. Bu duruma indeks parÃ§alanmasÄ± (index fragmentation) denir.

Ä°ki ana tÃ¼rde parÃ§alanma vardÄ±r:

1. **Internal Fragmentation (Ä°Ã§ ParÃ§alanma):**
    - Bu tÃ¼rde, indeks sayfalarÄ± arasÄ±nda boÅŸ alanlar oluÅŸur. Ã–rneÄŸin, bir veri sayfasÄ±nda %70 doluluk varsa, %30'luk kÄ±smÄ± boÅŸtur. Bu boÅŸ alanlar veri tabanÄ±nÄ±n daha fazla disk alanÄ± kullanmasÄ±na neden olur ve sorgu performansÄ±nÄ± dÃ¼ÅŸÃ¼rebilir.
2. **External Fragmentation (DÄ±ÅŸ ParÃ§alanma):**
    - Bu tÃ¼rde, veri sayfalarÄ± sÄ±ralÄ± bir ÅŸekilde depolanmaz. Sayfalar arasÄ±ndaki sÄ±ralÄ± olmayan veri yerleÅŸimi, sorgu iÅŸlemlerinin daha fazla sayfa okumasÄ±na neden olabilir, bu da performansÄ± olumsuz etkiler.

Ä°ndeks parÃ§alanmasÄ±, sorgu performansÄ±nÄ± olumsuz etkileyebilir Ã§Ã¼nkÃ¼ veri tabanÄ±, verileri daha yavaÅŸ okuyabilir. Bu sorunu Ã§Ã¶zmek iÃ§in dÃ¼zenli olarak indeks yeniden yapÄ±landÄ±rma (rebuild) veya reorganizasyon (reorganize) iÅŸlemleri yapÄ±labilir. Bu iÅŸlemler, indekslerin tekrar sÄ±ralanmasÄ±nÄ± ve parÃ§alanmanÄ±n giderilmesini saÄŸlar.

SQL Server iÃ§erisinde indexlerin doluluk oranlarÄ±na bakmak iÃ§in ilgili indexe Ã§ift tÄ±klayÄ±p sekme iÃ§erisinde bakabiliriz:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2034.png)

Bu ÅŸekilde baktÄ±ÄŸÄ±mÄ±zda sayfa doluluk oranÄ± %99.83 iken toplam fragmentation ise 0.01â€™dir. Ancak daha Ã¶nceden de dediÄŸimiz gibi veri tabanÄ±na insert iÅŸlemleri gerÃ§ekleÅŸtikÃ§e bu oran git gide dÃ¼ÅŸecektir. Bu yÃ¼zden buranÄ±n takibi oldukÃ§a Ã¶nemlidir.

Åimdi buraya 10.000 veri ekleyerek fragmentationâ€™u bir kontrol edelim.

```sql
/*
	veritabanÄ±na 10000 kayÄ±t atalÄ±m ve fragmentation'u kontrol edelim
*/
-- insert into kalÄ±bÄ±yla veri ekleyelim
INSERT INTO CUSTOMERS
(NAMESURNAME, GENDER, BIRTHDATE, CITY, TOWN, TELNR, 
NAME_, SURNAME, TCNO)

-- 10.000 kayÄ±tÄ± listeledik
SELECT TOP 10000 
NAMESURNAME, GENDER, BIRTHDATE, CITY, TOWN, TELNR, 
NAME_, SURNAME, TCNO
FROM CUSTOMERS

SELECT COUNT(*) FROM CUSTOMERS
```

Bu ÅŸekilde 10.000 kayÄ±t ekledik.

Ve sonuÃ§lara bakalÄ±m:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2035.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi fragmentation oranÄ± %20 deÄŸer kaybetmiÅŸ. Bu deÄŸer kaybÄ± oldukÃ§a ciddi ve sorgu performansÄ±nÄ± etkileyebilmektedir.

<aside>
ğŸ’¡

indexlerde bozulmalarda primary key genellikle en saÄŸlam olan ve bozulmaya mahal vermeyen bir indextir ancak bu primary key otomatik artanlÄ± bir durumdaysa bozulmaya yol aÃ§maz Ã§Ã¼nkÃ¼ her eklenen kayÄ±t sonrakinin arkasÄ±na ekleneceÄŸi iÃ§in araya herhangi bir veri alÄ±ÅŸÄ± almayacaktÄ±r ama unique bir deÄŸeri yani benzersiz olan bir deÄŸeri (*Ã¶rneÄŸin tc. no*) bu gibi alanlar araya illaki veriler alacaÄŸÄ± ve bu veriler dÃ¼zensiz olacaÄŸÄ± iÃ§in bu indexin bozulmama gibi bir garantisi ***yoktur!***

</aside>

Ä°ÅŸte bu bozulmalarÄ± Ã¶nlemek iÃ§in genellikle sistemin Ã§alÄ±ÅŸmadÄ±ÄŸÄ± zamanlarda veya gÃ¼n sonlarÄ±nda rebuild iÅŸlemleri yapÄ±lÄ±r.

Bir rebuild iÅŸlemi yapabilmek ise

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2036.png)

Buradan seÃ§ilir ve sonrasÄ±nda

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2037.png)

Buradan gerekli index seÃ§ilerek rebuild iÅŸlemi yapÄ±lÄ±r. Bu ÅŸekilde fragmentation iÅŸlemleri halledilmiÅŸ olur.

Ancak Ã¶yle sistemler vardÄ±r ki 7 gÃ¼n 24 saat Ã§alÄ±ÅŸabilmektedir. Ä°ÅŸte bu tipte Ã§alÄ±ÅŸan sistemlerde bazen boÅŸ bir an veya vakit bulmak oldukÃ§a zordur. Ä°ÅŸte bu tipte bir olayla ilgili ise durumu farklÄ± yÃ¶ntemlerle Ã§Ã¶zmemiz gerekebilmektedir.

***FILL FACTOR*** 

**Fill factor** (doldurma faktÃ¶rÃ¼), iliÅŸkisel veritabanÄ± yÃ¶netim sistemlerinde (RDBMS) bir indeks oluÅŸturulurken veya yeniden oluÅŸturulurken kullanÄ±lan bir ayardÄ±r. Fill factor, her bir veri sayfasÄ±nÄ±n ne kadarÄ±nÄ±n doldurulacaÄŸÄ±nÄ± belirler ve kalan kÄ±smÄ±n ilerideki veri eklemeleri iÃ§in boÅŸ bÄ±rakÄ±lmasÄ±nÄ± saÄŸlar.

Ã–rneÄŸin, bir fill factor deÄŸeri olarak %80 belirlendiÄŸinde, her bir veri sayfasÄ±nÄ±n %80'i dolu olacak ÅŸekilde veri eklenir, geri kalan %20'si ise yeni verilerin eklenebilmesi iÃ§in boÅŸ bÄ±rakÄ±lÄ±r. Bu, zamanla yeni veri eklendiÄŸinde indeks sayfalarÄ±nÄ±n yeniden dÃ¼zenlenmesi (reorganizasyon) gereksinimini azaltabilir ve indeks parÃ§alanmasÄ±nÄ±n (index fragmentation) Ã¶nÃ¼ne geÃ§ebilir.

**Fill Factor'un KullanÄ±mÄ±:**

- **DÃ¼ÅŸÃ¼k DeÄŸerli Fill Factor (%50 gibi):** Bu, sayfalarÄ±n daha bÃ¼yÃ¼k bir kÄ±smÄ±nÄ±n boÅŸ bÄ±rakÄ±lmasÄ±nÄ± saÄŸlar. Ã‡ok sÄ±k ekleme veya gÃ¼ncelleme yapÄ±lan sistemlerde tercih edilir, Ã§Ã¼nkÃ¼ boÅŸ alan sayesinde yeni veriler eklendiÄŸinde daha az parÃ§alanma olur.
- **YÃ¼ksek DeÄŸerli Fill Factor (%90 veya %100 gibi):** Sayfalar neredeyse tamamen doldurulur. Bu, yerden tasarruf saÄŸlar ve veri okuma iÅŸlemlerini hÄ±zlandÄ±rabilir, ancak daha fazla ekleme ve gÃ¼ncelleme yapÄ±lmasÄ± durumunda indeks parÃ§alanmasÄ± riski artar.

Fill factor ayarlarÄ±, veritabanÄ± performansÄ±nÄ± optimize etmek iÃ§in dikkatlice yapÄ±lmalÄ±dÄ±r. Ã‡ok dÃ¼ÅŸÃ¼k bir fill factor, fazla boÅŸ alan bÄ±rakÄ±lmasÄ±na neden olarak disk alanÄ±nÄ±n verimsiz kullanÄ±lmasÄ±na yol aÃ§abilir. Ã‡ok yÃ¼ksek bir fill factor ise indeks parÃ§alanmasÄ±nÄ± artÄ±rarak performans sorunlarÄ±na neden olabilir.

Bunun gÃ¶rselleÅŸtirilmiÅŸ hali ÅŸu ÅŸekildedir:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2038.png)

Åimdi bu fill factorâ€™Ã¼ nasÄ±l aktif edebileceÄŸimizi gÃ¶sterelim:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2039.png)

Buradan options seÃ§enekleri arasÄ±nda fill factorâ€™Ã¼ 80 olarak ayarlayalÄ±m.

Åimdi veri tabanÄ±na 10.000 kayÄ±t atalÄ±m:

```sql
-- insert into kalÄ±bÄ±yla veri ekleyelim
INSERT INTO CUSTOMERS
(NAMESURNAME, GENDER, BIRTHDATE, CITY, TOWN, TELNR, 
NAME_, SURNAME, TCNO)

-- 10.000 kayÄ±tÄ± listeledik
SELECT TOP 10000 
NAMESURNAME, GENDER, BIRTHDATE, CITY, TOWN, TELNR, 
NAME_, SURNAME, TCNO
FROM CUSTOMERS
```

10.000 kayÄ±t gÃ¶nderildi ve fragmentation oranÄ±na bi bakalÄ±m:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2040.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi fragmentasyonda bir bozulma olmadÄ±.

Åimdi ise veri tabanÄ± iÃ§erisinde 100.000 kayÄ±t gÃ¶nderelim:

```sql
INSERT INTO CUSTOMERS
(NAMESURNAME, GENDER, BIRTHDATE, CITY, TOWN, TELNR, 
NAME_, SURNAME, TCNO)

-- 10.000 kayÄ±tÄ± listeledik
SELECT TOP 100000 
NAMESURNAME, GENDER, BIRTHDATE, CITY, TOWN, TELNR, 
NAME_, SURNAME, TCNO
FROM CUSTOMERS
```

100.000 veriyi attÄ±k ve fragmantasyonu tekrar kontrol edelim.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2041.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi yine bozulma olmadÄ±.

Åimdi bu fragmantasyonu bozmak iÃ§in iÃ§erisine 500.000 veri atalÄ±m:

```sql
INSERT INTO CUSTOMERS
(NAMESURNAME, GENDER, BIRTHDATE, CITY, TOWN, TELNR, 
NAME_, SURNAME, TCNO)

SELECT TOP 500000 
NAMESURNAME, GENDER, BIRTHDATE, CITY, TOWN, TELNR, 
NAME_, SURNAME, TCNO
FROM CUSTOMERS
```

500.000 veriyi attÄ±k. Åimdi fragmantasyonu kontrol edelim:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2042.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi fragmantasyonu bozduk. 

Yani buradan Ã§Ä±karÄ±lacak sonuÃ§, fill faktor sayesinde verileri bozulmadan istenilen veri girilesiye kadar indexler bozulmamaya devam edecektir. Ancak fill factor oranÄ± dolduÄŸu anda fragmantasyon oranÄ± artacaktÄ±r.

Son olarak index konusunu vazgeÃ§ilmez bir durum olarak tanÄ±mlamak gerekir. KullanÄ±ldÄ±ÄŸÄ± zamanlarda zamandan bÃ¼yÃ¼k tasarruf ederken, kullanÄ±lmadÄ±ÄŸÄ± zamanlarda ise zamanÄ± ve makine kullanÄ±mÄ±nÄ± oldukÃ§a yormaktadÄ±r.

Bu ÅŸekilde de index konusunu bitirmiÅŸ olduk. Bir sonraki konumuz ise ***Cursor Konusu*** olacaktÄ±r.

### CURSOR KAVRAMI

Bir SQL sorgusu iÃ§inde dÃ¶ngÃ¼ ile satÄ±r satÄ±r dolaÅŸmak ve iÅŸlem yaptÄ±rmak iÃ§in kullandÄ±ÄŸÄ±mÄ±z yapÄ±lardÄ±r.

DeÄŸiÅŸkenler tanÄ±mlanÄ±r ve her bir satÄ±r iÃ§in bu deÄŸiÅŸkenler tablodan dÃ¶nen deÄŸerlere atanÄ±r.

`Declare <cursor_adi> for Select â€¦ from tablo_ismi` kalÄ±bÄ± ile tanÄ±mlanÄ±r.

`Fetch next into deÄŸiÅŸkenler` kalÄ±bÄ± ile bir sonraki satÄ±ra geÃ§ilir.

***CURSOR UYGULAMA***

Cursor iÅŸlemi genellikle Ã¶zelleÅŸtirilmiÅŸ alanlarda â€˜mail gÃ¶nderimi vs.â€™ gibi alanlarda veya kiÅŸiye Ã¶zel stored procedureâ€™larda sÄ±klÄ±kla kullanÄ±lan bir yapÄ±dÄ±r.

Bu yapÄ± kurgulanÄ±rken Ã¶ncelikle deÄŸiÅŸkenler tanÄ±mlanÄ±r sonrasÄ±nda ise select sorgusu kullanÄ±larak deÄŸiÅŸkenler iÃ§erisine deÄŸer atamalarÄ± gerÃ§ekleÅŸtirilir.

`OPEN CRS` adÄ± ile cursor aÃ§Ä±lÄ±r.

`FETCH NEXT FROM CRS INTO` kalÄ±bÄ±yla sorgudan gelen deÄŸerler deÄŸiÅŸkenlere atama yapÄ±lÄ±r.

Sorgunun sonuna gelesiye kadar `WHILE @@FETCH_STATUS = 0` sorgunun sonuna gelinip gelinmediÄŸi kontrol edilir.

EÄŸer gelinmezse `BEGIN END` bloklarÄ± iÃ§erisinde bÃ¼tÃ¼n iÅŸlemler yapÄ±lÄ±r.

`FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @BIRTHDATE`  sona gelinmediÄŸi sÃ¼reÃ§ boyunca bir sonraki satÄ±ra geÃ§me iÅŸlemi yapÄ±lÄ±r.

En sonunda `CLOSE CRS` iÅŸlemiyle cursor kapatÄ±lÄ±r ve `DEALLOCATE CRS` iÅŸlemiyle de cursora ait bilgiler hafÄ±zan silinir.

Bunun Ã¶rnek kodlarÄ± aÅŸaÄŸÄ±da gibidir:

```sql
DECLARE @ID AS INT
DECLARE @NAMESURNAME AS VARCHAR(100)
DECLARE @BIRTHDATE AS DATE

-- cursor kalÄ±bÄ± ÅŸu ÅŸekilde kurulur.
-- baÅŸÄ±nda @ iÅŸareti kullanÄ±lmaz.
-- sÄ±rasÄ±yla: cursor adÄ±, cursor tanÄ±mlanmasÄ±, hangi sql cÃ¼mlesi iÃ§in Ã§alÄ±ÅŸacak
DECLARE CRS CURSOR FOR 

	SELECT ID, NAMESURNAME, BIRTHDATE FROM CUSTOMERS
	WHERE
	CITY = 'Ä°STANBUL' AND TOWN = 'ÃœSKÃœDAR'

OPEN CRS -- cursoru aÃ§ma iÅŸlemi
-- sorgudan gelen deÄŸerleri cursor nesnesi deÄŸiÅŸkenlerine atamak gerekir.
FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @BIRTHDATE

WHILE @@FETCH_STATUS = 0 -- sorgunun sonuna geldim mi (bir global deÄŸiÅŸkeni iki adet @@ iÅŸaretiyle tanÄ±mlanÄ±r.)
BEGIN
	-- begin end bloklarÄ± iÃ§erisinde herhangi bir iÅŸlemi yaptÄ±rabilirim.
	-- Ã¶rneÄŸin:
	-- SELECT @NAMESURNAME
	-- veya
	PRINT @NAMESURNAME
	FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @BIRTHDATE -- sona gelmediÄŸim sÃ¼reÃ§ boyunca bir sonraki satÄ±ra geÃ§
END

-- cursor iÅŸlemi bittikten sonra
CLOSE CRS -- cursoru kapat
DEALLOCATE CRS -- cursora ait bilgileri hafÄ±zadan sil
```

Cursorun genel yapÄ±sÄ± bu ÅŸekildedir.

Burada `BEGIN-END` bloklarÄ± iÃ§erisinde istediÄŸim her iÅŸlemi gerÃ§ekleÅŸtirebilirim.

Ã–rneÄŸin:

```sql
BEGIN
	-- begin end bloklarÄ± iÃ§erisinde herhangi bir iÅŸlemi yaptÄ±rabilirim.
	-- Ã¶rneÄŸin:
	SELECT @NAMESURNAME
	FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @BIRTHDATE -- sona gelmediÄŸim sÃ¼reÃ§ boyunca bir sonraki satÄ±ra geÃ§
END
```

Ã–rneÄŸin burada sorguyu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda ÅŸu sonucu elde ederiz:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2043.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi satÄ±r satÄ±r isimleri bize getirdi.

Bir diÄŸer kullanÄ±m ve genellikle kullanÄ±m ise ÅŸu ÅŸekildedir:

```sql
BEGIN
	-- begin end bloklarÄ± iÃ§erisinde herhangi bir iÅŸlemi yaptÄ±rabilirim.
	PRINT @NAMESURNAME
	FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @BIRTHDATE -- sona gelmediÄŸim sÃ¼reÃ§ boyunca bir sonraki satÄ±ra geÃ§
END
```

Bu ÅŸekilde Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda sonuÃ§ ÅŸu ÅŸekilde olacaktÄ±r:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2044.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi konsola satÄ±r satÄ±r isim verileri gelecektir.

***CURSOR KÄ°ÅÄ°YE Ã–ZEL MAIL OLUÅTURMA***

KiÅŸiye Ã¶zel bey veya hanÄ±m gibi hitaplar, isimler, kaÃ§Ä±ncÄ± yaÅŸÄ±na girdiÄŸine dair bilgileri getirten bir cursor yazalÄ±m:

```sql
-- kiÅŸiye Ã¶zel doÄŸum gÃ¼nÃ¼ mesajÄ± oluÅŸturma

-- bugÃ¼n doÄŸanlarÄ±n listesini getirtelim.

SELECT ID, NAMESURNAME, GENDER, BIRTHDATE FROM CUSTOMERS
WHERE DATEPART(DAY,BIRTHDATE) = DATEPART(DAY, GETDATE())
AND
DATEPART(MONTH, BIRTHDATE) = DATEPART(MONTH, GETDATE()) -- 33 kiÅŸi var.

/* ÅŸu ÅŸekilde bir yapÄ± kurgulamamÄ±z gerekebilir.
'SayÄ±n Defne KaragÃ¶z HanÄ±m,
60.yaÅŸÄ±nÄ±zÄ± kutlar, saÄŸlÄ±klÄ± Ã¶mÃ¼rler dileriz.'
*/

-- Ã¶ncelikle deÄŸiÅŸkenlerimizi tanÄ±mlayalÄ±m
DECLARE @ID AS INT
DECLARE @NAMESURNAME AS VARCHAR(100)
DECLARE @GENDER AS VARCHAR(1)
DECLARE @BIRTHDATE AS DATE
DECLARE @MSG AS VARCHAR(1000) -- mesaj deÄŸiÅŸkeni
DECLARE @AGE AS INT -- yaÅŸ deÄŸiÅŸkeni

-- ÅŸimdi cursoru kuralÄ±m

DECLARE CRS CURSOR FOR
-- sorgunun kendisi
	SELECT ID, NAMESURNAME, GENDER, BIRTHDATE FROM CUSTOMERS
	WHERE DATEPART(DAY, BIRTHDATE) = DATEPART(DAY, GETDATE())
	AND
	DATEPART(MONTH, BIRTHDATE) = DATEPART(MONTH, GETDATE())

-- cursoru aÃ§alÄ±m
OPEN CRS
FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @GENDER, @BIRTHDATE

-- durum sÄ±fÄ±r olasÄ±ya kadar
WHILE @@FETCH_STATUS = 0
BEGIN
	-- mesajÄ± oluÅŸturalÄ±m
	SET @MSG = 'SayÄ±n, ' + @NAMESURNAME
	-- cinsiyete gÃ¶re hanÄ±m veya bey
	IF @GENDER = 'E'
		SET @MSG = @MSG+ ' Bey;'
	ELSE
		SET @MSG = @MSG+ ' HanÄ±m;'
	-- bir satÄ±r aÅŸaÄŸÄ± Ã§ekelim
	SET @MSG = @MSG+CHAR(13)

	-- yaÅŸÄ±nÄ± bulalÄ±m
	SET @AGE = DATEDIFF(YEAR, @BIRTHDATE, GETDATE())

	-- mesajÄ± son hale getirelim
	SET @MSG = @MSG + CONVERT(VARCHAR, @AGE)+ '. yaÅŸÄ±nÄ±zÄ± kutlar. SaÄŸlÄ±klÄ± yÄ±llar dileriz.'

	-- konsolda gÃ¶rÃ¼ntÃ¼leyelim
	PRINT @MSG

FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @GENDER, @BIRTHDATE
END

-- cursoru kapatalÄ±m
CLOSE CRS
-- cursoru hafÄ±zadan silelim
DEALLOCATE CRS
```

Åimdi bu cursoru gÃ¶rÃ¼ntÃ¼leyelim:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2045.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi mesajlar oluÅŸtu. Toplamda 33 kiÅŸi bu mesajtan etkilenecek. Bir sonraki durumda bunlarÄ± TSQL kullanarak nasÄ±l mail olarak gÃ¶nderebiliriz onu inceleyeceÄŸiz.

***SQL SERVER MAIL GÃ–NDERME Ä°ÅLEMÄ°***

SQL serverda mail gÃ¶nderme iÅŸlemi biraz basit olsa da biraz karmaÅŸÄ±k bir yapÄ±ya sahiptir. Ancak burada hata yapÄ±lmamasÄ± gereklidir. Ã‡Ã¼nkÃ¼ hata yapÄ±lÄ±rsa dÃ¼zeltilmesi biraz zordur.

Ã–ncelikle *Management* sekmesi iÃ§erisinde bulunan *Database Mail* sekmesine girmemiz gereklidir.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2046.png)

Buraya girildikten sonra ise bazÄ± konfigurasyon ayarlarÄ± yapÄ±lmasÄ± gereklidir.

*Set Up Database* seÃ§eneÄŸi seÃ§ilerek devam edilir.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2047.png)

*Next* diyerek devam edilir.

Bu gÃ¶rÃ¼ntÃ¼de *Profile Name* sekmesine *SQLMAIL* yazÄ±lmasÄ± gereklidir. ***Ancak burada TÃ¼rkÃ§e karakterler kullanÄ±lmamasÄ± gereklidir.***

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2048.png)

Bu ÅŸekilde tamamlanarak *Addâ€¦* sekmesine girilir.

AÃ§Ä±lan sekmede mail gÃ¶nderme iÅŸlemini hangi mail adresiyle yapÄ±lacaÄŸÄ± belirtilir. Ben burada kendi mail adresimi ve ÅŸifrelerimi giriyorum. Sizde kendinize ait mail ÅŸifrelerinizi girebilirsiniz.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2049.png)

Burada *Server name* alanÄ± ve *Port Number* alanÄ± Ã¶nceden belirlenmiÅŸ bir yapÄ±ya sahip olduÄŸu iÃ§in aynÄ± gÃ¶rseldeki gibi bÄ±rakmanÄ±z gerekir. Bu iÅŸlemleri tamamladÄ±ktan sonra *OK* basÄ±p yola devam ediyoruz.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2050.png)

Burada *public* olan kÄ±smÄ± iÅŸaretleyip *Next* diyerek yola devam ediyoruz.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2051.png)

Bizi bu ÅŸekilde bir ekran karÅŸÄ±ladÄ±ysa gayet baÅŸarÄ±lÄ± bir ÅŸekilde gerÃ§ekleÅŸtirmiÅŸizdir. Ancak SQL mail sistemi yine Ã§alÄ±ÅŸmayacaktÄ±r. Ã‡Ã¼nkÃ¼ Google yakÄ±n tarihte bu tip mail gÃ¶nderme iÅŸlemlerinin gÃ¼venlik problemlerine yol aÃ§tÄ±ÄŸÄ± gerekÃ§esiyle uygulama ÅŸifreleri Ã¶zelliÄŸini tanÄ±ttÄ±. Bu yÃ¼zden dolayÄ± bir uygulama ÅŸifresi almamÄ±z gerekecek. Ancak yine de test edelim. 

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2052.png)

Buradan *Test E-mail* kÄ±smÄ±na tÄ±klayarak bir test maili gÃ¶nderelim.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2053.png)

Buradan alÄ±cÄ± adreslerini girdikten sonra *send test e-mail* diyerek Ã§alÄ±ÅŸtÄ±ralÄ±m.

Mail kutunuzu kontrol ettiÄŸinizde herhangi bir aksiyon alamayacaksÄ±nÄ±z. Ã‡Ã¼nkÃ¼ uygulama ÅŸifrelerini aktif etmeniz gereklidir.

Google Accountunuzda iki kademeli doÄŸrulamayÄ± aÃ§tÄ±ktan sonra *App Password* kÄ±smÄ±na girerek ÅŸu ÅŸekilde bir ekran sizi karÅŸÄ±layacaktÄ±r.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2054.png)

Buradan uygulamanÄ±za bir isim girerek sonrasÄ±nda *Create* kÄ±smÄ±na gitmeniz gereklidir.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2055.png)

AldÄ±ÄŸÄ±nÄ±z uygulama ÅŸifresini kopyalayÄ±p, SQL Server iÃ§erisine tekrar dÃ¶nelim.

Buradan yine aynÄ± ÅŸekilde *Management* sekmesi altÄ±nda bulunan *Database Mail* sekmesine gelelim.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2056.png)

Buradan *Configure Database Mail* sekmesine tÄ±klayarak gerekli sayfayÄ± tekrar aÃ§alÄ±m.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2057.png)

AÃ§Ä±lan sayfada *Manage Database Mail* sekmesine tÄ±klayÄ±p *Next* diyelim.

ÅÃ¶yle bir ekran bizi karÅŸÄ±layacaktÄ±r.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2058.png)

Bu ekrandan *View, change..* sekmesini seÃ§elim.

AÃ§Ä±lan bu ekranda ise

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2059.png)

*Password* kÄ±smÄ±ndan ÅŸifrelerimizi almÄ±ÅŸ olduÄŸumuz uygulama ÅŸifresiyle deÄŸiÅŸtirelim.

Tekrardan bir test mail gÃ¶nderdiÄŸimizde ve posta kutumuzu kontrol ettiÄŸimizde ÅŸÃ¶yle bir sonuca ulaÅŸacaÄŸÄ±z.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2060.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi mail geldi.

BÃ¼tÃ¼n bu iÅŸlemlerin her biri TSQL ile de gerÃ§ekleÅŸtirilebilmektedir. *(Gerekli bilgileri microsoft sayfasÄ±ndan ulaÅŸabilirsiniz.)*

Ã–rnek bir e-mail scriptâ€™i yazalÄ±m:

```sql
-- SQL'den mail gÃ¶nderme iÅŸlemi TSQL'le gerÃ§ekleÅŸmektedir.
-- Bu iÅŸlemi ÅŸu ÅŸekilde gÃ¶rÃ¼ntÃ¼leyebiliriz

EXEC msdb.dbo.sp_send_dbmail
	@profile_name = 'SQLMAIL', -- profilde tanÄ±mlanmÄ±ÅŸ gmail 
	@recipients = 'ahmetklnc242@gmail.com', -- kime gÃ¶nderileceÄŸi
	@body = 'Bu bir deneme maili taslaÄŸÄ±dÄ±r. MSSQL tarafÄ±ndan gÃ¶nderilmiÅŸtir.', -- iÃ§eriÄŸi
	@subject = 'SQL test mail' -- konusu
```

Bu scripti Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda ise ve mail kutusunu tekrar kontrol ettiÄŸimizde ise 

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2061.png)

Bu ÅŸekilde bir maille karÅŸÄ±laÅŸÄ±yorsak baÅŸarmÄ±ÅŸÄ±z demektir. 

Åimdi doÄŸum gÃ¼nÃ¼ iÃ§eriklerini mail olarak gÃ¶nderelim.

Scripti inceleyelim:

```sql
-- kullanÄ±cÄ±lara doÄŸum gÃ¼nÃ¼ kutlayan e mail gÃ¶nderelim

-- gerekli alanlarÄ± seÃ§elim
/*
SELECT 
ID, NAMESURNAME, GENDER, BIRTHDATE, EMAIL, DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS AGE 
FROM USERS
WHERE DATEPART(DAY, BIRTHDATE) = DATEPART(DAY, GETDATE())
AND
DATEPART(MONTH, BIRTHDATE) = DATEPART(MONTH, GETDATE())
*/
-- ÅŸimdi Ã¶zellikleri deÄŸiÅŸken olarak tanÄ±mlayalÄ±m
DECLARE @ID AS INT
DECLARE @NAMESURNAME AS VARCHAR(100)
DECLARE @GENDER AS VARCHAR(1)
DECLARE @BIRTHDATE AS DATE
DECLARE @EMAIL AS VARCHAR(100)
DECLARE @AGE AS INT
DECLARE @MSG AS VARCHAR(1000)

-- cursoru yazalÄ±m
DECLARE CRS CURSOR FOR

	SELECT  -- burada e-mail adresleri benim kullandÄ±ÄŸÄ±m veriler fake veriler olduÄŸu iÃ§in Ã§alÄ±ÅŸmayacaktÄ±r. ondan dolayÄ± kendi mail adresimi girdim
	ID, NAMESURNAME, GENDER, BIRTHDATE, 'ahmetklnc242@gmail.com' EMAIL, DATEDIFF(YEAR, BIRTHDATE, GETDATE()) AS AGE 
	FROM USERS
	WHERE DATEPART(DAY, BIRTHDATE) = DATEPART(DAY, GETDATE())
	AND
	DATEPART(MONTH, BIRTHDATE) = DATEPART(MONTH, GETDATE())

OPEN CRS
FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @GENDER, @BIRTHDATE, @EMAIL, @AGE
WHILE @@FETCH_STATUS = 0
BEGIN
SET @MSG ='SayÄ±n '+ @NAMESURNAME
IF @GENDER = 'E'
	SET @MSG = @MSG+ ' Bey;'
ELSE
	SET @MSG = @MSG+ ' HanÄ±m;'
SET @MSG = @MSG + CHAR(13) -- bir alt satÄ±ra geldim.
SET @MSG = @MSG +CONVERT(VARCHAR, @AGE)+'. yaÅŸÄ±nÄ±zÄ± kutlar. Sevdiklerinizle, saÄŸlÄ±klÄ± ve mutlu bir yeni yÄ±l dileriz.'

-- SQL mail gÃ¶nderme scripti
EXEC msdb.dbo.sp_send_dbmail
	@profile_name = 'SQLMAIL',
	@recipients = @EMAIL,
	@body = @MSG,
	@subject = 'DoÄŸum GÃ¼nÃ¼nÃ¼z Kutlu Olsun!';

FETCH NEXT FROM CRS INTO @ID, @NAMESURNAME, @GENDER, @BIRTHDATE, @EMAIL, @AGE
END
CLOSE CRS
DEALLOCATE CRS
```

Scripti Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra mail kutumuzu bi kontrol edelim:

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2062.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi mailler gelmiÅŸ. Bu ÅŸekilde bir Ã¶zelleÅŸtirme doÄŸrultusunda Ã§alÄ±ÅŸmalar gerÃ§ekleÅŸtirebiliriz.

***CURSOR Ä°LE BÄ°R STORED PROCEDURE Ã‡AÄIRMAK***

***Senaryo:***

Bir tablodaki her bir satÄ±r iÃ§in belirli bir stored procedure'Ã¼ Ã§aÄŸÄ±rmak istediÄŸimizi varsayalÄ±m. `Employee` tablosunda `EmployeeID` sÃ¼tunu olduÄŸunu dÃ¼ÅŸÃ¼nelim ve her bir `EmployeeID` iÃ§in `usp_GetEmployeeDetails` adÄ±nda bir stored procedure'Ã¼ Ã§aÄŸÄ±racaÄŸÄ±z.

***AdÄ±mlar:***

1. *Cursor TanÄ±mlama ve AÃ§ma:*

```sql
DECLARE @EmployeeID INT

DECLARE EmployeeCursor CURSOR FOR
SELECT EmployeeID FROM Employee

OPEN EmployeeCursor
FETCH NEXT FROM EmployeeCursor INTO @EmployeeID

WHILE @@FETCH_STATUS = 0
BEGIN
    -- Stored procedure'Ã¼ Ã§aÄŸÄ±r
    EXEC usp_GetEmployeeDetails @EmployeeID

    FETCH NEXT FROM EmployeeCursor INTO @EmployeeID
END

CLOSE EmployeeCursor
DEALLOCATE EmployeeCursor

```

***AÃ§Ä±klamalar:***

- **Cursor TanÄ±mlama:** `DECLARE EmployeeCursor CURSOR FOR` ifadesiyle bir cursor tanÄ±mlÄ±yoruz. Bu cursor, `Employee` tablosundaki `EmployeeID` sÃ¼tunundaki deÄŸerleri alacak.
- **Cursor AÃ§ma:** `OPEN EmployeeCursor` ile cursor'Ä± aÃ§Ä±yoruz ve `FETCH NEXT FROM EmployeeCursor INTO @EmployeeID` ifadesiyle ilk `EmployeeID` deÄŸerini deÄŸiÅŸkene atÄ±yoruz.
- **While DÃ¶ngÃ¼sÃ¼:** Cursor'dan deÄŸerler alÄ±ndÄ±kÃ§a stored procedure Ã§aÄŸrÄ±lÄ±yor (`EXEC usp_GetEmployeeDetails @EmployeeID`). DÃ¶ngÃ¼, `@@FETCH_STATUS = 0` olduÄŸu sÃ¼rece devam eder.
- **Cursor Kapatma ve Bellekten Silme:** Cursor'Ä± kapatmak iÃ§in `CLOSE EmployeeCursor`, bellekten silmek iÃ§in ise `DEALLOCATE EmployeeCursor` komutlarÄ±nÄ± kullanÄ±yoruz.

Bu yÃ¶ntemle, cursor ile satÄ±r satÄ±r ilerleyerek her bir satÄ±r iÃ§in stored procedure'Ã¼ Ã§aÄŸÄ±rabilirsiniz.

### TEMP TABLE KAVRAMI

Temp table (geÃ§ici tablo), veritabanÄ± iÅŸlemleri sÄ±rasÄ±nda geÃ§ici olarak veri saklamak iÃ§in kullanÄ±lan bir tablo tÃ¼rÃ¼dÃ¼r. Bu tablolar, sadece bir oturum (session) sÃ¼resince geÃ§erlidir ve oturum sona erdiÄŸinde veya tablo silindiÄŸinde otomatik olarak silinirler. Temp table'lar, Ã¶zellikle karmaÅŸÄ±k sorgularda ara sonuÃ§larÄ± depolamak veya geÃ§ici verilerle Ã§alÄ±ÅŸmak iÃ§in kullanÄ±lÄ±r.

***Temp Table TÃ¼rleri***

Temp table'lar iki ana kategoriye ayrÄ±lÄ±r:

1. **Local Temp Table (Yerel GeÃ§ici Tablo):**
    - Bir `#` iÅŸaretiyle baÅŸlar (`#TempTable`).
    - Sadece tabloyu oluÅŸturan oturum tarafÄ±ndan gÃ¶rÃ¼lebilir.
    - Oturum kapandÄ±ÄŸÄ±nda otomatik olarak silinir.
2. **Global Temp Table (KÃ¼resel GeÃ§ici Tablo):**
    - Ä°ki `##` iÅŸaretiyle baÅŸlar (`##TempTable`).
    - Herhangi bir oturumdan eriÅŸilebilir.
    - Son eriÅŸen oturum kapandÄ±ÄŸÄ±nda otomatik olarak silinir.

***Temp Table AvantajlarÄ±***

- **Performans:** Temp table'lar, bÃ¼yÃ¼k veri iÅŸlemleri sÄ±rasÄ±nda geÃ§ici veriyi saklayarak performansÄ± artÄ±rabilir.
- **Kapsam:** Local temp table'lar sadece oluÅŸturulduÄŸu oturumda geÃ§erli olduÄŸundan, veri yalÄ±tÄ±mÄ± saÄŸlar.
- **GeÃ§ici Veri Saklama:** KarmaÅŸÄ±k sorgularda veya geÃ§ici veri saklama ihtiyaÃ§larÄ±nda kullanÄ±ÅŸlÄ±dÄ±r.

***Temp Table KullanÄ±m DurumlarÄ±***

- Ara sonuÃ§larÄ± depolamak.
- KarmaÅŸÄ±k sorgularda veri manipÃ¼lasyonlarÄ±nÄ± basitleÅŸtirmek.
- GeÃ§ici olarak bÃ¼yÃ¼k veri kÃ¼meleriyle Ã§alÄ±ÅŸmak.

Temp table'lar veritabanÄ± iÅŸlemlerinde oldukÃ§a esneklik saÄŸlayan ve performansÄ± artÄ±ran yararlÄ± araÃ§lardÄ±r.

***Temp Table OluÅŸturma***

Bir temp table oluÅŸturmak ve kullanmak oldukÃ§a basittir. 

```sql
-- fiziken bir tablo oluÅŸturalÄ±m
CREATE TABLE ISIMLER (ID INT IDENTITY(1,1), ISIM VARCHAR(100))

-- bir tane kayÄ±t atalÄ±m
INSERT INTO ISIMLER (ISIM) VALUES ('AHMET')

-- bu kaydÄ± listeleyelim
SELECT * FROM ISIMLER

-- temp table oluÅŸturmak iÃ§in tablo isminin Ã¶ncesine (#) iÅŸareti koyulur.
CREATE TABLE #ISIMLER (ID INT IDENTITY(1,1), ISIM VARCHAR(100))

-- ÅŸimdi bu temp table'a veri ekleyelim
INSERT INTO #ISIMLER (ISIM) VALUES ('EMÄ°NE')

-- bu kaydÄ± listeleyelim
SELECT * FROM #ISIMLER
```

BilindiÄŸi Ã¼zere fiziksel tablolarda sadece bir adet aynÄ± isimde tablo oluÅŸturulur. AynÄ±sÄ± oluÅŸturulmaz. Ancak temp tableâ€™da farklÄ± sessionlarda farklÄ± temp tablelar oluÅŸturulabilir.

Bir temp table fiziki bir tablo olmadÄ±ÄŸÄ± iÃ§in session sonunda sona erdiÄŸi iÃ§in direkt veritabanÄ± tablosu iÃ§erisinde yer almaz *System Databases* iÃ§erisinde yer almaktadÄ±r.

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2063.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi oluÅŸturulan Temp table bu hiyerarÅŸide yer almaktadÄ±r.

FarklÄ± bir session aÃ§arak bu temp tableâ€™Ä± gÃ¶rÃ¼ntÃ¼lemeye Ã§alÄ±ÅŸalÄ±m:

```sql
-- farklÄ± bir session'da Ã§alÄ±ÅŸtÄ±ralÄ±m

SELECT * FROM #ISIMLER
```

![image.png](TSQL%20DERS%20NOTLARI%203097002010d541d7b2738b6864248fed/image%2064.png)

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi hata alÄ±ndÄ±. Ã‡Ã¼nkÃ¼ temp tablelar sadece bir sessiona Ã¶zeldir. 

<aside>
ğŸ’¡

FarklÄ± sessionlarda aynÄ± isme sahip birden fazla temp table oluÅŸturulabilir. Bu durum hiÃ§bir problem yapmamaktadÄ±r. Temp tableâ€™Ä±n bu Ã¶zelliÄŸi fiziksel tablolardan ayÄ±ran en bÃ¼yÃ¼k Ã¶zelliÄŸidir.

</aside>

FarklÄ± sessionlarda da kullanÄ±labilir bir temp table kurmak istiyorsak ve oturum sonlandÄ±ÄŸÄ± zaman temp tableâ€™Ä±n silinmesini istiyorsak temp tableâ€™Ä± global olarak tanÄ±mlamamÄ±z gerekmektedir.

Global temp tableâ€™lar `(##)temp_table_ismi` ÅŸeklinde tanÄ±mlanÄ±r.

```sql
-- global session'lu temp table oluÅŸturmak iÃ§in tablo isminin Ã¶ncesine (##) iÅŸareti koyulur.
CREATE TABLE ##ISIMLER (ID INT IDENTITY(1,1), ISIM VARCHAR(100))

-- ÅŸimdi bu temp table'a veri ekleyelim
INSERT INTO ##ISIMLER (ISIM) VALUES ('EMÄ°NE')

-- bu kaydÄ± listeleyelim
SELECT * FROM ##ISIMLER
```

Åimdi farklÄ± bir session aÃ§alÄ±m:

```sql
-- 79 numaralÄ± session

SELECT * FROM ##ISIMLER -- 1 EMÄ°NE

-- veri de ekleyebilirim

INSERT INTO ##ISIMLER VALUES('AHMET')
/*
1	EMÄ°NE
2	AHMET
*/
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi Ã§alÄ±ÅŸmaktadÄ±r.

Åimdi bir Ã¶rnek Ã¼zerinden anlatalÄ±m:

```sql
-- temp table ile ilgili bir Ã¶rnek yapalÄ±m
-- kadÄ±nlar tarafÄ±ndan ne kadar alÄ±nmÄ±ÅŸ, erkekler tarafÄ±ndan ne kadar alÄ±nmÄ±ÅŸ

SELECT 
I.ID, I.ITEMCODE, I.ITEMNAME, U.GENDER,
SUM(OD.LINETOTAL) TOTALSALE
FROM ORDERDETAILS OD
JOIN ORDERS O ON O.ID = OD.ORDERID
JOIN USERS U ON U.ID = O.USERID
JOIN ITEMS I ON I.ID = OD.ITEMID
GROUP BY
I.ID, I.ITEMCODE, I.ITEMNAME, U.GENDER
ORDER BY
I.ITEMCODE, U.GENDER
```

GÃ¶rÃ¼ldÃ¼ÄŸÃ¼ gibi joinlerle bilgilerimizi getirdik.

Åimdi temp table kullanarak bir yapÄ± kuralÄ±m:

```sql
-- ÅŸimdi geÃ§ici bir tablo oluÅŸturalÄ±m

CREATE TABLE #RESULT
(ID INT, ITEMCODE VARCHAR(100), ITEMNAME VARCHAR(100), TOTALSALE_M FLOAT, TOTALSALE_W FLOAT)

SELECT * FROM #RESULT

-- ÅŸimdi tablo iÃ§ini dolduralÄ±m

INSERT INTO #RESULT (ID, ITEMCODE, ITEMNAME)
SELECT ID, ITEMCODE, ITEMNAME FROM ITEMS

UPDATE #RESULT SET TOTALSALE_M =
(
-- ÅŸimdi fiyat hesaplamalarÄ±nÄ± ekleyelim (erkek)
SELECT SUM(LINETOTAL) FROM ORDERDETAILS OD
JOIN ORDERS O ON O.ID = OD.ORDERID
JOIN USERS U ON U.ID = O.USERID
WHERE
ITEMID = #RESULT.ID
AND U.GENDER = 'E'
)

UPDATE #RESULT SET TOTALSALE_W =
(
-- ÅŸimdi fiyat hesaplamalarÄ±nÄ± ekleyelim (kadÄ±n)
SELECT SUM(LINETOTAL) FROM ORDERDETAILS OD
JOIN ORDERS O ON O.ID = OD.ORDERID
JOIN USERS U ON U.ID = O.USERID
WHERE
ITEMID = #RESULT.ID
AND U.GENDER = 'K'
)
```

Bu ÅŸekilde hem kadÄ±nlar iÃ§in hem de erkekler iÃ§in toplam satÄ±ÅŸ miktarÄ±nÄ± getirtmiÅŸ olduk. 

Bu ÅŸekilde yapÄ±lar iÃ§in temp table kullanmak oldukÃ§a basit ve yapÄ±labilir konumdadÄ±r.

### PIVOT ve UNPIVOT KAVRAMI

**Pivot** ve **Unpivot**, SQL Server'da verileri yeniden ÅŸekillendirmek iÃ§in kullanÄ±lan gÃ¼Ã§lÃ¼ araÃ§lardÄ±r. Bu iÅŸlemler, verileri farklÄ± bir perspektiften gÃ¶rmeyi saÄŸlar ve Ã¶zellikle raporlama ve veri analizinde kullanÄ±lÄ±r.

***Pivot Nedir?***

**Pivot**, satÄ±r verilerini sÃ¼tunlara dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lÄ±r. Bir tabloda belirli bir sÃ¼tunun (Ã¶rneÄŸin, aylar veya yÄ±llar) deÄŸerlerini sÃ¼tunlara Ã§evirir ve diÄŸer bir sÃ¼tunun (Ã¶rneÄŸin, satÄ±ÅŸlar) deÄŸerlerini bu sÃ¼tunlarda toplar veya hesaplar.

Bir Ã¶rneÄŸi pivot kullanmadan yapalÄ±m:

```sql
-- cinsiyet Ã¼zerinden ne kadar satÄ±ÅŸ yapmÄ±ÅŸ pivotla yapalÄ±m

SELECT 
CATEGORY1,
CUSTOMERGENDER, SUM(TOTALPRICE) TOTALSALE
FROM SALES
GROUP BY CUSTOMERGENDER, CATEGORY1
ORDER BY CATEGORY1, CUSTOMERGENDER

SELECT 
CATEGORY1, SUM(TOTALSALE_M) AS TOTALSALE_M,
SUM(TOTALSALE_F) TOTALSALE_F
FROM
(
SELECT
CATEGORY1,
CASE WHEN CUSTOMERGENDER = 'E' THEN SUM(TOTALPRICE) ELSE 0 END AS TOTALSALE_M,
CASE WHEN CUSTOMERGENDER = 'K' THEN SUM(TOTALPRICE) ELSE 0 END AS TOTALSALE_F,
CUSTOMERGENDER, SUM(TOTALPRICE) TOTALSALE
FROM SALES
GROUP BY CUSTOMERGENDER, CATEGORY1
) T
GROUP BY CATEGORY1
```

Pivot kullanmadan bu ÅŸekilde bir yapÄ± yapabiliriz.

Ancak pivot kullanarak ise ÅŸu ÅŸekilde bir yapÄ± kurgulamasÄ± yapabiliriz:

```sql
-- ÅŸimdi bunu pivot kavramÄ±yla nasÄ±l yapabiliriz.

SELECT CATEGORY1,[E], [K]
FROM
(
	SELECT CATEGORY1, CUSTOMERGENDER, TOTALPRICE FROM SALES
) SOURCETABLE -- ham veriyi Ã§ekeceÄŸim alanÄ± buraya yazacaÄŸÄ±m
PIVOT
( -- pivotlamak istediÄŸim alanÄ± buraya yazÄ±yorum
	SUM(TOTALPRICE) FOR CUSTOMERGENDER IN ([E], [K])
) PVT
```

Bu ÅŸekilde ham veriyi alarak istediÄŸim ÅŸekilde pivot table oluÅŸturabilirim.

Bir Ã¶rnek daha inceleyelim:

```sql
-- ÅŸehirlerin aylara gÃ¶re kÄ±rÄ±lÄ±mlara bakalÄ±m
SET LANGUAGE turkish -- aylar tÃ¼rkÃ§e gelsin diye dili tÃ¼rkÃ§e ayarladÄ±m.
SELECT CITY, DATENAME(MONTH, DATE_) MONTH_, SUM(TOTALPRICE)
FROM SALES
GROUP BY CITY, DATENAME(MONTH, DATE_)
ORDER BY CITY, DATENAME(MONTH, DATE_)
```

Bu ÅŸekilde satÄ±ÅŸlarÄ±n ÅŸehirlere kÄ±rÄ±lÄ±mÄ±nÄ± ortaya koyan bir script yazdÄ±k.

Peki bunu bir pivotla oluÅŸtursaydÄ±k:

```sql
-- ÅŸimdi bunu pivot kavramÄ±yla nasÄ±l yapabiliriz.

SELECT CITY, [OCAK], [ÅUBAT], [MART], [NÄ°SAN], [MAYIS], [HAZÄ°RAN], [TEMMUZ], [AÄUSTOS], [EYLÃœL], [EKÄ°M], [KASIM], [ARALIK]
FROM
(
	SELECT CITY, DATENAME(MONTH, DATE_) MONTH_, TOTALPRICE FROM SALES
) AS ST -- ham veriyi Ã§ekeceÄŸim alanÄ± buraya yazacaÄŸÄ±m
PIVOT
( -- pivotlamak istediÄŸim alanÄ± buraya yazÄ±yorum
	SUM(TOTALPRICE) FOR MONTH_ IN ([OCAK], [ÅUBAT], [MART], [NÄ°SAN], [MAYIS], [HAZÄ°RAN], [TEMMUZ], [AÄUSTOS], [EYLÃœL], [EKÄ°M], [KASIM], [ARALIK]) -- 12 ay olduÄŸu iÃ§in 12 aya gÃ¶re aldÄ±m
)AS PVT
```

Pivot kullanarak da satÄ±ÅŸ rakamÄ± kÄ±rÄ±lÄ±mÄ±nÄ± bu scriptle Ã¶ÄŸrenebiliriz.

Unpivotta ise iÅŸlem tersi ÅŸekilde ilerleyecektir.

Ã–ncelikle Ã¶zet halde verilmiÅŸ olan tablo ham veriye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lme iÅŸlemi olacaktÄ±r.

```sql
-- kategoriye gÃ¶re farklÄ± verileri nasÄ±l getirtebiliriz gelin bi bakalÄ±m
SELECT * FROM SALESPIVOT
WHERE CATEGORY1 = 'MEYVE'

-- Ã¶zet halde verilmiÅŸ olan veriyi tam haline getirme iÅŸlemi
SELECT CATEGORY1, MONTH_, SALES
FROM
(
	SELECT * FROM SALESPIVOT
) SOURCETABLE
UNPIVOT
(
	SALES FOR MONTH_ IN ([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12]) -- bizim aylarÄ±mÄ±zÄ± temsil etmektedir
) UPVT
```

Bu  ÅŸekilde de Ã¶zet haldeki veriyi ham hale Ã§evirmiÅŸ olduk.

Ve artÄ±k TSQL konularÄ±mÄ±zÄ±n sonuna gelmiÅŸ bulunmaktayÄ±z.

Bir sonraki teknik bloglarÄ±mÄ±zda gÃ¶rÃ¼ÅŸmek dileyiÄŸleâ€¦

HoÅŸ kalÄ±n! HoÅŸÃ§akalÄ±n!